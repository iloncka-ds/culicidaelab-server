{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CulicidaeLab Server Documentation","text":"CulicidaeLab Server <p>     Advanced mosquito research platform combining AI-powered species identification     with comprehensive surveillance data management and analytics   </p> Get Started API Reference"},{"location":"#overview","title":"Overview","text":"<p>CulicidaeLab Server combines a powerful Python-based backend API (FastAPI) with a dynamic frontend (Solara) to provide researchers, scientists, and public health professionals with advanced tools for mosquito species identification, surveillance data management, and predictive analytics.</p>"},{"location":"#platform-overview","title":"Platform Overview","text":"<p>CulicidaeLab Server is a cutting-edge web platform that revolutionizes mosquito research through the integration of artificial intelligence, geospatial analysis, and comprehensive data management. Built with modern technologies and scientific rigor, it serves researchers, public health professionals, and surveillance programs worldwide.</p> \ud83e\udd16 AI-Powered Identification <p>       Advanced machine learning models for accurate mosquito species identification       using morphological and molecular data     </p> \ud83d\uddfa\ufe0f Geospatial Analytics <p>       Interactive mapping and spatial analysis tools for surveillance data       visualization and pattern recognition     </p> \ud83d\udcca Data Management <p>       Comprehensive database system for storing, organizing, and analyzing       mosquito surveillance and research data     </p> \ud83d\udd17 API Integration <p>       RESTful API for seamless integration with external systems,       databases, and third-party applications     </p> \ud83d\udcc8 Real-time Analytics <p>       Live data processing and visualization capabilities for       immediate insights and decision-making     </p> \ud83d\udd2c Research Tools <p>       Specialized tools and workflows designed specifically for       mosquito research and surveillance programs     </p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"\ud83d\ude80 Getting Started <p>Quick installation and setup guides to get you up and running with CulicidaeLab Server.</p> Installation Guide \u2022     Quick Start \u2022     Configuration \ud83d\udc65 User Guide <p>Comprehensive guides for using the platform's features and capabilities.</p> Platform Overview \u2022     Species Prediction \u2022     Map Visualization \ud83d\udee0\ufe0f Developer Guide <p>Technical documentation for developers and system integrators.</p> Architecture \u2022     API Reference \u2022     Contributing \ud83d\ude80 Deployment <p>Production deployment guides and system administration documentation.</p> Production Setup \u2022     Docker Deployment \u2022     Monitoring \ud83d\udd2c Research <p>Scientific documentation covering AI models, datasets, and methodologies.</p> Data Models \u2022     AI Models \u2022     Datasets \ud83d\udcda Reference <p>Complete API reference, configuration options, and technical specifications.</p> API Documentation \u2022     Configuration \u2022     Changelog"},{"location":"#system-status","title":"System Status","text":"System Online  <p>The CulicidaeLab Server platform is currently operational and serving researchers worldwide.</p>"},{"location":"#quick-actions","title":"Quick Actions","text":"Install Now View Examples Try Prediction View Source"},{"location":"#community-support","title":"Community &amp; Support","text":"Join our community! Connect with researchers and developers using CulicidaeLab Server.  <ul> <li>\ud83d\udc1b Issues: Report bugs and request features on GitHub Issues</li> <li>\ud83d\udcac Discussions: Join community discussions on GitHub Discussions</li> <li>\ud83d\udce7 Contact: Reach out to the team at culicidaelab@gmail.com</li> <li>\ud83c\udf10 Website: Visit https://github.com/culicidaelab for more information</li> </ul> <p>This documentation is automatically generated and deployed. Last updated: 2025-10-17</p>"},{"location":"deployment/docker/","title":"Docker Deployment","text":"<p>This guide covers deploying CulicidaeLab Server using Docker containers. Docker provides a consistent, portable deployment environment that simplifies setup and scaling.</p>"},{"location":"deployment/docker/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker Engine 20.10+ installed</li> <li>Docker Compose 2.0+ installed</li> <li>At least 4GB RAM and 2 CPU cores</li> <li>10GB+ available disk space</li> </ul>"},{"location":"deployment/docker/#docker-setup","title":"Docker Setup","text":""},{"location":"deployment/docker/#1-create-dockerfile-for-backend","title":"1. Create Dockerfile for Backend","text":"<p>Create <code>backend/Dockerfile</code>:</p> <pre><code>FROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\nENV DEBIAN_FRONTEND=noninteractive\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    curl \\\n    git \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create app directory\nWORKDIR /app\n\n# Install uv for faster dependency management\nRUN pip install uv\n\n# Copy dependency files\nCOPY pyproject.toml uv.lock ./\nCOPY backend/ ./backend/\n\n# Install Python dependencies\nRUN uv sync --frozen --no-dev\n\n# Create non-root user\nRUN useradd --create-home --shell /bin/bash app\nRUN chown -R app:app /app\nUSER app\n\n# Create data directories\nRUN mkdir -p /app/data /app/models /app/logs\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Start command\nCMD [\"uv\", \"run\", \"uvicorn\", \"backend.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"deployment/docker/#2-create-dockerfile-for-frontend","title":"2. Create Dockerfile for Frontend","text":"<p>Create <code>frontend/Dockerfile</code>:</p> <pre><code>FROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\nENV DEBIAN_FRONTEND=noninteractive\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    curl \\\n    git \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create app directory\nWORKDIR /app\n\n# Install uv for faster dependency management\nRUN pip install uv\n\n# Copy dependency files\nCOPY pyproject.toml uv.lock ./\nCOPY frontend/ ./frontend/\nCOPY backend/config.py ./backend/config.py\nCOPY backend/__init__.py ./backend/__init__.py\n\n# Install Python dependencies\nRUN uv sync --frozen --no-dev\n\n# Create non-root user\nRUN useradd --create-home --shell /bin/bash app\nRUN chown -R app:app /app\nUSER app\n\n# Expose port\nEXPOSE 8765\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8765/ || exit 1\n\n# Start command\nCMD [\"uv\", \"run\", \"solara\", \"run\", \"frontend.main:routes\", \"--host\", \"0.0.0.0\", \"--port\", \"8765\", \"--production\"]\n</code></pre>"},{"location":"deployment/docker/#3-create-multi-stage-dockerfile-recommended","title":"3. Create Multi-stage Dockerfile (Recommended)","text":"<p>Create <code>Dockerfile</code> in project root:</p> <pre><code># Multi-stage build for optimized production image\nFROM python:3.11-slim as base\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\nENV DEBIAN_FRONTEND=noninteractive\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    curl \\\n    git \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install uv\nRUN pip install uv\n\n# Build stage\nFROM base as builder\n\nWORKDIR /app\n\n# Copy dependency files\nCOPY pyproject.toml uv.lock ./\n\n# Install dependencies\nRUN uv sync --frozen --no-dev\n\n# Production stage\nFROM base as production\n\nWORKDIR /app\n\n# Copy virtual environment from builder\nCOPY --from=builder /app/.venv /app/.venv\n\n# Copy application code\nCOPY backend/ ./backend/\nCOPY frontend/ ./frontend/\n\n# Create non-root user\nRUN useradd --create-home --shell /bin/bash app\nRUN chown -R app:app /app\nUSER app\n\n# Create data directories\nRUN mkdir -p /app/data /app/models /app/logs\n\n# Backend image\nFROM production as backend\nEXPOSE 8000\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\nCMD [\"/app/.venv/bin/uvicorn\", \"backend.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n\n# Frontend image\nFROM production as frontend\nEXPOSE 8765\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8765/ || exit 1\nCMD [\"/app/.venv/bin/solara\", \"run\", \"frontend.main:routes\", \"--host\", \"0.0.0.0\", \"--port\", \"8765\", \"--production\"]\n</code></pre>"},{"location":"deployment/docker/#docker-compose-configuration","title":"Docker Compose Configuration","text":""},{"location":"deployment/docker/#1-basic-docker-compose","title":"1. Basic Docker Compose","text":"<p>Create <code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  backend:\n    build:\n      context: .\n      target: backend\n    ports:\n      - \"8000:8000\"\n    environment:\n      - CULICIDAELAB_DATABASE_PATH=/app/data/.lancedb\n      - CULICIDAELAB_SAVE_PREDICTED_IMAGES=1\n      - ENVIRONMENT=production\n    volumes:\n      - ./data:/app/data\n      - ./models:/app/models\n      - ./logs:/app/logs\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  frontend:\n    build:\n      context: .\n      target: frontend\n    ports:\n      - \"8765:8765\"\n    environment:\n      - BACKEND_URL=http://backend:8000\n    depends_on:\n      backend:\n        condition: service_healthy\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8765/\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./ssl:/etc/nginx/ssl:ro\n    depends_on:\n      - backend\n      - frontend\n    restart: unless-stopped\n\nvolumes:\n  data:\n  models:\n  logs:\n</code></pre>"},{"location":"deployment/docker/#2-production-docker-compose","title":"2. Production Docker Compose","text":"<p>Create <code>docker-compose.prod.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  backend:\n    build:\n      context: .\n      target: backend\n    environment:\n      - CULICIDAELAB_DATABASE_PATH=/app/data/.lancedb\n      - CULICIDAELAB_SAVE_PREDICTED_IMAGES=1\n      - ENVIRONMENT=production\n    volumes:\n      - data:/app/data\n      - models:/app/models\n      - logs:/app/logs\n    restart: unless-stopped\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          cpus: '1.0'\n          memory: 2G\n        reservations:\n          cpus: '0.5'\n          memory: 1G\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  frontend:\n    build:\n      context: .\n      target: frontend\n    environment:\n      - BACKEND_URL=http://backend:8000\n    depends_on:\n      backend:\n        condition: service_healthy\n    restart: unless-stopped\n    deploy:\n      replicas: 1\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 1G\n        reservations:\n          cpus: '0.25'\n          memory: 512M\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8765/\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./nginx/ssl:/etc/nginx/ssl:ro\n    depends_on:\n      - backend\n      - frontend\n    restart: unless-stopped\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n\n  redis:\n    image: redis:alpine\n    restart: unless-stopped\n    deploy:\n      resources:\n        limits:\n          cpus: '0.25'\n          memory: 256M\n\nvolumes:\n  data:\n    driver: local\n  models:\n    driver: local\n  logs:\n    driver: local\n\nnetworks:\n  default:\n    driver: bridge\n</code></pre>"},{"location":"deployment/docker/#nginx-configuration-for-docker","title":"Nginx Configuration for Docker","text":"<p>Create <code>nginx/nginx.conf</code>:</p> <pre><code>events {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream backend {\n        server backend:8000;\n    }\n\n    upstream frontend {\n        server frontend:8765;\n    }\n\n    server {\n        listen 80;\n        server_name localhost;\n\n        # Redirect HTTP to HTTPS in production\n        # return 301 https://$server_name$request_uri;\n\n        # Frontend\n        location / {\n            proxy_pass http://frontend;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # WebSocket support\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n        }\n\n        # Backend API\n        location /api {\n            proxy_pass http://backend;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # Increase timeout for model predictions\n            proxy_read_timeout 300s;\n            proxy_connect_timeout 75s;\n        }\n\n        # Health checks\n        location /health {\n            access_log off;\n            return 200 \"healthy\\n\";\n            add_header Content-Type text/plain;\n        }\n    }\n\n    # HTTPS server (uncomment for production)\n    # server {\n    #     listen 443 ssl http2;\n    #     server_name your-domain.com;\n    #     \n    #     ssl_certificate /etc/nginx/ssl/certificate.crt;\n    #     ssl_certificate_key /etc/nginx/ssl/private.key;\n    #     \n    #     # Include locations from above\n    # }\n}\n</code></pre>"},{"location":"deployment/docker/#deployment-commands","title":"Deployment Commands","text":""},{"location":"deployment/docker/#1-development-deployment","title":"1. Development Deployment","text":"<pre><code># Build and start services\ndocker-compose up --build\n\n# Run in background\ndocker-compose up -d --build\n\n# View logs\ndocker-compose logs -f\n\n# Stop services\ndocker-compose down\n</code></pre>"},{"location":"deployment/docker/#2-production-deployment","title":"2. Production Deployment","text":"<pre><code># Build and start production services\ndocker-compose -f docker-compose.prod.yml up -d --build\n\n# Scale backend services\ndocker-compose -f docker-compose.prod.yml up -d --scale backend=3\n\n# Update services\ndocker-compose -f docker-compose.prod.yml pull\ndocker-compose -f docker-compose.prod.yml up -d --no-deps backend frontend\n\n# View service status\ndocker-compose -f docker-compose.prod.yml ps\n</code></pre>"},{"location":"deployment/docker/#3-docker-swarm-deployment","title":"3. Docker Swarm Deployment","text":"<pre><code># Initialize swarm\ndocker swarm init\n\n# Deploy stack\ndocker stack deploy -c docker-compose.prod.yml culicidaelab\n\n# Scale services\ndocker service scale culicidaelab_backend=3\n\n# Update service\ndocker service update --image culicidaelab_backend:latest culicidaelab_backend\n\n# Remove stack\ndocker stack rm culicidaelab\n</code></pre>"},{"location":"deployment/docker/#environment-variables","title":"Environment Variables","text":""},{"location":"deployment/docker/#backend-environment-variables","title":"Backend Environment Variables","text":"<pre><code># Required\nCULICIDAELAB_DATABASE_PATH=/app/data/.lancedb\nCULICIDAELAB_SAVE_PREDICTED_IMAGES=1\nENVIRONMENT=production\n\n# Optional\nCULICIDAELAB_MODEL_PATH=/app/models\nCULICIDAELAB_LOG_LEVEL=INFO\nCULICIDAELAB_WORKERS=4\nCULICIDAELAB_BACKEND_CORS_ORIGINS=http://localhost:8765\n</code></pre>"},{"location":"deployment/docker/#frontend-environment-variables","title":"Frontend Environment Variables","text":"<pre><code># Backend connection\nBACKEND_URL=http://backend:8000\nFRONTEND_PORT=8765\nFRONTEND_HOST=0.0.0.0\n</code></pre>"},{"location":"deployment/docker/#data-persistence","title":"Data Persistence","text":""},{"location":"deployment/docker/#1-volume-management","title":"1. Volume Management","text":"<pre><code># Create named volumes\ndocker volume create culicidaelab_data\ndocker volume create culicidaelab_models\ndocker volume create culicidaelab_logs\n\n# Backup volumes\ndocker run --rm -v culicidaelab_data:/data -v $(pwd):/backup alpine tar czf /backup/data-backup.tar.gz /data\n\n# Restore volumes\ndocker run --rm -v culicidaelab_data:/data -v $(pwd):/backup alpine tar xzf /backup/data-backup.tar.gz -C /\n</code></pre>"},{"location":"deployment/docker/#2-bind-mounts","title":"2. Bind Mounts","text":"<pre><code># In docker-compose.yml\nvolumes:\n  - ./data:/app/data              # Database files\n  - ./models:/app/models          # Model files\n  - ./logs:/app/logs              # Application logs\n  - ./uploads:/app/uploads        # User uploads\n</code></pre>"},{"location":"deployment/docker/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"deployment/docker/#1-container-monitoring","title":"1. Container Monitoring","text":"<pre><code># Monitor resource usage\ndocker stats\n\n# View container logs\ndocker-compose logs -f backend\ndocker-compose logs -f frontend\n\n# Execute commands in containers\ndocker-compose exec backend bash\ndocker-compose exec frontend bash\n</code></pre>"},{"location":"deployment/docker/#2-log-configuration","title":"2. Log Configuration","text":"<p>Create <code>docker-compose.override.yml</code> for logging:</p> <pre><code>version: '3.8'\n\nservices:\n  backend:\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n\n  frontend:\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n</code></pre>"},{"location":"deployment/docker/#security-best-practices","title":"Security Best Practices","text":""},{"location":"deployment/docker/#1-container-security","title":"1. Container Security","text":"<pre><code># Use non-root user\nRUN useradd --create-home --shell /bin/bash app\nUSER app\n\n# Remove unnecessary packages\nRUN apt-get remove --purge -y build-essential &amp;&amp; \\\n    apt-get autoremove -y &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# Set proper file permissions\nRUN chmod -R 755 /app\n</code></pre>"},{"location":"deployment/docker/#2-network-security","title":"2. Network Security","text":"<pre><code># In docker-compose.yml\nnetworks:\n  frontend:\n    driver: bridge\n  backend:\n    driver: bridge\n    internal: true  # No external access\n\nservices:\n  backend:\n    networks:\n      - backend\n  frontend:\n    networks:\n      - frontend\n      - backend\n</code></pre>"},{"location":"deployment/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/docker/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Container Won't Start <pre><code>docker-compose logs backend\ndocker-compose logs frontend\n</code></pre></p> </li> <li> <p>Port Conflicts <pre><code># Check port usage\nnetstat -tulpn | grep :8000\n\n# Use different ports\nports:\n  - \"8001:8000\"  # Map to different host port\n</code></pre></p> </li> <li> <p>Volume Permission Issues <pre><code># Fix permissions\nsudo chown -R 1000:1000 ./data\nsudo chmod -R 755 ./data\n</code></pre></p> </li> <li> <p>Memory Issues <pre><code># Increase memory limits\ndeploy:\n  resources:\n    limits:\n      memory: 4G\n</code></pre></p> </li> </ol>"},{"location":"deployment/docker/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Multi-stage Builds to reduce image size</li> <li>Layer Caching for faster builds</li> <li>Resource Limits to prevent resource exhaustion</li> <li>Health Checks for proper load balancing</li> <li>Log Rotation to manage disk usage</li> </ol>"},{"location":"deployment/docker/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"deployment/docker/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Build and Deploy\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build Docker images\n        run: |\n          docker build -t culicidaelab-backend --target backend .\n          docker build -t culicidaelab-frontend --target frontend .\n\n      - name: Deploy to production\n        run: |\n          docker-compose -f docker-compose.prod.yml up -d\n</code></pre>"},{"location":"deployment/monitoring/","title":"Monitoring and Logging","text":"<p>This guide covers comprehensive monitoring and logging strategies for CulicidaeLab Server, including application metrics, performance monitoring, log management, and alerting systems.</p>"},{"location":"deployment/monitoring/#overview","title":"Overview","text":"<p>Effective monitoring and logging are crucial for maintaining a healthy production environment. This document covers:</p> <ul> <li>Application health monitoring</li> <li>Performance metrics collection</li> <li>Log aggregation and analysis</li> <li>Alerting and notification systems</li> <li>Troubleshooting and debugging</li> </ul>"},{"location":"deployment/monitoring/#application-health-monitoring","title":"Application Health Monitoring","text":""},{"location":"deployment/monitoring/#health-check-endpoints","title":"Health Check Endpoints","text":"<p>CulicidaeLab Server provides several health check endpoints for monitoring:</p>"},{"location":"deployment/monitoring/#basic-health-check","title":"Basic Health Check","text":"<pre><code>GET /health\n</code></pre> <p>Response: <pre><code>{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-01T12:00:00Z\"\n}\n</code></pre></p>"},{"location":"deployment/monitoring/#detailed-api-health-check","title":"Detailed API Health Check","text":"<pre><code>GET /api/health\n</code></pre> <p>Response: <pre><code>{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-01T12:00:00Z\",\n  \"database\": {\n    \"status\": \"connected\",\n    \"response_time_ms\": 15\n  },\n  \"models\": {\n    \"segmenter\": {\n      \"status\": \"loaded\",\n      \"load_time_ms\": 2500\n    }\n  },\n  \"memory\": {\n    \"used_mb\": 1024,\n    \"available_mb\": 2048\n  }\n}\n</code></pre></p>"},{"location":"deployment/monitoring/#custom-health-checks","title":"Custom Health Checks","text":"<p>Implement custom health checks for critical components:</p> <pre><code># backend/services/health.py\nfrom typing import Dict, Any\nimport time\nimport psutil\nfrom backend.services.database import get_db\nfrom backend.config import get_predictor_model_path\n\nasync def check_database_health() -&gt; Dict[str, Any]:\n    \"\"\"Check database connectivity and performance\"\"\"\n    start_time = time.time()\n    try:\n        db = get_db()\n        # Perform a simple query\n        result = db.query(\"SELECT 1\").limit(1).to_list()\n        response_time = (time.time() - start_time) * 1000\n\n        return {\n            \"status\": \"connected\",\n            \"response_time_ms\": round(response_time, 2)\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"error\": str(e)\n        }\n\nasync def check_model_health() -&gt; Dict[str, Any]:\n    \"\"\"Check model availability and loading status\"\"\"\n    try:\n        model_path = get_predictor_model_path()\n        if not os.path.exists(model_path):\n            return {\n                \"status\": \"error\",\n                \"error\": \"Model file not found\"\n            }\n\n        # Check if model can be loaded (simplified check)\n        return {\n            \"status\": \"loaded\",\n            \"path\": model_path\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"error\": str(e)\n        }\n\nasync def check_system_resources() -&gt; Dict[str, Any]:\n    \"\"\"Check system resource usage\"\"\"\n    memory = psutil.virtual_memory()\n    disk = psutil.disk_usage('/')\n\n    return {\n        \"memory\": {\n            \"used_mb\": round(memory.used / 1024 / 1024, 2),\n            \"available_mb\": round(memory.available / 1024 / 1024, 2),\n            \"percent\": memory.percent\n        },\n        \"disk\": {\n            \"used_gb\": round(disk.used / 1024 / 1024 / 1024, 2),\n            \"free_gb\": round(disk.free / 1024 / 1024 / 1024, 2),\n            \"percent\": round((disk.used / disk.total) * 100, 2)\n        }\n    }\n</code></pre>"},{"location":"deployment/monitoring/#performance-metrics","title":"Performance Metrics","text":""},{"location":"deployment/monitoring/#application-metrics","title":"Application Metrics","text":""},{"location":"deployment/monitoring/#request-metrics","title":"Request Metrics","text":"<ul> <li>Request count per endpoint</li> <li>Response time percentiles (p50, p95, p99)</li> <li>Error rates by status code</li> <li>Concurrent request count</li> </ul>"},{"location":"deployment/monitoring/#model-performance-metrics","title":"Model Performance Metrics","text":"<ul> <li>Prediction latency</li> <li>Model loading time</li> <li>Prediction accuracy (if ground truth available)</li> <li>Memory usage during inference</li> </ul>"},{"location":"deployment/monitoring/#database-metrics","title":"Database Metrics","text":"<ul> <li>Query execution time</li> <li>Connection pool usage</li> <li>Database size and growth</li> <li>Index performance</li> </ul>"},{"location":"deployment/monitoring/#metrics-collection-with-prometheus","title":"Metrics Collection with Prometheus","text":"<p>Install and configure Prometheus metrics:</p> <pre><code># Add to pyproject.toml\npip install prometheus-client\n</code></pre> <pre><code># backend/services/metrics.py\nfrom prometheus_client import Counter, Histogram, Gauge, generate_latest\nimport time\nfrom functools import wraps\n\n# Define metrics\nREQUEST_COUNT = Counter(\n    'culicidaelab_requests_total',\n    'Total number of requests',\n    ['method', 'endpoint', 'status']\n)\n\nREQUEST_DURATION = Histogram(\n    'culicidaelab_request_duration_seconds',\n    'Request duration in seconds',\n    ['method', 'endpoint']\n)\n\nPREDICTION_DURATION = Histogram(\n    'culicidaelab_prediction_duration_seconds',\n    'Model prediction duration in seconds',\n    ['model_type']\n)\n\nACTIVE_CONNECTIONS = Gauge(\n    'culicidaelab_active_connections',\n    'Number of active database connections'\n)\n\nMODEL_MEMORY_USAGE = Gauge(\n    'culicidaelab_model_memory_mb',\n    'Memory usage by loaded models in MB',\n    ['model_name']\n)\n\ndef track_requests(func):\n    \"\"\"Decorator to track request metrics\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        start_time = time.time()\n        status = \"200\"\n\n        try:\n            result = await func(*args, **kwargs)\n            return result\n        except Exception as e:\n            status = \"500\"\n            raise\n        finally:\n            duration = time.time() - start_time\n            REQUEST_DURATION.labels(\n                method=\"POST\",  # Adjust based on actual method\n                endpoint=func.__name__\n            ).observe(duration)\n            REQUEST_COUNT.labels(\n                method=\"POST\",\n                endpoint=func.__name__,\n                status=status\n            ).inc()\n\n    return wrapper\n\ndef track_prediction_time(model_type: str):\n    \"\"\"Decorator to track prediction timing\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            start_time = time.time()\n            try:\n                result = await func(*args, **kwargs)\n                return result\n            finally:\n                duration = time.time() - start_time\n                PREDICTION_DURATION.labels(model_type=model_type).observe(duration)\n        return wrapper\n    return decorator\n\n# Metrics endpoint\nfrom fastapi import Response\n\n@app.get(\"/metrics\")\nasync def metrics():\n    \"\"\"Prometheus metrics endpoint\"\"\"\n    return Response(\n        generate_latest(),\n        media_type=\"text/plain\"\n    )\n</code></pre>"},{"location":"deployment/monitoring/#metrics-dashboard-with-grafana","title":"Metrics Dashboard with Grafana","text":"<p>Create Grafana dashboard configuration:</p> <pre><code>{\n  \"dashboard\": {\n    \"title\": \"CulicidaeLab Server Metrics\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(culicidaelab_requests_total[5m])\",\n            \"legendFormat\": \"{{endpoint}} - {{status}}\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Response Time\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, rate(culicidaelab_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"95th percentile\"\n          },\n          {\n            \"expr\": \"histogram_quantile(0.50, rate(culicidaelab_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"50th percentile\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Prediction Latency\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, rate(culicidaelab_prediction_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"{{model_type}} - 95th percentile\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Memory Usage\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"culicidaelab_model_memory_mb\",\n            \"legendFormat\": \"{{model_name}}\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"deployment/monitoring/#logging-configuration","title":"Logging Configuration","text":""},{"location":"deployment/monitoring/#structured-logging","title":"Structured Logging","text":"<p>Configure structured logging for better analysis:</p> <pre><code># backend/services/logging.py\nimport logging\nimport json\nimport sys\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"Custom JSON formatter for structured logging\"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        log_entry = {\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno\n        }\n\n        # Add extra fields if present\n        if hasattr(record, 'request_id'):\n            log_entry['request_id'] = record.request_id\n        if hasattr(record, 'user_id'):\n            log_entry['user_id'] = record.user_id\n        if hasattr(record, 'duration_ms'):\n            log_entry['duration_ms'] = record.duration_ms\n        if hasattr(record, 'status_code'):\n            log_entry['status_code'] = record.status_code\n\n        # Add exception info if present\n        if record.exc_info:\n            log_entry['exception'] = self.formatException(record.exc_info)\n\n        return json.dumps(log_entry)\n\ndef setup_logging(log_level: str = \"INFO\", log_file: str = None):\n    \"\"\"Configure application logging\"\"\"\n\n    # Create logger\n    logger = logging.getLogger(\"culicidaelab\")\n    logger.setLevel(getattr(logging, log_level.upper()))\n\n    # Remove existing handlers\n    for handler in logger.handlers[:]:\n        logger.removeHandler(handler)\n\n    # Create formatter\n    formatter = JSONFormatter()\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    # File handler (if specified)\n    if log_file:\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    return logger\n\n# Request logging middleware\nimport uuid\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware to log HTTP requests and responses\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        # Generate request ID\n        request_id = str(uuid.uuid4())\n\n        # Log request\n        logger = logging.getLogger(\"culicidaelab.requests\")\n        start_time = time.time()\n\n        logger.info(\n            \"Request started\",\n            extra={\n                \"request_id\": request_id,\n                \"method\": request.method,\n                \"url\": str(request.url),\n                \"user_agent\": request.headers.get(\"user-agent\"),\n                \"client_ip\": request.client.host\n            }\n        )\n\n        # Process request\n        try:\n            response = await call_next(request)\n            status_code = response.status_code\n        except Exception as e:\n            status_code = 500\n            logger.error(\n                \"Request failed with exception\",\n                extra={\n                    \"request_id\": request_id,\n                    \"exception\": str(e)\n                },\n                exc_info=True\n            )\n            raise\n        finally:\n            # Log response\n            duration_ms = (time.time() - start_time) * 1000\n            logger.info(\n                \"Request completed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"status_code\": status_code,\n                    \"duration_ms\": round(duration_ms, 2)\n                }\n            )\n\n        return response\n</code></pre>"},{"location":"deployment/monitoring/#log-aggregation","title":"Log Aggregation","text":""},{"location":"deployment/monitoring/#elk-stack-elasticsearch-logstash-kibana","title":"ELK Stack (Elasticsearch, Logstash, Kibana)","text":"<p>Docker Compose configuration for ELK stack:</p> <pre><code># docker-compose.elk.yml\nversion: '3.8'\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    ports:\n      - \"9200:9200\"\n    volumes:\n      - elasticsearch_data:/usr/share/elasticsearch/data\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:8.11.0\n    ports:\n      - \"5044:5044\"\n    volumes:\n      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf\n    depends_on:\n      - elasticsearch\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.11.0\n    ports:\n      - \"5601:5601\"\n    environment:\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\n    depends_on:\n      - elasticsearch\n\nvolumes:\n  elasticsearch_data:\n</code></pre> <p>Logstash configuration (<code>logstash.conf</code>):</p> <pre><code>input {\n  beats {\n    port =&gt; 5044\n  }\n}\n\nfilter {\n  if [fields][service] == \"culicidaelab\" {\n    json {\n      source =&gt; \"message\"\n    }\n\n    date {\n      match =&gt; [ \"timestamp\", \"ISO8601\" ]\n    }\n\n    if [level] == \"ERROR\" or [level] == \"CRITICAL\" {\n      mutate {\n        add_tag =&gt; [ \"error\" ]\n      }\n    }\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts =&gt; [\"elasticsearch:9200\"]\n    index =&gt; \"culicidaelab-logs-%{+YYYY.MM.dd}\"\n  }\n}\n</code></pre>"},{"location":"deployment/monitoring/#filebeat-configuration","title":"Filebeat Configuration","text":"<p>Configure Filebeat to ship logs to Logstash:</p> <pre><code># filebeat.yml\nfilebeat.inputs:\n- type: log\n  enabled: true\n  paths:\n    - /var/log/culicidaelab/*.log\n  fields:\n    service: culicidaelab\n  fields_under_root: true\n  json.keys_under_root: true\n  json.add_error_key: true\n\noutput.logstash:\n  hosts: [\"logstash:5044\"]\n\nprocessors:\n  - add_host_metadata:\n      when.not.contains.tags: forwarded\n</code></pre>"},{"location":"deployment/monitoring/#log-analysis-and-alerting","title":"Log Analysis and Alerting","text":""},{"location":"deployment/monitoring/#kibana-dashboards","title":"Kibana Dashboards","text":"<p>Create Kibana visualizations for:</p> <ol> <li>Request Volume: Requests per minute/hour</li> <li>Error Rate: Error percentage over time</li> <li>Response Time: Response time percentiles</li> <li>Geographic Distribution: Request origins on map</li> <li>User Activity: Active users and sessions</li> </ol>"},{"location":"deployment/monitoring/#log-based-alerts","title":"Log-based Alerts","text":"<p>Configure alerts for critical events:</p> <pre><code>{\n  \"alert\": {\n    \"name\": \"High Error Rate\",\n    \"condition\": {\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            {\"term\": {\"level\": \"ERROR\"}},\n            {\"range\": {\"@timestamp\": {\"gte\": \"now-5m\"}}}\n          ]\n        }\n      },\n      \"threshold\": 10\n    },\n    \"actions\": [\n      {\n        \"type\": \"email\",\n        \"to\": [\"admin@culicidaelab.com\"],\n        \"subject\": \"CulicidaeLab: High Error Rate Alert\"\n      },\n      {\n        \"type\": \"slack\",\n        \"webhook\": \"https://hooks.slack.com/...\",\n        \"message\": \"High error rate detected in CulicidaeLab\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"deployment/monitoring/#system-monitoring","title":"System Monitoring","text":""},{"location":"deployment/monitoring/#infrastructure-monitoring","title":"Infrastructure Monitoring","text":""},{"location":"deployment/monitoring/#server-metrics","title":"Server Metrics","text":"<p>Monitor key system metrics:</p> <ul> <li>CPU usage and load average</li> <li>Memory usage and swap</li> <li>Disk usage and I/O</li> <li>Network traffic and connections</li> <li>Process count and status</li> </ul>"},{"location":"deployment/monitoring/#docker-monitoring","title":"Docker Monitoring","text":"<p>For containerized deployments:</p> <pre><code># docker-compose.monitoring.yml\nversion: '3.8'\n\nservices:\n  prometheus:\n    image: prom/prometheus\n    ports:\n      - \"9090:9090\"\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n      - prometheus_data:/prometheus\n\n  grafana:\n    image: grafana/grafana\n    ports:\n      - \"3000:3000\"\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n    volumes:\n      - grafana_data:/var/lib/grafana\n\n  node-exporter:\n    image: prom/node-exporter\n    ports:\n      - \"9100:9100\"\n    volumes:\n      - /proc:/host/proc:ro\n      - /sys:/host/sys:ro\n      - /:/rootfs:ro\n\n  cadvisor:\n    image: gcr.io/cadvisor/cadvisor\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - /:/rootfs:ro\n      - /var/run:/var/run:ro\n      - /sys:/sys:ro\n      - /var/lib/docker/:/var/lib/docker:ro\n\nvolumes:\n  prometheus_data:\n  grafana_data:\n</code></pre>"},{"location":"deployment/monitoring/#database-monitoring","title":"Database Monitoring","text":"<p>Monitor LanceDB performance:</p> <pre><code># backend/services/db_monitoring.py\nimport time\nimport psutil\nfrom typing import Dict, Any\n\nclass DatabaseMonitor:\n    \"\"\"Monitor database performance and health\"\"\"\n\n    def __init__(self, db_path: str):\n        self.db_path = db_path\n\n    def get_database_metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Collect database performance metrics\"\"\"\n\n        # Database size\n        db_size = self._get_directory_size(self.db_path)\n\n        # Query performance (example)\n        query_times = self._measure_query_performance()\n\n        # Connection count (if applicable)\n        connection_count = self._get_connection_count()\n\n        return {\n            \"size_mb\": round(db_size / 1024 / 1024, 2),\n            \"query_times\": query_times,\n            \"connections\": connection_count,\n            \"timestamp\": time.time()\n        }\n\n    def _get_directory_size(self, path: str) -&gt; int:\n        \"\"\"Calculate directory size in bytes\"\"\"\n        total_size = 0\n        for dirpath, dirnames, filenames in os.walk(path):\n            for filename in filenames:\n                filepath = os.path.join(dirpath, filename)\n                total_size += os.path.getsize(filepath)\n        return total_size\n\n    def _measure_query_performance(self) -&gt; Dict[str, float]:\n        \"\"\"Measure query execution times\"\"\"\n        # Implement query timing logic\n        return {\n            \"avg_query_time_ms\": 15.5,\n            \"max_query_time_ms\": 150.0,\n            \"queries_per_second\": 25.0\n        }\n\n    def _get_connection_count(self) -&gt; int:\n        \"\"\"Get active connection count\"\"\"\n        # Implement connection counting logic\n        return 5\n</code></pre>"},{"location":"deployment/monitoring/#alerting-and-notifications","title":"Alerting and Notifications","text":""},{"location":"deployment/monitoring/#alert-rules","title":"Alert Rules","text":"<p>Define alert rules for critical conditions:</p> <pre><code># prometheus-alerts.yml\ngroups:\n  - name: culicidaelab-alerts\n    rules:\n      - alert: HighErrorRate\n        expr: rate(culicidaelab_requests_total{status=~\"5..\"}[5m]) &gt; 0.1\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value }} errors per second\"\n\n      - alert: HighResponseTime\n        expr: histogram_quantile(0.95, rate(culicidaelab_request_duration_seconds_bucket[5m])) &gt; 5\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High response time detected\"\n          description: \"95th percentile response time is {{ $value }} seconds\"\n\n      - alert: DatabaseConnectionFailure\n        expr: up{job=\"culicidaelab-backend\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Database connection failure\"\n          description: \"Cannot connect to database\"\n\n      - alert: HighMemoryUsage\n        expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes &gt; 0.9\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High memory usage\"\n          description: \"Memory usage is {{ $value | humanizePercentage }}\"\n\n      - alert: DiskSpaceLow\n        expr: (node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes &gt; 0.85\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Low disk space\"\n          description: \"Disk usage is {{ $value | humanizePercentage }}\"\n</code></pre>"},{"location":"deployment/monitoring/#notification-channels","title":"Notification Channels","text":""},{"location":"deployment/monitoring/#email-notifications","title":"Email Notifications","text":"<pre><code># backend/services/notifications.py\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\nclass EmailNotifier:\n    \"\"\"Send email notifications for alerts\"\"\"\n\n    def __init__(self, smtp_host: str, smtp_port: int, username: str, password: str):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n        self.username = username\n        self.password = password\n\n    def send_alert(self, to_email: str, subject: str, message: str):\n        \"\"\"Send alert email\"\"\"\n        msg = MIMEMultipart()\n        msg['From'] = self.username\n        msg['To'] = to_email\n        msg['Subject'] = subject\n\n        msg.attach(MIMEText(message, 'plain'))\n\n        try:\n            server = smtplib.SMTP(self.smtp_host, self.smtp_port)\n            server.starttls()\n            server.login(self.username, self.password)\n            server.send_message(msg)\n            server.quit()\n        except Exception as e:\n            logging.error(f\"Failed to send email: {e}\")\n</code></pre>"},{"location":"deployment/monitoring/#slack-notifications","title":"Slack Notifications","text":"<pre><code>import requests\nimport json\n\nclass SlackNotifier:\n    \"\"\"Send Slack notifications for alerts\"\"\"\n\n    def __init__(self, webhook_url: str):\n        self.webhook_url = webhook_url\n\n    def send_alert(self, message: str, severity: str = \"warning\"):\n        \"\"\"Send alert to Slack\"\"\"\n        color_map = {\n            \"critical\": \"#FF0000\",\n            \"warning\": \"#FFA500\",\n            \"info\": \"#00FF00\"\n        }\n\n        payload = {\n            \"attachments\": [\n                {\n                    \"color\": color_map.get(severity, \"#808080\"),\n                    \"title\": f\"CulicidaeLab Alert - {severity.upper()}\",\n                    \"text\": message,\n                    \"ts\": int(time.time())\n                }\n            ]\n        }\n\n        try:\n            response = requests.post(\n                self.webhook_url,\n                data=json.dumps(payload),\n                headers={'Content-Type': 'application/json'}\n            )\n            response.raise_for_status()\n        except Exception as e:\n            logging.error(f\"Failed to send Slack notification: {e}\")\n</code></pre>"},{"location":"deployment/monitoring/#troubleshooting-and-debugging","title":"Troubleshooting and Debugging","text":""},{"location":"deployment/monitoring/#log-analysis-queries","title":"Log Analysis Queries","text":"<p>Common log analysis queries for troubleshooting:</p>"},{"location":"deployment/monitoring/#find-error-patterns","title":"Find Error Patterns","text":"<pre><code>{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\"term\": {\"level\": \"ERROR\"}},\n        {\"range\": {\"@timestamp\": {\"gte\": \"now-1h\"}}}\n      ]\n    }\n  },\n  \"aggs\": {\n    \"error_messages\": {\n      \"terms\": {\n        \"field\": \"message.keyword\",\n        \"size\": 10\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"deployment/monitoring/#performance-analysis","title":"Performance Analysis","text":"<pre><code>{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\"exists\": {\"field\": \"duration_ms\"}},\n        {\"range\": {\"duration_ms\": {\"gte\": 1000}}}\n      ]\n    }\n  },\n  \"sort\": [\n    {\"duration_ms\": {\"order\": \"desc\"}}\n  ]\n}\n</code></pre>"},{"location":"deployment/monitoring/#user-activity-tracking","title":"User Activity Tracking","text":"<pre><code>{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\"exists\": {\"field\": \"user_id\"}},\n        {\"range\": {\"@timestamp\": {\"gte\": \"now-24h\"}}}\n      ]\n    }\n  },\n  \"aggs\": {\n    \"unique_users\": {\n      \"cardinality\": {\n        \"field\": \"user_id\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"deployment/monitoring/#performance-debugging","title":"Performance Debugging","text":""},{"location":"deployment/monitoring/#memory-profiling","title":"Memory Profiling","text":"<pre><code># backend/services/profiling.py\nimport tracemalloc\nimport psutil\nimport gc\nfrom functools import wraps\n\ndef profile_memory(func):\n    \"\"\"Decorator to profile memory usage\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Start tracing\n        tracemalloc.start()\n        process = psutil.Process()\n        initial_memory = process.memory_info().rss\n\n        try:\n            result = await func(*args, **kwargs)\n            return result\n        finally:\n            # Get memory statistics\n            current, peak = tracemalloc.get_traced_memory()\n            final_memory = process.memory_info().rss\n            tracemalloc.stop()\n\n            # Log memory usage\n            logging.info(\n                \"Memory profile\",\n                extra={\n                    \"function\": func.__name__,\n                    \"current_mb\": round(current / 1024 / 1024, 2),\n                    \"peak_mb\": round(peak / 1024 / 1024, 2),\n                    \"process_delta_mb\": round((final_memory - initial_memory) / 1024 / 1024, 2)\n                }\n            )\n\n    return wrapper\n</code></pre>"},{"location":"deployment/monitoring/#database-query-profiling","title":"Database Query Profiling","text":"<pre><code>def profile_query(func):\n    \"\"\"Decorator to profile database queries\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        start_time = time.time()\n\n        try:\n            result = await func(*args, **kwargs)\n            return result\n        finally:\n            duration = time.time() - start_time\n\n            # Log slow queries\n            if duration &gt; 1.0:  # Log queries taking more than 1 second\n                logging.warning(\n                    \"Slow query detected\",\n                    extra={\n                        \"function\": func.__name__,\n                        \"duration_seconds\": round(duration, 3),\n                        \"args\": str(args)[:100]  # Truncate for logging\n                    }\n                )\n\n    return wrapper\n</code></pre>"},{"location":"deployment/monitoring/#monitoring-best-practices","title":"Monitoring Best Practices","text":"<ol> <li>Set Appropriate Thresholds: Configure alert thresholds based on baseline performance</li> <li>Avoid Alert Fatigue: Don't over-alert; focus on actionable alerts</li> <li>Monitor Business Metrics: Track user engagement and feature usage</li> <li>Regular Review: Periodically review and update monitoring configuration</li> <li>Documentation: Document alert procedures and escalation paths</li> <li>Testing: Test monitoring and alerting systems regularly</li> <li>Retention Policies: Set appropriate log and metric retention periods</li> <li>Security: Secure monitoring infrastructure and access controls</li> </ol>"},{"location":"deployment/production/","title":"Production Deployment","text":"<p>This guide covers deploying CulicidaeLab Server to a production environment. The application consists of a FastAPI backend and a Solara frontend that can be deployed together or separately.</p>"},{"location":"deployment/production/#prerequisites","title":"Prerequisites","text":"<p>Before deploying to production, ensure you have:</p> <ul> <li>Python 3.11 or higher</li> <li>Access to a server with at least 4GB RAM and 2 CPU cores</li> <li>Domain name and SSL certificate (recommended)</li> <li>Database storage (local or cloud-based)</li> <li>Model files for species prediction</li> </ul>"},{"location":"deployment/production/#deployment-architecture","title":"Deployment Architecture","text":"<p>CulicidaeLab Server can be deployed in several configurations:</p>"},{"location":"deployment/production/#single-server-deployment","title":"Single Server Deployment","text":"<ul> <li>Both backend and frontend on the same server</li> <li>Suitable for small to medium workloads</li> <li>Easier to manage and maintain</li> </ul>"},{"location":"deployment/production/#microservices-deployment","title":"Microservices Deployment","text":"<ul> <li>Backend and frontend on separate servers</li> <li>Better scalability and resource allocation</li> <li>Requires load balancer configuration</li> </ul>"},{"location":"deployment/production/#environment-setup","title":"Environment Setup","text":""},{"location":"deployment/production/#1-server-preparation","title":"1. Server Preparation","text":"<pre><code># Update system packages\nsudo apt update &amp;&amp; sudo apt upgrade -y\n\n# Install Python 3.11+\nsudo apt install python3.11 python3.11-venv python3.11-dev\n\n# Install system dependencies\nsudo apt install build-essential curl git nginx supervisor\n</code></pre>"},{"location":"deployment/production/#2-application-setup","title":"2. Application Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/your-org/culicidaelab-server.git\ncd culicidaelab-server\n\n# Create virtual environment\npython3.11 -m venv .venv\nsource .venv/bin/activate\n\n# Install dependencies\npip install uv\nuv sync -p 3.11\n</code></pre>"},{"location":"deployment/production/#3-environment-configuration","title":"3. Environment Configuration","text":"<p>Create production environment file:</p> <pre><code># Copy example environment file\ncp backend/.env.example backend/.env\n\n# Edit configuration for production\nnano backend/.env\n</code></pre> <p>Required production environment variables:</p> <pre><code># Database configuration\nCULICIDAELAB_DATABASE_PATH=\"/var/lib/culicidaelab/data/.lancedb\"\n\n# Image storage\nCULICIDAELAB_SAVE_PREDICTED_IMAGES=1\n\n# Environment\nENVIRONMENT=production\n\n# Security (generate secure values)\nSECRET_KEY=\"your-secure-secret-key-here\"\nALLOWED_HOSTS=\"your-domain.com,www.your-domain.com\"\n\n# CORS origins for frontend\nCULICIDAELAB_BACKEND_CORS_ORIGINS=\"https://your-domain.com,https://www.your-domain.com\"\n</code></pre>"},{"location":"deployment/production/#application-deployment","title":"Application Deployment","text":""},{"location":"deployment/production/#1-backend-deployment","title":"1. Backend Deployment","text":"<p>Create systemd service for the backend:</p> <pre><code>sudo nano /etc/systemd/system/culicidaelab-backend.service\n</code></pre> <pre><code>[Unit]\nDescription=CulicidaeLab Backend API\nAfter=network.target\n\n[Service]\nType=exec\nUser=www-data\nGroup=www-data\nWorkingDirectory=/path/to/culicidaelab-server\nEnvironment=PATH=/path/to/culicidaelab-server/.venv/bin\nExecStart=/path/to/culicidaelab-server/.venv/bin/uvicorn backend.main:app --host 127.0.0.1 --port 8000 --workers 4\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"deployment/production/#2-frontend-deployment","title":"2. Frontend Deployment","text":"<p>Create systemd service for the frontend:</p> <pre><code>sudo nano /etc/systemd/system/culicidaelab-frontend.service\n</code></pre> <pre><code>[Unit]\nDescription=CulicidaeLab Frontend\nAfter=network.target\n\n[Service]\nType=exec\nUser=www-data\nGroup=www-data\nWorkingDirectory=/path/to/culicidaelab-server\nEnvironment=PATH=/path/to/culicidaelab-server/.venv/bin\nExecStart=/path/to/culicidaelab-server/.venv/bin/solara run frontend.main:routes --host 127.0.0.1 --port 8765 --production\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"deployment/production/#3-enable-and-start-services","title":"3. Enable and Start Services","text":"<pre><code># Enable services\nsudo systemctl enable culicidaelab-backend\nsudo systemctl enable culicidaelab-frontend\n\n# Start services\nsudo systemctl start culicidaelab-backend\nsudo systemctl start culicidaelab-frontend\n\n# Check status\nsudo systemctl status culicidaelab-backend\nsudo systemctl status culicidaelab-frontend\n</code></pre>"},{"location":"deployment/production/#reverse-proxy-configuration","title":"Reverse Proxy Configuration","text":""},{"location":"deployment/production/#nginx-configuration","title":"Nginx Configuration","text":"<p>Create Nginx configuration:</p> <pre><code>sudo nano /etc/nginx/sites-available/culicidaelab\n</code></pre> <pre><code>server {\n    listen 80;\n    server_name your-domain.com www.your-domain.com;\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com www.your-domain.com;\n\n    # SSL Configuration\n    ssl_certificate /path/to/ssl/certificate.crt;\n    ssl_certificate_key /path/to/ssl/private.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n\n    # Security headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";\n\n    # Frontend (main application)\n    location / {\n        proxy_pass http://127.0.0.1:8765;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # WebSocket support for Solara\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n    }\n\n    # Backend API\n    location /api {\n        proxy_pass http://127.0.0.1:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Increase timeout for model predictions\n        proxy_read_timeout 300s;\n        proxy_connect_timeout 75s;\n    }\n\n    # Static files\n    location /static {\n        alias /path/to/culicidaelab-server/backend/static;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n\n    # File upload size limit\n    client_max_body_size 50M;\n}\n</code></pre> <p>Enable the site:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/culicidaelab /etc/nginx/sites-enabled/\nsudo nginx -t\nsudo systemctl reload nginx\n</code></pre>"},{"location":"deployment/production/#database-setup","title":"Database Setup","text":""},{"location":"deployment/production/#1-create-database-directory","title":"1. Create Database Directory","text":"<pre><code>sudo mkdir -p /var/lib/culicidaelab/data\nsudo chown -R www-data:www-data /var/lib/culicidaelab\nsudo chmod 755 /var/lib/culicidaelab\n</code></pre>"},{"location":"deployment/production/#2-initialize-database","title":"2. Initialize Database","text":"<pre><code># Run database initialization script if available\ncd /path/to/culicidaelab-server\nsource .venv/bin/activate\npython -m backend.scripts.init_database\n</code></pre>"},{"location":"deployment/production/#model-files-setup","title":"Model Files Setup","text":""},{"location":"deployment/production/#1-download-model-files","title":"1. Download Model Files","text":"<pre><code># Create models directory\nsudo mkdir -p /var/lib/culicidaelab/models\nsudo chown -R www-data:www-data /var/lib/culicidaelab/models\n\n# Download or copy model files\n# This depends on your model distribution method\n</code></pre>"},{"location":"deployment/production/#2-configure-model-paths","title":"2. Configure Model Paths","text":"<p>Update your environment configuration to point to the model files:</p> <pre><code># In backend/.env\nCULICIDAELAB_MODEL_PATH=\"/var/lib/culicidaelab/models\"\n</code></pre>"},{"location":"deployment/production/#health-checks-and-monitoring","title":"Health Checks and Monitoring","text":""},{"location":"deployment/production/#1-application-health-checks","title":"1. Application Health Checks","text":"<p>The application provides health check endpoints:</p> <ul> <li>Backend: <code>https://your-domain.com/api/health</code></li> <li>Frontend: Monitor the main application URL</li> </ul>"},{"location":"deployment/production/#2-log-monitoring","title":"2. Log Monitoring","text":"<p>Configure log rotation and monitoring:</p> <pre><code># Create log directories\nsudo mkdir -p /var/log/culicidaelab\nsudo chown -R www-data:www-data /var/log/culicidaelab\n\n# Configure logrotate\nsudo nano /etc/logrotate.d/culicidaelab\n</code></pre> <pre><code>/var/log/culicidaelab/*.log {\n    daily\n    missingok\n    rotate 52\n    compress\n    delaycompress\n    notifempty\n    create 644 www-data www-data\n    postrotate\n        systemctl reload culicidaelab-backend\n        systemctl reload culicidaelab-frontend\n    endscript\n}\n</code></pre>"},{"location":"deployment/production/#backup-strategy","title":"Backup Strategy","text":""},{"location":"deployment/production/#1-database-backup","title":"1. Database Backup","text":"<pre><code>#!/bin/bash\n# backup-database.sh\nBACKUP_DIR=\"/var/backups/culicidaelab\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\nmkdir -p $BACKUP_DIR\ntar -czf $BACKUP_DIR/database_$DATE.tar.gz /var/lib/culicidaelab/data/\n</code></pre>"},{"location":"deployment/production/#2-application-backup","title":"2. Application Backup","text":"<pre><code>#!/bin/bash\n# backup-application.sh\nBACKUP_DIR=\"/var/backups/culicidaelab\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\nmkdir -p $BACKUP_DIR\ntar -czf $BACKUP_DIR/application_$DATE.tar.gz /path/to/culicidaelab-server/\n</code></pre>"},{"location":"deployment/production/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"deployment/production/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>For high-traffic deployments:</p> <ol> <li>Load Balancer: Use nginx or HAProxy to distribute traffic</li> <li>Multiple Backend Instances: Run multiple backend workers</li> <li>Database Scaling: Consider database clustering or replication</li> <li>CDN: Use CDN for static assets and images</li> </ol>"},{"location":"deployment/production/#vertical-scaling","title":"Vertical Scaling","text":"<p>Resource recommendations by load:</p> <ul> <li>Small (&lt; 100 users): 2 CPU cores, 4GB RAM</li> <li>Medium (100-1000 users): 4 CPU cores, 8GB RAM</li> <li>Large (1000+ users): 8+ CPU cores, 16GB+ RAM</li> </ul>"},{"location":"deployment/production/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/production/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Service Won't Start <pre><code>sudo journalctl -u culicidaelab-backend -f\nsudo journalctl -u culicidaelab-frontend -f\n</code></pre></p> </li> <li> <p>Permission Issues <pre><code>sudo chown -R www-data:www-data /path/to/culicidaelab-server\nsudo chmod -R 755 /path/to/culicidaelab-server\n</code></pre></p> </li> <li> <p>Database Connection Issues</p> </li> <li>Check database path permissions</li> <li>Verify environment variables</li> <li> <p>Check disk space</p> </li> <li> <p>Model Loading Issues</p> </li> <li>Verify model file paths</li> <li>Check model file permissions</li> <li>Ensure sufficient memory</li> </ol>"},{"location":"deployment/production/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Enable Gzip Compression in Nginx</li> <li>Configure Caching for static assets</li> <li>Optimize Database queries and indexing</li> <li>Monitor Resource Usage with tools like htop, iotop</li> </ol>"},{"location":"deployment/production/#security-checklist","title":"Security Checklist","text":"<ul> <li> SSL/TLS certificates configured</li> <li> Firewall rules configured (only ports 80, 443, 22 open)</li> <li> Regular security updates applied</li> <li> Strong passwords and SSH key authentication</li> <li> Database access restricted</li> <li> Application logs monitored</li> <li> Backup strategy implemented</li> <li> Rate limiting configured</li> <li> CORS origins properly configured</li> </ul>"},{"location":"deployment/security/","title":"Security Considerations","text":"<p>This document outlines comprehensive security guidelines and best practices for deploying and maintaining CulicidaeLab Server in production environments.</p>"},{"location":"deployment/security/#security-overview","title":"Security Overview","text":"<p>CulicidaeLab Server handles sensitive research data, user uploads, and provides AI-powered species identification services. A robust security posture is essential to protect:</p> <ul> <li>Research data and observations</li> <li>User-uploaded images and metadata</li> <li>API endpoints and services</li> <li>Model files and intellectual property</li> <li>System infrastructure and resources</li> </ul>"},{"location":"deployment/security/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"deployment/security/#api-security","title":"API Security","text":""},{"location":"deployment/security/#api-key-authentication","title":"API Key Authentication","text":"<p>Implement API key authentication for programmatic access:</p> <pre><code># backend/services/auth.py\nimport secrets\nimport hashlib\nfrom typing import Optional\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\nsecurity = HTTPBearer()\n\nclass APIKeyManager:\n    \"\"\"Manage API key authentication\"\"\"\n\n    def __init__(self):\n        self.api_keys = {}  # In production, use database storage\n\n    def generate_api_key(self, user_id: str) -&gt; str:\n        \"\"\"Generate a new API key for a user\"\"\"\n        api_key = secrets.token_urlsafe(32)\n        key_hash = hashlib.sha256(api_key.encode()).hexdigest()\n\n        self.api_keys[key_hash] = {\n            \"user_id\": user_id,\n            \"created_at\": datetime.utcnow(),\n            \"last_used\": None,\n            \"is_active\": True\n        }\n\n        return api_key\n\n    def validate_api_key(self, api_key: str) -&gt; Optional[str]:\n        \"\"\"Validate API key and return user ID\"\"\"\n        key_hash = hashlib.sha256(api_key.encode()).hexdigest()\n\n        if key_hash in self.api_keys:\n            key_info = self.api_keys[key_hash]\n            if key_info[\"is_active\"]:\n                key_info[\"last_used\"] = datetime.utcnow()\n                return key_info[\"user_id\"]\n\n        return None\n\napi_key_manager = APIKeyManager()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Dependency to get current authenticated user\"\"\"\n    user_id = api_key_manager.validate_api_key(credentials.credentials)\n\n    if not user_id:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid API key\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return user_id\n\n# Usage in endpoints\n@app.post(\"/api/protected-endpoint\")\nasync def protected_endpoint(user_id: str = Depends(get_current_user)):\n    return {\"message\": f\"Hello, user {user_id}\"}\n</code></pre>"},{"location":"deployment/security/#rate-limiting","title":"Rate Limiting","text":"<p>Implement rate limiting to prevent abuse:</p> <pre><code># backend/services/rate_limiting.py\nimport time\nfrom collections import defaultdict, deque\nfrom typing import Dict, Deque\nfrom fastapi import HTTPException, Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass RateLimiter:\n    \"\"\"Token bucket rate limiter\"\"\"\n\n    def __init__(self, requests_per_minute: int = 60):\n        self.requests_per_minute = requests_per_minute\n        self.requests: Dict[str, Deque[float]] = defaultdict(deque)\n\n    def is_allowed(self, identifier: str) -&gt; bool:\n        \"\"\"Check if request is allowed for given identifier\"\"\"\n        now = time.time()\n        minute_ago = now - 60\n\n        # Clean old requests\n        request_times = self.requests[identifier]\n        while request_times and request_times[0] &lt;= minute_ago:\n            request_times.popleft()\n\n        # Check if under limit\n        if len(request_times) &lt; self.requests_per_minute:\n            request_times.append(now)\n            return True\n\n        return False\n\nclass RateLimitMiddleware(BaseHTTPMiddleware):\n    \"\"\"Rate limiting middleware\"\"\"\n\n    def __init__(self, app, requests_per_minute: int = 60):\n        super().__init__(app)\n        self.rate_limiter = RateLimiter(requests_per_minute)\n\n    async def dispatch(self, request: Request, call_next):\n        # Use IP address as identifier\n        client_ip = request.client.host\n\n        if not self.rate_limiter.is_allowed(client_ip):\n            raise HTTPException(\n                status_code=429,\n                detail=\"Rate limit exceeded\"\n            )\n\n        response = await call_next(request)\n        return response\n\n# Add to FastAPI app\napp.add_middleware(RateLimitMiddleware, requests_per_minute=100)\n</code></pre>"},{"location":"deployment/security/#session-management","title":"Session Management","text":"<p>Implement secure session handling:</p> <pre><code># backend/services/sessions.py\nimport secrets\nimport time\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime, timedelta\n\nclass SessionManager:\n    \"\"\"Manage user sessions securely\"\"\"\n\n    def __init__(self, session_timeout: int = 3600):\n        self.sessions: Dict[str, Dict[str, Any]] = {}\n        self.session_timeout = session_timeout\n\n    def create_session(self, user_id: str, user_data: Dict[str, Any]) -&gt; str:\n        \"\"\"Create a new session\"\"\"\n        session_id = secrets.token_urlsafe(32)\n\n        self.sessions[session_id] = {\n            \"user_id\": user_id,\n            \"user_data\": user_data,\n            \"created_at\": datetime.utcnow(),\n            \"last_accessed\": datetime.utcnow(),\n            \"expires_at\": datetime.utcnow() + timedelta(seconds=self.session_timeout)\n        }\n\n        return session_id\n\n    def get_session(self, session_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get session data if valid\"\"\"\n        if session_id not in self.sessions:\n            return None\n\n        session = self.sessions[session_id]\n\n        # Check if session expired\n        if datetime.utcnow() &gt; session[\"expires_at\"]:\n            del self.sessions[session_id]\n            return None\n\n        # Update last accessed time\n        session[\"last_accessed\"] = datetime.utcnow()\n        return session\n\n    def invalidate_session(self, session_id: str):\n        \"\"\"Invalidate a session\"\"\"\n        if session_id in self.sessions:\n            del self.sessions[session_id]\n\n    def cleanup_expired_sessions(self):\n        \"\"\"Remove expired sessions\"\"\"\n        now = datetime.utcnow()\n        expired_sessions = [\n            sid for sid, session in self.sessions.items()\n            if now &gt; session[\"expires_at\"]\n        ]\n\n        for sid in expired_sessions:\n            del self.sessions[sid]\n</code></pre>"},{"location":"deployment/security/#input-validation-and-sanitization","title":"Input Validation and Sanitization","text":""},{"location":"deployment/security/#file-upload-security","title":"File Upload Security","text":"<p>Secure file upload handling:</p> <pre><code># backend/services/file_security.py\nimport os\nimport magic\nimport hashlib\nfrom typing import List, Optional\nfrom fastapi import UploadFile, HTTPException\nfrom PIL import Image\nimport io\n\nclass FileValidator:\n    \"\"\"Validate uploaded files for security\"\"\"\n\n    ALLOWED_MIME_TYPES = [\n        'image/jpeg',\n        'image/png',\n        'image/tiff',\n        'image/bmp'\n    ]\n\n    ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.tiff', '.tif', '.bmp']\n    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB\n\n    def __init__(self):\n        self.mime = magic.Magic(mime=True)\n\n    def validate_file(self, file: UploadFile) -&gt; bool:\n        \"\"\"Comprehensive file validation\"\"\"\n\n        # Check file size\n        if not self._check_file_size(file):\n            raise HTTPException(status_code=413, detail=\"File too large\")\n\n        # Check file extension\n        if not self._check_extension(file.filename):\n            raise HTTPException(status_code=400, detail=\"Invalid file extension\")\n\n        # Check MIME type\n        file_content = file.file.read()\n        file.file.seek(0)  # Reset file pointer\n\n        if not self._check_mime_type(file_content):\n            raise HTTPException(status_code=400, detail=\"Invalid file type\")\n\n        # Validate image format\n        if not self._validate_image_format(file_content):\n            raise HTTPException(status_code=400, detail=\"Invalid or corrupted image\")\n\n        # Check for malicious content\n        if not self._scan_for_malware(file_content):\n            raise HTTPException(status_code=400, detail=\"File failed security scan\")\n\n        return True\n\n    def _check_file_size(self, file: UploadFile) -&gt; bool:\n        \"\"\"Check if file size is within limits\"\"\"\n        file.file.seek(0, 2)  # Seek to end\n        size = file.file.tell()\n        file.file.seek(0)  # Reset to beginning\n\n        return size &lt;= self.MAX_FILE_SIZE\n\n    def _check_extension(self, filename: str) -&gt; bool:\n        \"\"\"Check if file extension is allowed\"\"\"\n        if not filename:\n            return False\n\n        ext = os.path.splitext(filename.lower())[1]\n        return ext in self.ALLOWED_EXTENSIONS\n\n    def _check_mime_type(self, content: bytes) -&gt; bool:\n        \"\"\"Check MIME type using python-magic\"\"\"\n        mime_type = self.mime.from_buffer(content)\n        return mime_type in self.ALLOWED_MIME_TYPES\n\n    def _validate_image_format(self, content: bytes) -&gt; bool:\n        \"\"\"Validate image format using PIL\"\"\"\n        try:\n            with Image.open(io.BytesIO(content)) as img:\n                img.verify()  # Verify image integrity\n            return True\n        except Exception:\n            return False\n\n    def _scan_for_malware(self, content: bytes) -&gt; bool:\n        \"\"\"Basic malware scanning (implement with ClamAV or similar)\"\"\"\n        # Check for suspicious patterns\n        suspicious_patterns = [\n            b'&lt;script',\n            b'javascript:',\n            b'&lt;?php',\n            b'&lt;%',\n            b'eval(',\n            b'exec('\n        ]\n\n        content_lower = content.lower()\n        for pattern in suspicious_patterns:\n            if pattern in content_lower:\n                return False\n\n        return True\n\n    def generate_safe_filename(self, original_filename: str) -&gt; str:\n        \"\"\"Generate a safe filename\"\"\"\n        # Remove path components\n        filename = os.path.basename(original_filename)\n\n        # Generate hash-based filename\n        timestamp = str(int(time.time()))\n        file_hash = hashlib.md5(filename.encode()).hexdigest()[:8]\n        ext = os.path.splitext(filename)[1].lower()\n\n        return f\"{timestamp}_{file_hash}{ext}\"\n\n# Usage in endpoints\nfile_validator = FileValidator()\n\n@app.post(\"/api/upload\")\nasync def upload_file(file: UploadFile):\n    # Validate file\n    file_validator.validate_file(file)\n\n    # Generate safe filename\n    safe_filename = file_validator.generate_safe_filename(file.filename)\n\n    # Save file securely\n    # ... implementation\n</code></pre>"},{"location":"deployment/security/#input-sanitization","title":"Input Sanitization","text":"<p>Sanitize user inputs to prevent injection attacks:</p> <pre><code># backend/services/input_sanitization.py\nimport re\nimport html\nfrom typing import Any, Dict, List, Union\n\nclass InputSanitizer:\n    \"\"\"Sanitize user inputs\"\"\"\n\n    # Regex patterns for validation\n    EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    ALPHANUMERIC_PATTERN = re.compile(r'^[a-zA-Z0-9_-]+$')\n\n    @staticmethod\n    def sanitize_string(value: str, max_length: int = 1000) -&gt; str:\n        \"\"\"Sanitize string input\"\"\"\n        if not isinstance(value, str):\n            raise ValueError(\"Input must be a string\")\n\n        # Truncate to max length\n        value = value[:max_length]\n\n        # HTML escape\n        value = html.escape(value)\n\n        # Remove null bytes\n        value = value.replace('\\x00', '')\n\n        # Strip whitespace\n        value = value.strip()\n\n        return value\n\n    @staticmethod\n    def validate_email(email: str) -&gt; bool:\n        \"\"\"Validate email format\"\"\"\n        return bool(InputSanitizer.EMAIL_PATTERN.match(email))\n\n    @staticmethod\n    def validate_alphanumeric(value: str) -&gt; bool:\n        \"\"\"Validate alphanumeric input\"\"\"\n        return bool(InputSanitizer.ALPHANUMERIC_PATTERN.match(value))\n\n    @staticmethod\n    def sanitize_coordinates(lat: float, lon: float) -&gt; tuple:\n        \"\"\"Sanitize geographic coordinates\"\"\"\n        # Validate latitude range\n        if not -90 &lt;= lat &lt;= 90:\n            raise ValueError(\"Invalid latitude\")\n\n        # Validate longitude range\n        if not -180 &lt;= lon &lt;= 180:\n            raise ValueError(\"Invalid longitude\")\n\n        return round(lat, 6), round(lon, 6)\n\n    @staticmethod\n    def sanitize_dict(data: Dict[str, Any], allowed_keys: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Sanitize dictionary input\"\"\"\n        sanitized = {}\n\n        for key in allowed_keys:\n            if key in data:\n                value = data[key]\n\n                if isinstance(value, str):\n                    sanitized[key] = InputSanitizer.sanitize_string(value)\n                elif isinstance(value, (int, float)):\n                    sanitized[key] = value\n                elif isinstance(value, bool):\n                    sanitized[key] = value\n                # Add more type handling as needed\n\n        return sanitized\n\n# Pydantic models with validation\nfrom pydantic import BaseModel, validator, Field\n\nclass ObservationInput(BaseModel):\n    \"\"\"Validated observation input model\"\"\"\n\n    species_name: str = Field(..., max_length=100)\n    latitude: float = Field(..., ge=-90, le=90)\n    longitude: float = Field(..., ge=-180, le=180)\n    confidence: float = Field(..., ge=0, le=1)\n    notes: Optional[str] = Field(None, max_length=1000)\n\n    @validator('species_name')\n    def validate_species_name(cls, v):\n        return InputSanitizer.sanitize_string(v, 100)\n\n    @validator('notes')\n    def validate_notes(cls, v):\n        if v is not None:\n            return InputSanitizer.sanitize_string(v, 1000)\n        return v\n</code></pre>"},{"location":"deployment/security/#data-protection","title":"Data Protection","text":""},{"location":"deployment/security/#encryption","title":"Encryption","text":""},{"location":"deployment/security/#data-at-rest","title":"Data at Rest","text":"<p>Encrypt sensitive data stored in the database:</p> <pre><code># backend/services/encryption.py\nimport os\nimport base64\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nclass DataEncryption:\n    \"\"\"Handle data encryption and decryption\"\"\"\n\n    def __init__(self, password: str):\n        self.key = self._derive_key(password)\n        self.cipher = Fernet(self.key)\n\n    def _derive_key(self, password: str) -&gt; bytes:\n        \"\"\"Derive encryption key from password\"\"\"\n        salt = os.environ.get('ENCRYPTION_SALT', 'default_salt').encode()\n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=salt,\n            iterations=100000,\n        )\n        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n        return key\n\n    def encrypt(self, data: str) -&gt; str:\n        \"\"\"Encrypt string data\"\"\"\n        encrypted_data = self.cipher.encrypt(data.encode())\n        return base64.urlsafe_b64encode(encrypted_data).decode()\n\n    def decrypt(self, encrypted_data: str) -&gt; str:\n        \"\"\"Decrypt string data\"\"\"\n        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())\n        decrypted_data = self.cipher.decrypt(encrypted_bytes)\n        return decrypted_data.decode()\n\n# Usage for sensitive fields\nencryption = DataEncryption(os.environ.get('ENCRYPTION_PASSWORD'))\n\nclass EncryptedObservation:\n    \"\"\"Observation with encrypted sensitive fields\"\"\"\n\n    def __init__(self, data: dict):\n        self.id = data['id']\n        self.species_id = data['species_id']\n        self.location = data['location']  # Encrypted\n        self.notes = data['notes']  # Encrypted\n        self.created_at = data['created_at']\n\n    @classmethod\n    def create(cls, species_id: str, location: dict, notes: str):\n        \"\"\"Create observation with encryption\"\"\"\n        encrypted_location = encryption.encrypt(json.dumps(location))\n        encrypted_notes = encryption.encrypt(notes) if notes else None\n\n        return cls({\n            'id': str(uuid.uuid4()),\n            'species_id': species_id,\n            'location': encrypted_location,\n            'notes': encrypted_notes,\n            'created_at': datetime.utcnow()\n        })\n\n    def get_decrypted_location(self) -&gt; dict:\n        \"\"\"Get decrypted location data\"\"\"\n        return json.loads(encryption.decrypt(self.location))\n\n    def get_decrypted_notes(self) -&gt; str:\n        \"\"\"Get decrypted notes\"\"\"\n        return encryption.decrypt(self.notes) if self.notes else \"\"\n</code></pre>"},{"location":"deployment/security/#data-in-transit","title":"Data in Transit","text":"<p>Ensure all communications use HTTPS/TLS:</p> <pre><code># Nginx SSL configuration\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n\n    # SSL certificates\n    ssl_certificate /path/to/certificate.crt;\n    ssl_certificate_key /path/to/private.key;\n\n    # SSL security settings\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    # HSTS\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";\n\n    # Other security headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\";\n    add_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';\";\n}\n</code></pre>"},{"location":"deployment/security/#data-privacy","title":"Data Privacy","text":""},{"location":"deployment/security/#gdpr-compliance","title":"GDPR Compliance","text":"<p>Implement data privacy controls:</p> <pre><code># backend/services/privacy.py\nfrom typing import List, Dict, Any\nfrom datetime import datetime, timedelta\n\nclass PrivacyManager:\n    \"\"\"Manage data privacy and GDPR compliance\"\"\"\n\n    def __init__(self, db_connection):\n        self.db = db_connection\n\n    def export_user_data(self, user_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Export all user data for GDPR compliance\"\"\"\n        user_data = {\n            \"user_id\": user_id,\n            \"export_date\": datetime.utcnow().isoformat(),\n            \"observations\": self._get_user_observations(user_id),\n            \"uploads\": self._get_user_uploads(user_id),\n            \"sessions\": self._get_user_sessions(user_id)\n        }\n\n        return user_data\n\n    def delete_user_data(self, user_id: str) -&gt; bool:\n        \"\"\"Delete all user data (right to be forgotten)\"\"\"\n        try:\n            # Delete observations\n            self.db.delete_user_observations(user_id)\n\n            # Delete uploaded files\n            self._delete_user_files(user_id)\n\n            # Delete sessions\n            self.db.delete_user_sessions(user_id)\n\n            # Anonymize remaining references\n            self._anonymize_user_references(user_id)\n\n            return True\n        except Exception as e:\n            logging.error(f\"Failed to delete user data: {e}\")\n            return False\n\n    def anonymize_old_data(self, days_old: int = 365):\n        \"\"\"Anonymize data older than specified days\"\"\"\n        cutoff_date = datetime.utcnow() - timedelta(days=days_old)\n\n        # Anonymize old observations\n        old_observations = self.db.get_observations_before(cutoff_date)\n        for obs in old_observations:\n            self._anonymize_observation(obs)\n\n    def _get_user_observations(self, user_id: str) -&gt; List[Dict]:\n        \"\"\"Get all observations for a user\"\"\"\n        return self.db.get_user_observations(user_id)\n\n    def _get_user_uploads(self, user_id: str) -&gt; List[Dict]:\n        \"\"\"Get all file uploads for a user\"\"\"\n        return self.db.get_user_uploads(user_id)\n\n    def _get_user_sessions(self, user_id: str) -&gt; List[Dict]:\n        \"\"\"Get session history for a user\"\"\"\n        return self.db.get_user_sessions(user_id)\n\n    def _delete_user_files(self, user_id: str):\n        \"\"\"Delete all files uploaded by user\"\"\"\n        user_files = self.db.get_user_files(user_id)\n        for file_info in user_files:\n            try:\n                os.remove(file_info['file_path'])\n            except FileNotFoundError:\n                pass  # File already deleted\n\n    def _anonymize_observation(self, observation: Dict):\n        \"\"\"Anonymize an observation record\"\"\"\n        # Remove or hash identifying information\n        observation['user_id'] = 'anonymous'\n        observation['ip_address'] = None\n        observation['metadata'] = {}\n\n        self.db.update_observation(observation)\n\n    def _anonymize_user_references(self, user_id: str):\n        \"\"\"Anonymize references to user in other tables\"\"\"\n        # Update any remaining references to use anonymous ID\n        self.db.update_user_references(user_id, 'anonymous')\n</code></pre>"},{"location":"deployment/security/#infrastructure-security","title":"Infrastructure Security","text":""},{"location":"deployment/security/#server-hardening","title":"Server Hardening","text":""},{"location":"deployment/security/#operating-system-security","title":"Operating System Security","text":"<pre><code>#!/bin/bash\n# server-hardening.sh\n\n# Update system packages\napt update &amp;&amp; apt upgrade -y\n\n# Configure firewall\nufw default deny incoming\nufw default allow outgoing\nufw allow ssh\nufw allow 80/tcp\nufw allow 443/tcp\nufw --force enable\n\n# Disable unnecessary services\nsystemctl disable bluetooth\nsystemctl disable cups\nsystemctl disable avahi-daemon\n\n# Configure SSH security\nsed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config\nsed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config\nsed -i 's/#PubkeyAuthentication yes/PubkeyAuthentication yes/' /etc/ssh/sshd_config\nsystemctl restart sshd\n\n# Install fail2ban\napt install fail2ban -y\nsystemctl enable fail2ban\nsystemctl start fail2ban\n\n# Configure automatic security updates\napt install unattended-upgrades -y\ndpkg-reconfigure -plow unattended-upgrades\n\n# Set up log monitoring\napt install logwatch -y\necho \"logwatch --output mail --mailto admin@example.com --detail high\" &gt; /etc/cron.daily/00logwatch\nchmod +x /etc/cron.daily/00logwatch\n</code></pre>"},{"location":"deployment/security/#docker-security","title":"Docker Security","text":"<pre><code># Secure Dockerfile practices\nFROM python:3.11-slim\n\n# Create non-root user\nRUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser\n\n# Install security updates\nRUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; \\\n    apt-get install -y --no-install-recommends \\\n    build-essential &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# Set working directory\nWORKDIR /app\n\n# Copy and install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Set proper permissions\nRUN chown -R appuser:appuser /app\nUSER appuser\n\n# Use non-root port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Run application\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"deployment/security/#network-security","title":"Network Security","text":""},{"location":"deployment/security/#firewall-configuration","title":"Firewall Configuration","text":"<pre><code># iptables rules for additional security\niptables -A INPUT -i lo -j ACCEPT\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\niptables -A INPUT -j DROP\n\n# Rate limiting\niptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT\n\n# Save rules\niptables-save &gt; /etc/iptables/rules.v4\n</code></pre>"},{"location":"deployment/security/#vpn-access","title":"VPN Access","text":"<p>For administrative access, consider VPN setup:</p> <pre><code># Install WireGuard VPN\napt install wireguard -y\n\n# Generate server keys\nwg genkey | tee /etc/wireguard/private.key\ncat /etc/wireguard/private.key | wg pubkey | tee /etc/wireguard/public.key\n\n# Configure WireGuard\ncat &gt; /etc/wireguard/wg0.conf &lt;&lt; EOF\n[Interface]\nPrivateKey = $(cat /etc/wireguard/private.key)\nAddress = 10.0.0.1/24\nListenPort = 51820\nPostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nPostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\n\n[Peer]\nPublicKey = CLIENT_PUBLIC_KEY\nAllowedIPs = 10.0.0.2/32\nEOF\n\n# Enable and start WireGuard\nsystemctl enable wg-quick@wg0\nsystemctl start wg-quick@wg0\n</code></pre>"},{"location":"deployment/security/#security-monitoring","title":"Security Monitoring","text":""},{"location":"deployment/security/#intrusion-detection","title":"Intrusion Detection","text":""},{"location":"deployment/security/#ossec-configuration","title":"OSSEC Configuration","text":"<pre><code>&lt;!-- /var/ossec/etc/ossec.conf --&gt;\n&lt;ossec_config&gt;\n  &lt;global&gt;\n    &lt;email_notification&gt;yes&lt;/email_notification&gt;\n    &lt;smtp_server&gt;localhost&lt;/smtp_server&gt;\n    &lt;email_from&gt;ossec@culicidaelab.com&lt;/email_from&gt;\n    &lt;email_to&gt;admin@culicidaelab.com&lt;/email_to&gt;\n  &lt;/global&gt;\n\n  &lt;rules&gt;\n    &lt;include&gt;rules_config.xml&lt;/include&gt;\n    &lt;include&gt;pam_rules.xml&lt;/include&gt;\n    &lt;include&gt;sshd_rules.xml&lt;/include&gt;\n    &lt;include&gt;telnetd_rules.xml&lt;/include&gt;\n    &lt;include&gt;syslog_rules.xml&lt;/include&gt;\n    &lt;include&gt;arpwatch_rules.xml&lt;/include&gt;\n    &lt;include&gt;symantec-av_rules.xml&lt;/include&gt;\n    &lt;include&gt;symantec-ws_rules.xml&lt;/include&gt;\n    &lt;include&gt;pix_rules.xml&lt;/include&gt;\n    &lt;include&gt;named_rules.xml&lt;/include&gt;\n    &lt;include&gt;smbd_rules.xml&lt;/include&gt;\n    &lt;include&gt;vsftpd_rules.xml&lt;/include&gt;\n    &lt;include&gt;pure-ftpd_rules.xml&lt;/include&gt;\n    &lt;include&gt;proftpd_rules.xml&lt;/include&gt;\n    &lt;include&gt;ms_ftpd_rules.xml&lt;/include&gt;\n    &lt;include&gt;ftpd_rules.xml&lt;/include&gt;\n    &lt;include&gt;hordeimp_rules.xml&lt;/include&gt;\n    &lt;include&gt;roundcube_rules.xml&lt;/include&gt;\n    &lt;include&gt;wordpress_rules.xml&lt;/include&gt;\n    &lt;include&gt;cimserver_rules.xml&lt;/include&gt;\n    &lt;include&gt;vpopmail_rules.xml&lt;/include&gt;\n    &lt;include&gt;vmpop3d_rules.xml&lt;/include&gt;\n    &lt;include&gt;courier_rules.xml&lt;/include&gt;\n    &lt;include&gt;web_rules.xml&lt;/include&gt;\n    &lt;include&gt;web_appsec_rules.xml&lt;/include&gt;\n    &lt;include&gt;apache_rules.xml&lt;/include&gt;\n    &lt;include&gt;nginx_rules.xml&lt;/include&gt;\n    &lt;include&gt;php_rules.xml&lt;/include&gt;\n    &lt;include&gt;mysql_rules.xml&lt;/include&gt;\n    &lt;include&gt;postgresql_rules.xml&lt;/include&gt;\n    &lt;include&gt;ids_rules.xml&lt;/include&gt;\n    &lt;include&gt;squid_rules.xml&lt;/include&gt;\n    &lt;include&gt;firewall_rules.xml&lt;/include&gt;\n    &lt;include&gt;cisco-ios_rules.xml&lt;/include&gt;\n    &lt;include&gt;netscreenfw_rules.xml&lt;/include&gt;\n    &lt;include&gt;sonicwall_rules.xml&lt;/include&gt;\n    &lt;include&gt;postfix_rules.xml&lt;/include&gt;\n    &lt;include&gt;sendmail_rules.xml&lt;/include&gt;\n    &lt;include&gt;imapd_rules.xml&lt;/include&gt;\n    &lt;include&gt;mailscanner_rules.xml&lt;/include&gt;\n    &lt;include&gt;dovecot_rules.xml&lt;/include&gt;\n    &lt;include&gt;ms-exchange_rules.xml&lt;/include&gt;\n    &lt;include&gt;racoon_rules.xml&lt;/include&gt;\n    &lt;include&gt;vpn_concentrator_rules.xml&lt;/include&gt;\n    &lt;include&gt;spamd_rules.xml&lt;/include&gt;\n    &lt;include&gt;msauth_rules.xml&lt;/include&gt;\n    &lt;include&gt;mcafee_av_rules.xml&lt;/include&gt;\n    &lt;include&gt;trend-osce_rules.xml&lt;/include&gt;\n    &lt;include&gt;ms-se_rules.xml&lt;/include&gt;\n    &lt;include&gt;zeus_rules.xml&lt;/include&gt;\n    &lt;include&gt;solaris_bsm_rules.xml&lt;/include&gt;\n    &lt;include&gt;vmware_rules.xml&lt;/include&gt;\n    &lt;include&gt;ms_dhcp_rules.xml&lt;/include&gt;\n    &lt;include&gt;asterisk_rules.xml&lt;/include&gt;\n    &lt;include&gt;ossec_rules.xml&lt;/include&gt;\n    &lt;include&gt;attack_rules.xml&lt;/include&gt;\n    &lt;include&gt;local_rules.xml&lt;/include&gt;\n  &lt;/rules&gt;\n\n  &lt;syscheck&gt;\n    &lt;directories check_all=\"yes\"&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt;\n    &lt;directories check_all=\"yes\"&gt;/bin,/sbin&lt;/directories&gt;\n    &lt;directories check_all=\"yes\"&gt;/app&lt;/directories&gt;\n  &lt;/syscheck&gt;\n\n  &lt;rootcheck&gt;\n    &lt;rootkit_files&gt;/var/ossec/etc/shared/rootkit_files.txt&lt;/rootkit_files&gt;\n    &lt;rootkit_trojans&gt;/var/ossec/etc/shared/rootkit_trojans.txt&lt;/rootkit_trojans&gt;\n  &lt;/rootcheck&gt;\n\n  &lt;localfile&gt;\n    &lt;log_format&gt;syslog&lt;/log_format&gt;\n    &lt;location&gt;/var/log/auth.log&lt;/location&gt;\n  &lt;/localfile&gt;\n\n  &lt;localfile&gt;\n    &lt;log_format&gt;syslog&lt;/log_format&gt;\n    &lt;location&gt;/var/log/syslog&lt;/location&gt;\n  &lt;/localfile&gt;\n\n  &lt;localfile&gt;\n    &lt;log_format&gt;apache&lt;/log_format&gt;\n    &lt;location&gt;/var/log/nginx/access.log&lt;/location&gt;\n  &lt;/localfile&gt;\n\n  &lt;localfile&gt;\n    &lt;log_format&gt;apache&lt;/log_format&gt;\n    &lt;location&gt;/var/log/nginx/error.log&lt;/location&gt;\n  &lt;/localfile&gt;\n&lt;/ossec_config&gt;\n</code></pre>"},{"location":"deployment/security/#security-alerting","title":"Security Alerting","text":""},{"location":"deployment/security/#custom-security-alerts","title":"Custom Security Alerts","text":"<pre><code># backend/services/security_alerts.py\nimport logging\nfrom typing import Dict, Any\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\nclass SecurityAlertManager:\n    \"\"\"Manage security alerts and notifications\"\"\"\n\n    def __init__(self):\n        self.failed_attempts = defaultdict(list)\n        self.suspicious_activities = []\n\n    def log_failed_login(self, ip_address: str, user_agent: str):\n        \"\"\"Log failed login attempt\"\"\"\n        self.failed_attempts[ip_address].append({\n            'timestamp': datetime.utcnow(),\n            'user_agent': user_agent\n        })\n\n        # Check for brute force attack\n        recent_attempts = [\n            attempt for attempt in self.failed_attempts[ip_address]\n            if attempt['timestamp'] &gt; datetime.utcnow() - timedelta(minutes=15)\n        ]\n\n        if len(recent_attempts) &gt;= 5:\n            self._trigger_brute_force_alert(ip_address, recent_attempts)\n\n    def log_suspicious_activity(self, activity_type: str, details: Dict[str, Any]):\n        \"\"\"Log suspicious activity\"\"\"\n        alert = {\n            'type': activity_type,\n            'timestamp': datetime.utcnow(),\n            'details': details\n        }\n\n        self.suspicious_activities.append(alert)\n\n        # Trigger immediate alert for critical activities\n        if activity_type in ['sql_injection', 'file_upload_malware', 'privilege_escalation']:\n            self._trigger_critical_alert(alert)\n\n    def _trigger_brute_force_alert(self, ip_address: str, attempts: list):\n        \"\"\"Trigger brute force attack alert\"\"\"\n        logging.critical(\n            \"Brute force attack detected\",\n            extra={\n                'security_alert': True,\n                'alert_type': 'brute_force',\n                'ip_address': ip_address,\n                'attempt_count': len(attempts),\n                'time_window': '15 minutes'\n            }\n        )\n\n        # Send notification to security team\n        self._send_security_notification(\n            \"Brute Force Attack Detected\",\n            f\"IP {ip_address} has made {len(attempts)} failed login attempts in 15 minutes\"\n        )\n\n    def _trigger_critical_alert(self, alert: Dict[str, Any]):\n        \"\"\"Trigger critical security alert\"\"\"\n        logging.critical(\n            \"Critical security event detected\",\n            extra={\n                'security_alert': True,\n                'alert_type': alert['type'],\n                'details': alert['details']\n            }\n        )\n\n        # Immediate notification\n        self._send_security_notification(\n            f\"Critical Security Alert: {alert['type']}\",\n            f\"Details: {alert['details']}\"\n        )\n\n    def _send_security_notification(self, subject: str, message: str):\n        \"\"\"Send security notification\"\"\"\n        # Implement notification logic (email, Slack, etc.)\n        pass\n\n# Middleware for security monitoring\nclass SecurityMonitoringMiddleware(BaseHTTPMiddleware):\n    \"\"\"Monitor requests for security threats\"\"\"\n\n    def __init__(self, app):\n        super().__init__(app)\n        self.alert_manager = SecurityAlertManager()\n\n    async def dispatch(self, request: Request, call_next):\n        # Check for suspicious patterns\n        self._check_sql_injection(request)\n        self._check_xss_attempts(request)\n        self._check_path_traversal(request)\n\n        response = await call_next(request)\n\n        # Log failed authentication attempts\n        if response.status_code == 401:\n            self.alert_manager.log_failed_login(\n                request.client.host,\n                request.headers.get('user-agent', '')\n            )\n\n        return response\n\n    def _check_sql_injection(self, request: Request):\n        \"\"\"Check for SQL injection attempts\"\"\"\n        sql_patterns = [\n            r\"union\\s+select\",\n            r\"drop\\s+table\",\n            r\"insert\\s+into\",\n            r\"delete\\s+from\",\n            r\"update\\s+.*set\",\n            r\"exec\\s*\\(\",\n            r\"script\\s*&gt;\",\n            r\"&lt;\\s*script\"\n        ]\n\n        query_string = str(request.url.query).lower()\n\n        for pattern in sql_patterns:\n            if re.search(pattern, query_string):\n                self.alert_manager.log_suspicious_activity(\n                    'sql_injection',\n                    {\n                        'ip_address': request.client.host,\n                        'url': str(request.url),\n                        'pattern': pattern,\n                        'user_agent': request.headers.get('user-agent', '')\n                    }\n                )\n                break\n\n    def _check_xss_attempts(self, request: Request):\n        \"\"\"Check for XSS attempts\"\"\"\n        xss_patterns = [\n            r\"&lt;script\",\n            r\"javascript:\",\n            r\"onload\\s*=\",\n            r\"onerror\\s*=\",\n            r\"onclick\\s*=\"\n        ]\n\n        query_string = str(request.url.query).lower()\n\n        for pattern in xss_patterns:\n            if re.search(pattern, query_string):\n                self.alert_manager.log_suspicious_activity(\n                    'xss_attempt',\n                    {\n                        'ip_address': request.client.host,\n                        'url': str(request.url),\n                        'pattern': pattern\n                    }\n                )\n                break\n\n    def _check_path_traversal(self, request: Request):\n        \"\"\"Check for path traversal attempts\"\"\"\n        path = str(request.url.path)\n\n        if '../' in path or '..\\\\' in path:\n            self.alert_manager.log_suspicious_activity(\n                'path_traversal',\n                {\n                    'ip_address': request.client.host,\n                    'path': path\n                }\n            )\n</code></pre>"},{"location":"deployment/security/#incident-response","title":"Incident Response","text":""},{"location":"deployment/security/#security-incident-playbook","title":"Security Incident Playbook","text":""},{"location":"deployment/security/#1-detection-and-analysis","title":"1. Detection and Analysis","text":"<pre><code># backend/services/incident_response.py\nfrom enum import Enum\nfrom typing import List, Dict, Any\nfrom datetime import datetime\n\nclass IncidentSeverity(Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\nclass SecurityIncident:\n    \"\"\"Security incident management\"\"\"\n\n    def __init__(self, incident_type: str, severity: IncidentSeverity, description: str):\n        self.id = str(uuid.uuid4())\n        self.type = incident_type\n        self.severity = severity\n        self.description = description\n        self.created_at = datetime.utcnow()\n        self.status = \"open\"\n        self.actions_taken = []\n        self.affected_systems = []\n\n    def add_action(self, action: str, performed_by: str):\n        \"\"\"Add action taken during incident response\"\"\"\n        self.actions_taken.append({\n            'timestamp': datetime.utcnow(),\n            'action': action,\n            'performed_by': performed_by\n        })\n\n    def add_affected_system(self, system: str):\n        \"\"\"Add affected system to incident\"\"\"\n        if system not in self.affected_systems:\n            self.affected_systems.append(system)\n\n    def close_incident(self, resolution: str):\n        \"\"\"Close the incident\"\"\"\n        self.status = \"closed\"\n        self.resolution = resolution\n        self.closed_at = datetime.utcnow()\n\nclass IncidentResponseManager:\n    \"\"\"Manage security incident response\"\"\"\n\n    def __init__(self):\n        self.active_incidents = {}\n        self.incident_history = []\n\n    def create_incident(self, incident_type: str, severity: IncidentSeverity, \n                       description: str) -&gt; SecurityIncident:\n        \"\"\"Create new security incident\"\"\"\n        incident = SecurityIncident(incident_type, severity, description)\n        self.active_incidents[incident.id] = incident\n\n        # Trigger immediate response for critical incidents\n        if severity == IncidentSeverity.CRITICAL:\n            self._trigger_emergency_response(incident)\n\n        return incident\n\n    def _trigger_emergency_response(self, incident: SecurityIncident):\n        \"\"\"Trigger emergency response procedures\"\"\"\n        # Immediate actions for critical incidents\n        actions = [\n            \"Notify security team immediately\",\n            \"Isolate affected systems if necessary\",\n            \"Begin evidence collection\",\n            \"Activate incident response team\"\n        ]\n\n        for action in actions:\n            incident.add_action(action, \"automated_system\")\n\n        # Send emergency notifications\n        self._send_emergency_notification(incident)\n\n    def _send_emergency_notification(self, incident: SecurityIncident):\n        \"\"\"Send emergency notification to response team\"\"\"\n        # Implement emergency notification logic\n        pass\n</code></pre>"},{"location":"deployment/security/#2-containment-and-eradication","title":"2. Containment and Eradication","text":"<pre><code>#!/bin/bash\n# incident-containment.sh\n\n# Isolate compromised system\niptables -A INPUT -s COMPROMISED_IP -j DROP\niptables -A OUTPUT -d COMPROMISED_IP -j DROP\n\n# Stop affected services\nsystemctl stop culicidaelab-backend\nsystemctl stop culicidaelab-frontend\n\n# Create forensic image\ndd if=/dev/sda of=/forensics/system-image-$(date +%Y%m%d-%H%M%S).img bs=4M\n\n# Preserve logs\ncp -r /var/log /forensics/logs-$(date +%Y%m%d-%H%M%S)\n\n# Change all passwords\npasswd root\n# Change application passwords and API keys\n\n# Update and patch system\napt update &amp;&amp; apt upgrade -y\n\n# Scan for malware\nclamscan -r /app --log=/forensics/malware-scan.log\n\n# Restart services with new configuration\nsystemctl start culicidaelab-backend\nsystemctl start culicidaelab-frontend\n</code></pre>"},{"location":"deployment/security/#recovery-and-lessons-learned","title":"Recovery and Lessons Learned","text":""},{"location":"deployment/security/#post-incident-analysis","title":"Post-Incident Analysis","text":"<pre><code># backend/services/post_incident.py\nclass PostIncidentAnalysis:\n    \"\"\"Conduct post-incident analysis\"\"\"\n\n    def __init__(self, incident: SecurityIncident):\n        self.incident = incident\n        self.timeline = []\n        self.root_causes = []\n        self.recommendations = []\n\n    def analyze_incident(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze incident and generate report\"\"\"\n\n        # Build timeline\n        self._build_timeline()\n\n        # Identify root causes\n        self._identify_root_causes()\n\n        # Generate recommendations\n        self._generate_recommendations()\n\n        return {\n            'incident_id': self.incident.id,\n            'timeline': self.timeline,\n            'root_causes': self.root_causes,\n            'recommendations': self.recommendations,\n            'lessons_learned': self._extract_lessons_learned()\n        }\n\n    def _build_timeline(self):\n        \"\"\"Build incident timeline\"\"\"\n        # Analyze logs and actions to build timeline\n        pass\n\n    def _identify_root_causes(self):\n        \"\"\"Identify root causes of incident\"\"\"\n        # Analyze incident data to identify causes\n        pass\n\n    def _generate_recommendations(self):\n        \"\"\"Generate security improvement recommendations\"\"\"\n        common_recommendations = [\n            \"Implement additional monitoring\",\n            \"Update security policies\",\n            \"Conduct security training\",\n            \"Review access controls\",\n            \"Update incident response procedures\"\n        ]\n\n        self.recommendations.extend(common_recommendations)\n\n    def _extract_lessons_learned(self) -&gt; List[str]:\n        \"\"\"Extract lessons learned from incident\"\"\"\n        return [\n            \"Importance of rapid detection\",\n            \"Need for automated response\",\n            \"Value of regular security training\",\n            \"Critical nature of backup systems\"\n        ]\n</code></pre>"},{"location":"deployment/security/#security-best-practices-summary","title":"Security Best Practices Summary","text":""},{"location":"deployment/security/#development-security","title":"Development Security","text":"<ol> <li>Secure Coding Practices</li> <li>Input validation and sanitization</li> <li>Output encoding</li> <li>Parameterized queries</li> <li> <p>Error handling without information disclosure</p> </li> <li> <p>Dependency Management</p> </li> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>License compliance</li> <li> <p>Minimal dependencies</p> </li> <li> <p>Code Review</p> </li> <li>Security-focused code reviews</li> <li>Automated security testing</li> <li>Static code analysis</li> <li>Penetration testing</li> </ol>"},{"location":"deployment/security/#deployment-security","title":"Deployment Security","text":"<ol> <li>Infrastructure Hardening</li> <li>Server hardening</li> <li>Network segmentation</li> <li>Access controls</li> <li> <p>Regular updates</p> </li> <li> <p>Monitoring and Alerting</p> </li> <li>Real-time monitoring</li> <li>Security event correlation</li> <li>Incident response procedures</li> <li> <p>Regular security assessments</p> </li> <li> <p>Data Protection</p> </li> <li>Encryption at rest and in transit</li> <li>Access logging</li> <li>Data retention policies</li> <li>Privacy compliance</li> </ol>"},{"location":"deployment/security/#operational-security","title":"Operational Security","text":"<ol> <li>Access Management</li> <li>Principle of least privilege</li> <li>Multi-factor authentication</li> <li>Regular access reviews</li> <li> <p>Secure credential storage</p> </li> <li> <p>Backup and Recovery</p> </li> <li>Regular backups</li> <li>Backup encryption</li> <li>Recovery testing</li> <li> <p>Disaster recovery planning</p> </li> <li> <p>Compliance and Auditing</p> </li> <li>Regular security audits</li> <li>Compliance monitoring</li> <li>Documentation maintenance</li> <li>Staff training</li> </ol>"},{"location":"developer-guide/architecture/","title":"System Architecture","text":"<p>This document provides a comprehensive overview of the CulicidaeLab Server architecture, including system components, data flow, and technical design decisions.</p>"},{"location":"developer-guide/architecture/#overview","title":"Overview","text":"<p>CulicidaeLab Server is a full-stack web application built with modern Python technologies, designed for mosquito research, surveillance, and data analysis. The system follows a microservices-inspired architecture with clear separation between frontend and backend components.</p>"},{"location":"developer-guide/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"Frontend Layer\"\n        UI[Solara Web UI]\n        COMP[React Components]\n        STATE[State Management]\n    end\n\n    subgraph \"API Layer\"\n        FASTAPI[FastAPI Server]\n        ROUTES[API Routes]\n        MIDDLEWARE[CORS/Auth Middleware]\n    end\n\n    subgraph \"Service Layer\"\n        PRED[Prediction Service]\n        GEO[Geo Service]\n        SPECIES[Species Service]\n        DISEASE[Disease Service]\n        OBS[Observation Service]\n        CACHE[Cache Service]\n    end\n\n    subgraph \"Data Layer\"\n        LANCE[LanceDB Vector DB]\n        MODELS[AI Models]\n        STATIC[Static Files]\n    end\n\n    subgraph \"External Dependencies\"\n        CULICIDAE[culicidaelab Library]\n        FASTAI[FastAI Models]\n        HUGGINGFACE[HuggingFace Models]\n    end\n\n    UI --&gt; FASTAPI\n    COMP --&gt; STATE\n    STATE --&gt; FASTAPI\n\n    FASTAPI --&gt; ROUTES\n    ROUTES --&gt; MIDDLEWARE\n    MIDDLEWARE --&gt; PRED\n    MIDDLEWARE --&gt; GEO\n    MIDDLEWARE --&gt; SPECIES\n    MIDDLEWARE --&gt; DISEASE\n    MIDDLEWARE --&gt; OBS\n\n    PRED --&gt; CACHE\n    GEO --&gt; CACHE\n    SPECIES --&gt; CACHE\n    DISEASE --&gt; CACHE\n    OBS --&gt; CACHE\n\n    CACHE --&gt; LANCE\n    PRED --&gt; MODELS\n    SPECIES --&gt; LANCE\n    DISEASE --&gt; LANCE\n    OBS --&gt; LANCE\n    GEO --&gt; LANCE\n\n    PRED --&gt; CULICIDAE\n    MODELS --&gt; FASTAI\n    MODELS --&gt; HUGGINGFACE</code></pre>"},{"location":"developer-guide/architecture/#component-architecture","title":"Component Architecture","text":""},{"location":"developer-guide/architecture/#frontend-architecture-solara","title":"Frontend Architecture (Solara)","text":"<p>The frontend is built using Solara, a pure Python reactive web framework that compiles to modern web technologies.</p>"},{"location":"developer-guide/architecture/#key-components","title":"Key Components:","text":"<ul> <li>Main Application (<code>frontend/main.py</code>): Entry point and routing configuration</li> <li>Pages (<code>frontend/pages/</code>): Individual page components for different features</li> <li>Components (<code>frontend/components/</code>): Reusable UI components organized by feature</li> <li>State Management (<code>frontend/state.py</code>): Global application state using Solara reactives</li> <li>Configuration (<code>frontend/config.py</code>): Frontend settings, themes, and API endpoints</li> </ul>"},{"location":"developer-guide/architecture/#frontend-data-flow","title":"Frontend Data Flow:","text":"<pre><code>sequenceDiagram\n    participant User\n    participant UI as Solara UI\n    participant State as State Manager\n    participant API as Backend API\n    participant DB as LanceDB\n\n    User-&gt;&gt;UI: Interact with component\n    UI-&gt;&gt;State: Update reactive state\n    State-&gt;&gt;API: HTTP request\n    API-&gt;&gt;DB: Query data\n    DB--&gt;&gt;API: Return results\n    API--&gt;&gt;State: JSON response\n    State--&gt;&gt;UI: Update component\n    UI--&gt;&gt;User: Render changes</code></pre>"},{"location":"developer-guide/architecture/#backend-architecture-fastapi","title":"Backend Architecture (FastAPI)","text":"<p>The backend follows a layered architecture pattern with clear separation of concerns.</p>"},{"location":"developer-guide/architecture/#layer-structure","title":"Layer Structure:","text":"<ol> <li>API Layer (<code>backend/routers/</code>): FastAPI route handlers</li> <li>Service Layer (<code>backend/services/</code>): Business logic and data processing</li> <li>Schema Layer (<code>backend/schemas/</code>): Pydantic models for request/response validation</li> <li>Data Layer (<code>backend/database_utils/</code>): Database connection and query utilities</li> </ol>"},{"location":"developer-guide/architecture/#backend-components","title":"Backend Components:","text":"<ul> <li>Main Application (<code>backend/main.py</code>): FastAPI app initialization and configuration</li> <li>Configuration (<code>backend/config.py</code>): Settings management with Pydantic</li> <li>Dependencies (<code>backend/dependencies.py</code>): Dependency injection for common services</li> <li>Routers: Feature-specific API endpoints</li> <li><code>species.py</code>: Species information and search</li> <li><code>diseases.py</code>: Disease data and vector relationships</li> <li><code>prediction.py</code>: AI-powered species prediction</li> <li><code>geo.py</code>: Geographic data and observations</li> <li><code>observation.py</code>: User observation management</li> <li><code>filters.py</code>: Filter options for UI components</li> </ul>"},{"location":"developer-guide/architecture/#data-architecture","title":"Data Architecture","text":""},{"location":"developer-guide/architecture/#lancedb-vector-database","title":"LanceDB Vector Database","text":"<p>The system uses LanceDB as the primary data store, providing:</p> <ul> <li>Vector similarity search for species identification</li> <li>Geospatial indexing for location-based queries</li> <li>Schema evolution support for data model changes</li> <li>High-performance queries with automatic indexing</li> </ul>"},{"location":"developer-guide/architecture/#data-models","title":"Data Models:","text":"<pre><code># Core data structures\nSpecies {\n    id: str\n    scientific_name: str\n    common_names: dict[str, str]\n    description: dict[str, str]\n    images: list[str]\n    distribution: dict\n    vector_embedding: list[float]\n}\n\nObservation {\n    id: str\n    species_id: str\n    location: Point\n    timestamp: datetime\n    confidence: float\n    user_id: str\n    image_path: str\n}\n\nDisease {\n    id: str\n    name: dict[str, str]\n    description: dict[str, str]\n    symptoms: dict[str, str]\n    vectors: list[str]\n    prevention: dict[str, str]\n}\n</code></pre>"},{"location":"developer-guide/architecture/#aiml-integration","title":"AI/ML Integration","text":""},{"location":"developer-guide/architecture/#model-architecture","title":"Model Architecture","text":"<p>The system integrates with the <code>culicidaelab</code> library for AI-powered species identification:</p> <pre><code>graph LR\n    subgraph \"AI Pipeline\"\n        INPUT[Image Input]\n        PREPROCESS[Preprocessing]\n        CLASSIFY[Classification Model]\n        DETECT[Detection Model]\n        SEGMENT[Segmentation Model]\n        POSTPROCESS[Post-processing]\n        OUTPUT[Prediction Results]\n    end\n\n    INPUT --&gt; PREPROCESS\n    PREPROCESS --&gt; CLASSIFY\n    PREPROCESS --&gt; DETECT\n    PREPROCESS --&gt; SEGMENT\n    CLASSIFY --&gt; POSTPROCESS\n    DETECT --&gt; POSTPROCESS\n    SEGMENT --&gt; POSTPROCESS\n    POSTPROCESS --&gt; OUTPUT</code></pre>"},{"location":"developer-guide/architecture/#model-types","title":"Model Types:","text":"<ol> <li>Classification Models: Species identification from images</li> <li>Detection Models: Mosquito detection and localization</li> <li>Segmentation Models: Precise mosquito boundary detection</li> </ol>"},{"location":"developer-guide/architecture/#performance-considerations","title":"Performance Considerations:","text":"<ul> <li>GPU Acceleration: CUDA support for faster inference</li> <li>Model Caching: Pre-loaded models for reduced latency</li> <li>Batch Processing: Efficient handling of multiple predictions</li> <li>Fallback Mechanisms: CPU processing when GPU unavailable</li> </ul>"},{"location":"developer-guide/architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"developer-guide/architecture/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>Currently implements basic security measures:</p> <ul> <li>CORS Configuration: Controlled cross-origin access</li> <li>Input Validation: Pydantic schema validation</li> <li>File Upload Security: Image type and size validation</li> <li>Rate Limiting: (Planned) API request throttling</li> </ul>"},{"location":"developer-guide/architecture/#data-security","title":"Data Security","text":"<ul> <li>Input Sanitization: All user inputs validated</li> <li>SQL Injection Prevention: Parameterized queries via LanceDB</li> <li>File System Security: Controlled file access patterns</li> <li>Environment Variables: Sensitive configuration externalized</li> </ul>"},{"location":"developer-guide/architecture/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"developer-guide/architecture/#development-environment","title":"Development Environment","text":"<pre><code>graph TB\n    subgraph \"Development Setup\"\n        DEV_FE[Frontend Dev Server&lt;br/&gt;localhost:8765]\n        DEV_BE[Backend Dev Server&lt;br/&gt;localhost:8000]\n        DEV_DB[Local LanceDB]\n    end\n\n    DEV_FE --&gt; DEV_BE\n    DEV_BE --&gt; DEV_DB</code></pre>"},{"location":"developer-guide/architecture/#production-environment","title":"Production Environment","text":"<pre><code>graph TB\n    subgraph \"Production Deployment\"\n        LB[Load Balancer]\n        FE[Frontend Server]\n        BE[Backend Server]\n        DB[LanceDB Storage]\n        STATIC[Static File Server]\n    end\n\n    LB --&gt; FE\n    LB --&gt; BE\n    BE --&gt; DB\n    FE --&gt; STATIC</code></pre>"},{"location":"developer-guide/architecture/#performance-considerations_1","title":"Performance Considerations","text":""},{"location":"developer-guide/architecture/#frontend-performance","title":"Frontend Performance","text":"<ul> <li>Component Lazy Loading: On-demand component loading</li> <li>State Optimization: Efficient reactive state updates</li> <li>Asset Optimization: Compressed images and static files</li> <li>Caching Strategy: Browser and CDN caching</li> </ul>"},{"location":"developer-guide/architecture/#backend-performance","title":"Backend Performance","text":"<ul> <li>Database Indexing: Optimized LanceDB indexes</li> <li>Connection Pooling: Efficient database connections</li> <li>Async Processing: Non-blocking I/O operations</li> <li>Response Caching: Cached API responses for static data</li> </ul>"},{"location":"developer-guide/architecture/#monitoring-observability","title":"Monitoring &amp; Observability","text":"<ul> <li>Application Logs: Structured logging throughout the system</li> <li>Performance Metrics: Response time and throughput monitoring</li> <li>Error Tracking: Comprehensive error logging and alerting</li> <li>Health Checks: System health monitoring endpoints</li> </ul>"},{"location":"developer-guide/architecture/#technology-stack-summary","title":"Technology Stack Summary","text":""},{"location":"developer-guide/architecture/#frontend-stack","title":"Frontend Stack","text":"<ul> <li>Solara: Pure Python web framework</li> <li>ipyleaflet: Interactive mapping components</li> <li>Plotly: Data visualization</li> <li>Material Design: UI component library</li> </ul>"},{"location":"developer-guide/architecture/#backend-stack","title":"Backend Stack","text":"<ul> <li>FastAPI: High-performance web framework</li> <li>Uvicorn: ASGI server</li> <li>Pydantic: Data validation and settings</li> <li>LanceDB: Vector database</li> <li>culicidaelab: AI/ML library</li> </ul>"},{"location":"developer-guide/architecture/#development-tools","title":"Development Tools","text":"<ul> <li>uv: Python package management</li> <li>pytest: Testing framework</li> <li>Black: Code formatting</li> <li>mypy: Type checking</li> <li>pre-commit: Git hooks for code quality</li> </ul>"},{"location":"developer-guide/backend-development/","title":"Backend Development Guide","text":"<p>This guide covers backend development for the CulicidaeLab Server, including setup, architecture patterns, and best practices for working with the FastAPI-based API server.</p>"},{"location":"developer-guide/backend-development/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"developer-guide/backend-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>uv package manager (recommended) or pip</li> <li>Git</li> <li>CUDA-capable GPU (optional, for AI model acceleration)</li> </ul>"},{"location":"developer-guide/backend-development/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Clone and navigate to the project: <pre><code>git clone https://github.com/iloncka-ds/culicidaelab-server.git\ncd culicidaelab-server\n</code></pre></p> </li> <li> <p>Set up Python environment: <pre><code># Using uv (recommended)\nuv venv -p 3.11\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv sync -p 3.11\n\n# Or using pip\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -e .\n</code></pre></p> </li> <li> <p>Configure environment variables: <pre><code># Copy example environment file\ncp backend/.env.example backend/.env\n\n# Edit backend/.env with your settings\nCULICIDAELAB_DATABASE_PATH=.lancedb\nCULICIDAELAB_SAVE_PREDICTED_IMAGES=false\n</code></pre></p> </li> <li> <p>Initialize the database: <pre><code># Generate sample data\npython -m backend.data.sample_data.generate_sample_data\n\n# Populate LanceDB\npython -m backend.scripts.populate_lancedb\n\n# Verify setup\npython -m backend.scripts.query_lancedb observations --limit 5\n</code></pre></p> </li> </ol>"},{"location":"developer-guide/backend-development/#running-the-backend-server","title":"Running the Backend Server","text":"<pre><code># Development server with auto-reload\nuvicorn backend.main:app --port 8000 --host 127.0.0.1 --reload\n\n# Production server\nuvicorn backend.main:app --port 8000 --host 0.0.0.0\n</code></pre> <p>The API will be available at: - Swagger UI: http://localhost:8000/docs - ReDoc: http://localhost:8000/redoc - OpenAPI JSON: http://localhost:8000/api/openapi.json</p>"},{"location":"developer-guide/backend-development/#project-structure","title":"Project Structure","text":"<pre><code>backend/\n\u251c\u2500\u2500 main.py                 # FastAPI application entry point\n\u251c\u2500\u2500 config.py              # Application configuration\n\u251c\u2500\u2500 dependencies.py        # Dependency injection\n\u251c\u2500\u2500 routers/               # API route handlers\n\u2502   \u251c\u2500\u2500 species.py         # Species-related endpoints\n\u2502   \u251c\u2500\u2500 diseases.py        # Disease information endpoints\n\u2502   \u251c\u2500\u2500 prediction.py      # AI prediction endpoints\n\u2502   \u251c\u2500\u2500 geo.py            # Geographic data endpoints\n\u2502   \u251c\u2500\u2500 observation.py    # User observation endpoints\n\u2502   \u2514\u2500\u2500 filters.py        # Filter options endpoints\n\u251c\u2500\u2500 services/              # Business logic layer\n\u2502   \u251c\u2500\u2500 database.py        # Database connection utilities\n\u2502   \u251c\u2500\u2500 cache_service.py   # Caching and data loading\n\u2502   \u251c\u2500\u2500 species_service.py # Species data operations\n\u2502   \u251c\u2500\u2500 disease_service.py # Disease data operations\n\u2502   \u251c\u2500\u2500 prediction_service.py # AI prediction logic\n\u2502   \u251c\u2500\u2500 geo_service.py     # Geographic operations\n\u2502   \u2514\u2500\u2500 observation_service.py # Observation management\n\u251c\u2500\u2500 schemas/               # Pydantic data models\n\u2502   \u251c\u2500\u2500 species_schemas.py # Species data structures\n\u2502   \u251c\u2500\u2500 diseases_schemas.py # Disease data structures\n\u2502   \u251c\u2500\u2500 prediction_schemas.py # Prediction request/response\n\u2502   \u251c\u2500\u2500 geo_schemas.py     # Geographic data structures\n\u2502   \u2514\u2500\u2500 observation_schemas.py # Observation data structures\n\u251c\u2500\u2500 database_utils/        # Database utilities\n\u2502   \u2514\u2500\u2500 lancedb_manager.py # LanceDB operations\n\u251c\u2500\u2500 scripts/               # Utility scripts\n\u2502   \u251c\u2500\u2500 populate_lancedb.py # Database initialization\n\u2502   \u2514\u2500\u2500 query_lancedb.py   # Database querying tools\n\u2514\u2500\u2500 static/                # Static file serving\n    \u2514\u2500\u2500 images/            # Image assets\n</code></pre>"},{"location":"developer-guide/backend-development/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"developer-guide/backend-development/#layered-architecture","title":"Layered Architecture","text":"<p>The backend follows a clean layered architecture:</p> <ol> <li>Router Layer: HTTP request handling and response formatting</li> <li>Service Layer: Business logic and data processing</li> <li>Schema Layer: Data validation and serialization</li> <li>Data Layer: Database operations and external API calls</li> </ol>"},{"location":"developer-guide/backend-development/#dependency-injection","title":"Dependency Injection","text":"<p>FastAPI's dependency injection system is used throughout:</p> <pre><code># dependencies.py\nfrom fastapi import Depends\nfrom backend.services.database import get_db\n\ndef get_database_connection():\n    return get_db()\n\n# In routers\n@router.get(\"/species\")\nasync def get_species(db=Depends(get_database_connection)):\n    # Use db connection\n    pass\n</code></pre>"},{"location":"developer-guide/backend-development/#configuration-management","title":"Configuration Management","text":"<p>Settings are managed using Pydantic BaseSettings:</p> <pre><code># config.py\nfrom pydantic_settings import BaseSettings\n\nclass AppSettings(BaseSettings):\n    APP_NAME: str = \"CulicidaeLab API\"\n    DATABASE_PATH: str = \".lancedb\"\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_prefix=\"CULICIDAELAB_\"\n    )\n\nsettings = AppSettings()\n</code></pre>"},{"location":"developer-guide/backend-development/#api-development-guidelines","title":"API Development Guidelines","text":""},{"location":"developer-guide/backend-development/#router-structure","title":"Router Structure","text":"<p>Each router should follow this pattern:</p> <pre><code># routers/example.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom backend.schemas.example_schemas import ExampleResponse\nfrom backend.services.example_service import ExampleService\n\nrouter = APIRouter()\n\n@router.get(\"/examples\", response_model=list[ExampleResponse])\nasync def get_examples(\n    limit: int = 10,\n    service: ExampleService = Depends()\n):\n    \"\"\"Get a list of examples.\n\n    Args:\n        limit: Maximum number of results to return\n        service: Injected service dependency\n\n    Returns:\n        List of example objects\n\n    Raises:\n        HTTPException: If examples cannot be retrieved\n    \"\"\"\n    try:\n        return await service.get_examples(limit=limit)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"developer-guide/backend-development/#schema-definition","title":"Schema Definition","text":"<p>Use Pydantic models for all request/response schemas:</p> <pre><code># schemas/example_schemas.py\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional\n\nclass ExampleBase(BaseModel):\n    \"\"\"Base schema for example objects.\"\"\"\n    name: str = Field(..., description=\"Example name\")\n    description: Optional[str] = Field(None, description=\"Optional description\")\n\nclass ExampleCreate(ExampleBase):\n    \"\"\"Schema for creating new examples.\"\"\"\n    pass\n\nclass ExampleResponse(ExampleBase):\n    \"\"\"Schema for example API responses.\"\"\"\n    id: str = Field(..., description=\"Unique identifier\")\n    created_at: datetime = Field(..., description=\"Creation timestamp\")\n\n    model_config = {\"from_attributes\": True}\n</code></pre>"},{"location":"developer-guide/backend-development/#service-layer-implementation","title":"Service Layer Implementation","text":"<p>Services contain the business logic:</p> <pre><code># services/example_service.py\nfrom typing import List\nfrom backend.services.database import get_db, get_table\nfrom backend.schemas.example_schemas import ExampleResponse\n\nclass ExampleService:\n    \"\"\"Service for example-related operations.\"\"\"\n\n    def __init__(self):\n        self.db = get_db()\n        self.table = get_table(self.db, \"examples\")\n\n    async def get_examples(self, limit: int = 10) -&gt; List[ExampleResponse]:\n        \"\"\"Retrieve examples from the database.\n\n        Args:\n            limit: Maximum number of results\n\n        Returns:\n            List of example objects\n        \"\"\"\n        try:\n            results = self.table.search().limit(limit).to_list()\n            return [ExampleResponse(**item) for item in results]\n        except Exception as e:\n            raise ValueError(f\"Failed to retrieve examples: {e}\")\n</code></pre>"},{"location":"developer-guide/backend-development/#database-operations","title":"Database Operations","text":""},{"location":"developer-guide/backend-development/#lancedb-integration","title":"LanceDB Integration","text":"<p>The system uses LanceDB for vector similarity search and data storage:</p> <pre><code># Working with LanceDB\nfrom backend.services.database import get_db, get_table\n\n# Get database connection\ndb = get_db()\n\n# Open a table\nspecies_table = get_table(db, \"species\")\n\n# Basic queries\nresults = species_table.search().limit(10).to_list()\n\n# Vector similarity search\nquery_vector = [0.1, 0.2, 0.3, ...]  # Your embedding vector\nsimilar_species = (\n    species_table\n    .search(query_vector)\n    .limit(5)\n    .to_list()\n)\n\n# Filtered queries\nfiltered_results = (\n    species_table\n    .search()\n    .where(\"region = 'Europe'\")\n    .limit(10)\n    .to_list()\n)\n</code></pre>"},{"location":"developer-guide/backend-development/#database-schema-management","title":"Database Schema Management","text":"<p>Tables are created and managed through scripts:</p> <pre><code># scripts/populate_lancedb.py\nimport lancedb\nimport pandas as pd\n\ndef create_species_table(db):\n    \"\"\"Create and populate species table.\"\"\"\n    # Load data\n    df = pd.read_json(\"sample_data/sample_species.json\")\n\n    # Create table with schema\n    table = db.create_table(\"species\", df, mode=\"overwrite\")\n\n    # Create indexes for performance\n    table.create_index(\"scientific_name\")\n    table.create_index(\"region\")\n\n    return table\n</code></pre>"},{"location":"developer-guide/backend-development/#aiml-integration","title":"AI/ML Integration","text":""},{"location":"developer-guide/backend-development/#prediction-service","title":"Prediction Service","text":"<p>The prediction service integrates with the culicidaelab library:</p> <pre><code># services/prediction_service.py\nfrom culicidaelab import get_predictor\nfrom backend.config import settings\n\nclass PredictionService:\n    \"\"\"Service for AI-powered species prediction.\"\"\"\n\n    def __init__(self):\n        self.predictor = get_predictor(settings.classifier_settings)\n\n    async def predict_species(self, image_path: str) -&gt; dict:\n        \"\"\"Predict mosquito species from image.\n\n        Args:\n            image_path: Path to the image file\n\n        Returns:\n            Prediction results with confidence scores\n        \"\"\"\n        try:\n            results = self.predictor.predict(image_path)\n            return {\n                \"species\": results.species,\n                \"confidence\": results.confidence,\n                \"alternatives\": results.alternatives\n            }\n        except Exception as e:\n            raise ValueError(f\"Prediction failed: {e}\")\n</code></pre>"},{"location":"developer-guide/backend-development/#model-management","title":"Model Management","text":"<p>Models are managed through the configuration system:</p> <pre><code># config.py\ndef get_predictor_model_path():\n    \"\"\"Get the path to the predictor model.\"\"\"\n    settings = get_settings()\n    return settings.get_model_weights_path(\"segmenter\")\n\ndef get_predictor_settings():\n    \"\"\"Get complete predictor configuration.\"\"\"\n    return get_settings()\n</code></pre>"},{"location":"developer-guide/backend-development/#error-handling","title":"Error Handling","text":""},{"location":"developer-guide/backend-development/#exception-handling-strategy","title":"Exception Handling Strategy","text":"<p>Use consistent error handling patterns:</p> <pre><code>from fastapi import HTTPException\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@router.get(\"/species/{species_id}\")\nasync def get_species(species_id: str):\n    try:\n        species = await species_service.get_by_id(species_id)\n        if not species:\n            raise HTTPException(\n                status_code=404, \n                detail=f\"Species {species_id} not found\"\n            )\n        return species\n    except ValueError as e:\n        logger.error(f\"Validation error: {e}\")\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n</code></pre>"},{"location":"developer-guide/backend-development/#custom-exception-classes","title":"Custom Exception Classes","text":"<p>Define domain-specific exceptions:</p> <pre><code># exceptions.py\nclass CulicidaeLabException(Exception):\n    \"\"\"Base exception for CulicidaeLab errors.\"\"\"\n    pass\n\nclass SpeciesNotFoundError(CulicidaeLabException):\n    \"\"\"Raised when a species cannot be found.\"\"\"\n    pass\n\nclass PredictionError(CulicidaeLabException):\n    \"\"\"Raised when AI prediction fails.\"\"\"\n    pass\n</code></pre>"},{"location":"developer-guide/backend-development/#testing","title":"Testing","text":""},{"location":"developer-guide/backend-development/#unit-testing","title":"Unit Testing","text":"<p>Write comprehensive unit tests:</p> <pre><code># tests/test_species_service.py\nimport pytest\nfrom backend.services.species_service import SpeciesService\n\n@pytest.fixture\ndef species_service():\n    return SpeciesService()\n\n@pytest.mark.asyncio\nasync def test_get_species_by_id(species_service):\n    \"\"\"Test retrieving species by ID.\"\"\"\n    species = await species_service.get_by_id(\"aedes_aegypti\")\n    assert species is not None\n    assert species.scientific_name == \"Aedes aegypti\"\n\n@pytest.mark.asyncio\nasync def test_get_nonexistent_species(species_service):\n    \"\"\"Test handling of nonexistent species.\"\"\"\n    with pytest.raises(SpeciesNotFoundError):\n        await species_service.get_by_id(\"nonexistent_species\")\n</code></pre>"},{"location":"developer-guide/backend-development/#integration-testing","title":"Integration Testing","text":"<p>Test API endpoints:</p> <pre><code># tests/test_api.py\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\n\nclient = TestClient(app)\n\ndef test_get_species_list():\n    \"\"\"Test species list endpoint.\"\"\"\n    response = client.get(\"/api/species\")\n    assert response.status_code == 200\n    data = response.json()\n    assert isinstance(data, list)\n\ndef test_predict_species():\n    \"\"\"Test species prediction endpoint.\"\"\"\n    with open(\"test_image.jpg\", \"rb\") as f:\n        response = client.post(\n            \"/api/predict_species/\",\n            files={\"file\": (\"test.jpg\", f, \"image/jpeg\")}\n        )\n    assert response.status_code == 200\n    data = response.json()\n    assert \"species\" in data\n    assert \"confidence\" in data\n</code></pre>"},{"location":"developer-guide/backend-development/#performance-optimization","title":"Performance Optimization","text":""},{"location":"developer-guide/backend-development/#caching-strategy","title":"Caching Strategy","text":"<p>Implement caching for frequently accessed data:</p> <pre><code># services/cache_service.py\nfrom functools import lru_cache\nfrom typing import Dict, List\n\n@lru_cache(maxsize=128)\ndef load_species_names(db_conn) -&gt; Dict[str, str]:\n    \"\"\"Cache species names for quick lookup.\"\"\"\n    table = get_table(db_conn, \"species\")\n    results = table.search().to_list()\n    return {item[\"id\"]: item[\"scientific_name\"] for item in results}\n\n# Application startup caching\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Load caches on startup\n    app.state.SPECIES_NAMES = load_species_names(get_db())\n    yield\n</code></pre>"},{"location":"developer-guide/backend-development/#database-optimization","title":"Database Optimization","text":"<p>Optimize database queries:</p> <pre><code># Efficient querying patterns\ndef get_species_with_pagination(offset: int, limit: int):\n    \"\"\"Get species with efficient pagination.\"\"\"\n    return (\n        species_table\n        .search()\n        .offset(offset)\n        .limit(limit)\n        .select([\"id\", \"scientific_name\", \"common_names\"])  # Select only needed fields\n        .to_list()\n    )\n\n# Use indexes for filtering\ndef search_species_by_region(region: str):\n    \"\"\"Search species by region using index.\"\"\"\n    return (\n        species_table\n        .search()\n        .where(f\"region = '{region}'\")  # Uses region index\n        .to_list()\n    )\n</code></pre>"},{"location":"developer-guide/backend-development/#security-best-practices","title":"Security Best Practices","text":""},{"location":"developer-guide/backend-development/#input-validation","title":"Input Validation","text":"<p>Always validate inputs using Pydantic:</p> <pre><code>from pydantic import BaseModel, validator\nfrom typing import Optional\n\nclass SpeciesQuery(BaseModel):\n    region: Optional[str] = None\n    limit: int = 10\n\n    @validator('limit')\n    def validate_limit(cls, v):\n        if v &lt; 1 or v &gt; 100:\n            raise ValueError('Limit must be between 1 and 100')\n        return v\n\n    @validator('region')\n    def validate_region(cls, v):\n        if v and len(v) &lt; 2:\n            raise ValueError('Region must be at least 2 characters')\n        return v\n</code></pre>"},{"location":"developer-guide/backend-development/#file-upload-security","title":"File Upload Security","text":"<p>Secure file handling for image uploads:</p> <pre><code>from fastapi import UploadFile, HTTPException\nimport magic\n\nALLOWED_MIME_TYPES = {\"image/jpeg\", \"image/png\", \"image/webp\"}\nMAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\n\nasync def validate_image_upload(file: UploadFile):\n    \"\"\"Validate uploaded image file.\"\"\"\n    # Check file size\n    content = await file.read()\n    if len(content) &gt; MAX_FILE_SIZE:\n        raise HTTPException(400, \"File too large\")\n\n    # Check MIME type\n    mime_type = magic.from_buffer(content, mime=True)\n    if mime_type not in ALLOWED_MIME_TYPES:\n        raise HTTPException(400, \"Invalid file type\")\n\n    # Reset file pointer\n    await file.seek(0)\n    return file\n</code></pre>"},{"location":"developer-guide/backend-development/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"developer-guide/backend-development/#environment-configuration","title":"Environment Configuration","text":"<p>Use environment-specific settings:</p> <pre><code># config.py\nclass AppSettings(BaseSettings):\n    # Development vs Production settings\n    DEBUG: bool = False\n    LOG_LEVEL: str = \"INFO\"\n\n    # Database settings\n    DATABASE_PATH: str = \".lancedb\"\n    DATABASE_BACKUP_ENABLED: bool = True\n\n    # Security settings\n    CORS_ORIGINS: List[str] = [\"http://localhost:8765\"]\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_prefix=\"CULICIDAELAB_\"\n    )\n</code></pre>"},{"location":"developer-guide/backend-development/#health-checks","title":"Health Checks","text":"<p>Implement health check endpoints:</p> <pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint for monitoring.\"\"\"\n    try:\n        # Check database connectivity\n        db = get_db()\n        db.table_names()  # Simple connectivity test\n\n        return {\n            \"status\": \"healthy\",\n            \"timestamp\": datetime.utcnow(),\n            \"version\": \"1.0.0\"\n        }\n    except Exception as e:\n        raise HTTPException(500, f\"Health check failed: {e}\")\n</code></pre>"},{"location":"developer-guide/backend-development/#logging-configuration","title":"Logging Configuration","text":"<p>Set up structured logging:</p> <pre><code>import logging\nimport sys\n\ndef setup_logging():\n    \"\"\"Configure application logging.\"\"\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler('app.log')\n        ]\n    )\n\n    # Set specific log levels\n    logging.getLogger(\"uvicorn\").setLevel(logging.INFO)\n    logging.getLogger(\"fastapi\").setLevel(logging.INFO)\n</code></pre> <p>This guide provides the foundation for backend development on the CulicidaeLab Server. For specific implementation details, refer to the existing codebase and the API documentation available at <code>/docs</code> when running the server.</p>"},{"location":"developer-guide/contributing/","title":"Contributing Guidelines","text":"<p>Welcome to the CulicidaeLab Server project! We appreciate your interest in contributing to this open-source mosquito research and analysis platform. This guide will help you get started with contributing effectively.</p>"},{"location":"developer-guide/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please read it to understand the standards we expect from all contributors.</p>"},{"location":"developer-guide/contributing/#getting-started","title":"Getting Started","text":""},{"location":"developer-guide/contributing/#prerequisites","title":"Prerequisites","text":"<p>Before contributing, ensure you have:</p> <ul> <li>Python 3.11 or higher</li> <li>Git installed and configured</li> <li>Basic knowledge of FastAPI and Solara frameworks</li> <li>Understanding of mosquito research domain (helpful but not required)</li> </ul>"},{"location":"developer-guide/contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li> <p>Fork and Clone the Repository <pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/culicidaelab-server.git\ncd culicidaelab-server\n\n# Add upstream remote\ngit remote add upstream https://github.com/iloncka-ds/culicidaelab-server.git\n</code></pre></p> </li> <li> <p>Set Up Development Environment <pre><code># Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install dependencies\npip install -e .\n# Or with uv: uv sync -p 3.11\n\n# Install development dependencies\npip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Initialize Database <pre><code># Generate sample data\npython -m backend.data.sample_data.generate_sample_data\n\n# Populate database\npython -m backend.scripts.populate_lancedb\n\n# Verify setup\npython -m backend.scripts.query_lancedb observations --limit 5\n</code></pre></p> </li> <li> <p>Run Tests <pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=backend --cov=frontend\n</code></pre></p> </li> <li> <p>Start Development Servers <pre><code># Terminal 1: Backend\nuvicorn backend.main:app --port 8000 --reload\n\n# Terminal 2: Frontend\nsolara run frontend.main --port 8765\n</code></pre></p> </li> </ol>"},{"location":"developer-guide/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"developer-guide/contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>We welcome various types of contributions:</p> <ul> <li>Bug Reports: Help us identify and fix issues</li> <li>Feature Requests: Suggest new functionality</li> <li>Code Contributions: Implement features or fix bugs</li> <li>Documentation: Improve or add documentation</li> <li>Testing: Add or improve test coverage</li> <li>Performance: Optimize existing code</li> <li>Translations: Add support for new languages</li> </ul>"},{"location":"developer-guide/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting bugs or requesting features:</p> <ol> <li>Search Existing Issues: Check if the issue already exists</li> <li>Use Issue Templates: Follow the provided templates</li> <li>Provide Details: Include steps to reproduce, expected behavior, and environment info</li> <li>Add Labels: Use appropriate labels to categorize the issue</li> </ol>"},{"location":"developer-guide/contributing/#bug-report-template","title":"Bug Report Template","text":"<pre><code>**Bug Description**\nA clear description of the bug.\n\n**Steps to Reproduce**\n1. Go to '...'\n2. Click on '...'\n3. See error\n\n**Expected Behavior**\nWhat you expected to happen.\n\n**Actual Behavior**\nWhat actually happened.\n\n**Environment**\n- OS: [e.g., Windows 11, Ubuntu 22.04]\n- Python Version: [e.g., 3.11.5]\n- Browser: [e.g., Chrome 118]\n\n**Additional Context**\nScreenshots, logs, or other relevant information.\n</code></pre>"},{"location":"developer-guide/contributing/#making-code-changes","title":"Making Code Changes","text":""},{"location":"developer-guide/contributing/#workflow","title":"Workflow","text":"<ol> <li> <p>Create a Branch <pre><code># Update your fork\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n\n# Create feature branch\ngit checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-number-description\n</code></pre></p> </li> <li> <p>Make Changes</p> </li> <li>Follow the coding standards (see below)</li> <li>Write or update tests</li> <li>Update documentation if needed</li> <li> <p>Ensure all tests pass</p> </li> <li> <p>Commit Changes <pre><code># Stage changes\ngit add .\n\n# Commit with descriptive message\ngit commit -m \"feat: add species prediction caching\n\n- Implement LRU cache for prediction results\n- Add cache invalidation on model updates\n- Improve prediction response time by 40%\n\nCloses #123\"\n</code></pre></p> </li> <li> <p>Push and Create Pull Request <pre><code># Push to your fork\ngit push origin feature/your-feature-name\n\n# Create pull request on GitHub\n</code></pre></p> </li> </ol>"},{"location":"developer-guide/contributing/#commit-message-convention","title":"Commit Message Convention","text":"<p>We follow the Conventional Commits specification:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes (formatting, etc.) - <code>refactor</code>: Code refactoring - <code>test</code>: Adding or updating tests - <code>chore</code>: Maintenance tasks</p> <p>Examples: <pre><code>feat(api): add species similarity search endpoint\nfix(frontend): resolve map rendering issue on mobile\ndocs(readme): update installation instructions\ntest(backend): add integration tests for prediction service\n</code></pre></p>"},{"location":"developer-guide/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"developer-guide/contributing/#python-code-style","title":"Python Code Style","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Black: Code formatting</li> <li>isort: Import sorting</li> <li>mypy: Type checking</li> <li>flake8: Linting</li> </ul>"},{"location":"developer-guide/contributing/#setup-pre-commit-hooks","title":"Setup Pre-commit Hooks","text":"<pre><code># Install pre-commit\npip install pre-commit\n\n# Install hooks\npre-commit install\n\n# Run hooks manually\npre-commit run --all-files\n</code></pre>"},{"location":"developer-guide/contributing/#code-formatting","title":"Code Formatting","text":"<pre><code># Good: Clear, well-documented function\nasync def predict_species(\n    image_path: str,\n    confidence_threshold: float = 0.5\n) -&gt; PredictionResult:\n    \"\"\"Predict mosquito species from image.\n\n    Args:\n        image_path: Path to the image file\n        confidence_threshold: Minimum confidence for prediction\n\n    Returns:\n        Prediction result with species and confidence\n\n    Raises:\n        ValueError: If image cannot be processed\n        FileNotFoundError: If image file doesn't exist\n    \"\"\"\n    if not Path(image_path).exists():\n        raise FileNotFoundError(f\"Image not found: {image_path}\")\n\n    try:\n        result = await predictor.predict(image_path)\n        if result.confidence &lt; confidence_threshold:\n            logger.warning(f\"Low confidence prediction: {result.confidence}\")\n\n        return PredictionResult(\n            species=result.species,\n            confidence=result.confidence,\n            alternatives=result.alternatives\n        )\n    except Exception as e:\n        logger.error(f\"Prediction failed for {image_path}: {e}\")\n        raise ValueError(f\"Failed to predict species: {e}\")\n</code></pre>"},{"location":"developer-guide/contributing/#type-hints","title":"Type Hints","text":"<p>Use type hints throughout the codebase:</p> <pre><code>from typing import List, Dict, Optional, Union\nfrom pydantic import BaseModel\n\nclass SpeciesInfo(BaseModel):\n    \"\"\"Species information model.\"\"\"\n    id: str\n    scientific_name: str\n    common_names: Dict[str, str]\n    distribution: Optional[List[str]] = None\n\nasync def get_species_by_region(\n    region: str,\n    limit: int = 10\n) -&gt; List[SpeciesInfo]:\n    \"\"\"Get species found in a specific region.\"\"\"\n    # Implementation here\n    pass\n</code></pre>"},{"location":"developer-guide/contributing/#frontend-code-style","title":"Frontend Code Style","text":""},{"location":"developer-guide/contributing/#solara-component-guidelines","title":"Solara Component Guidelines","text":"<pre><code>import solara\nfrom typing import Callable, Optional\n\n@solara.component\ndef SpeciesCard(\n    species: dict,\n    on_click: Optional[Callable[[str], None]] = None,\n    show_details: bool = True\n):\n    \"\"\"Reusable species card component.\n\n    Args:\n        species: Species information dictionary\n        on_click: Callback when card is clicked\n        show_details: Whether to show detailed information\n    \"\"\"\n\n    def handle_click():\n        if on_click:\n            on_click(species[\"id\"])\n\n    with solara.Card(\n        title=species[\"scientific_name\"],\n        on_click=handle_click if on_click else None\n    ):\n        if show_details:\n            solara.Text(species.get(\"description\", \"\"))\n\n        # Display common names\n        common_names = species.get(\"common_names\", {})\n        if common_names:\n            for lang, name in common_names.items():\n                solara.Text(f\"{lang.upper()}: {name}\")\n</code></pre>"},{"location":"developer-guide/contributing/#state-management","title":"State Management","text":"<pre><code># Good: Clear state organization\nimport solara\nfrom typing import List, Optional\n\n# Global application state\ncurrent_user_id: solara.Reactive[Optional[str]] = solara.reactive(None)\nselected_species: solara.Reactive[List[str]] = solara.reactive([])\nloading_states = {\n    'species': solara.reactive(False),\n    'predictions': solara.reactive(False)\n}\n\n@solara.component\ndef use_species_data():\n    \"\"\"Hook for managing species data.\"\"\"\n    data, set_data = solara.use_state([])\n    error, set_error = solara.use_state(None)\n\n    async def fetch_data():\n        loading_states['species'].value = True\n        set_error(None)\n\n        try:\n            # Fetch data logic\n            result = await api_client.get_species()\n            set_data(result)\n        except Exception as e:\n            set_error(str(e))\n        finally:\n            loading_states['species'].value = False\n\n    return data, fetch_data, error\n</code></pre>"},{"location":"developer-guide/contributing/#database-guidelines","title":"Database Guidelines","text":""},{"location":"developer-guide/contributing/#lancedb-best-practices","title":"LanceDB Best Practices","text":"<pre><code># Good: Efficient database operations\nfrom backend.services.database import get_db, get_table\nfrom typing import List, Dict, Any\n\nclass SpeciesRepository:\n    \"\"\"Repository for species data operations.\"\"\"\n\n    def __init__(self):\n        self.db = get_db()\n        self.table = get_table(self.db, \"species\")\n\n    async def search_by_region(\n        self,\n        region: str,\n        limit: int = 10\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Search species by region with efficient querying.\"\"\"\n        try:\n            results = (\n                self.table\n                .search()\n                .where(f\"region = '{region}'\")\n                .limit(limit)\n                .select([\"id\", \"scientific_name\", \"common_names\"])  # Select only needed fields\n                .to_list()\n            )\n            return results\n        except Exception as e:\n            logger.error(f\"Failed to search species by region {region}: {e}\")\n            raise\n\n    async def similarity_search(\n        self,\n        query_vector: List[float],\n        limit: int = 5\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Perform vector similarity search.\"\"\"\n        try:\n            results = (\n                self.table\n                .search(query_vector)\n                .limit(limit)\n                .to_list()\n            )\n            return results\n        except Exception as e:\n            logger.error(f\"Similarity search failed: {e}\")\n            raise\n</code></pre>"},{"location":"developer-guide/contributing/#testing-requirements","title":"Testing Requirements","text":""},{"location":"developer-guide/contributing/#test-coverage","title":"Test Coverage","text":"<p>All contributions must include appropriate tests:</p> <ul> <li>New Features: Comprehensive test coverage (&gt;90%)</li> <li>Bug Fixes: Tests that reproduce the bug and verify the fix</li> <li>Refactoring: Existing tests must continue to pass</li> </ul>"},{"location":"developer-guide/contributing/#test-types","title":"Test Types","text":"<ol> <li>Unit Tests: Test individual functions/methods</li> <li>Integration Tests: Test component interactions</li> <li>API Tests: Test endpoint functionality</li> <li>Frontend Tests: Test component behavior</li> </ol>"},{"location":"developer-guide/contributing/#example-test-structure","title":"Example Test Structure","text":"<pre><code># tests/backend/test_services/test_species_service.py\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom backend.services.species_service import SpeciesService\n\nclass TestSpeciesService:\n    \"\"\"Test suite for SpeciesService.\"\"\"\n\n    @pytest.fixture\n    def species_service(self):\n        \"\"\"Create species service with mocked dependencies.\"\"\"\n        with patch('backend.services.species_service.get_db'):\n            return SpeciesService()\n\n    @pytest.mark.asyncio\n    async def test_get_species_by_id_success(self, species_service):\n        \"\"\"Test successful species retrieval.\"\"\"\n        # Arrange\n        expected_species = {\"id\": \"aedes_aegypti\", \"name\": \"Aedes aegypti\"}\n\n        # Act\n        result = await species_service.get_by_id(\"aedes_aegypti\")\n\n        # Assert\n        assert result is not None\n        assert result.id == \"aedes_aegypti\"\n\n    @pytest.mark.asyncio\n    async def test_get_species_not_found(self, species_service):\n        \"\"\"Test handling of non-existent species.\"\"\"\n        with pytest.raises(ValueError, match=\"Species .* not found\"):\n            await species_service.get_by_id(\"nonexistent\")\n</code></pre>"},{"location":"developer-guide/contributing/#documentation-standards","title":"Documentation Standards","text":""},{"location":"developer-guide/contributing/#code-documentation","title":"Code Documentation","text":"<ul> <li>Docstrings: All public functions, classes, and modules</li> <li>Type Hints: Use throughout the codebase</li> <li>Comments: Explain complex logic, not obvious code</li> <li>README Updates: Update relevant documentation</li> </ul>"},{"location":"developer-guide/contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>OpenAPI: Ensure FastAPI generates accurate API docs</li> <li>Examples: Include request/response examples</li> <li>Error Codes: Document all possible error responses</li> </ul>"},{"location":"developer-guide/contributing/#user-documentation","title":"User Documentation","text":"<ul> <li>Feature Documentation: Document new user-facing features</li> <li>Screenshots: Include visual guides where helpful</li> <li>Tutorials: Step-by-step guides for complex features</li> </ul>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"developer-guide/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Rebase on Latest Main <pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre></p> </li> <li> <p>Run Full Test Suite <pre><code>pytest --cov=backend --cov=frontend\n</code></pre></p> </li> <li> <p>Check Code Quality <pre><code>black .\nisort .\nmypy backend/ frontend/\nflake8 backend/ frontend/\n</code></pre></p> </li> <li> <p>Update Documentation</p> </li> <li>Update relevant docs</li> <li>Add docstrings for new functions</li> <li>Update API documentation if needed</li> </ol>"},{"location":"developer-guide/contributing/#pull-request-template","title":"Pull Request Template","text":"<pre><code>## Description\nBrief description of changes made.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change that fixes an issue)\n- [ ] New feature (non-breaking change that adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n\n## Testing\n- [ ] Tests pass locally\n- [ ] New tests added for new functionality\n- [ ] Test coverage maintained or improved\n\n## Checklist\n- [ ] Code follows project style guidelines\n- [ ] Self-review completed\n- [ ] Documentation updated\n- [ ] No new warnings introduced\n\n## Related Issues\nCloses #123\nRelated to #456\n</code></pre>"},{"location":"developer-guide/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI/CD pipeline runs tests and quality checks</li> <li>Code Review: Maintainers review code for quality and design</li> <li>Feedback: Address reviewer comments and suggestions</li> <li>Approval: At least one maintainer approval required</li> <li>Merge: Maintainer merges after all checks pass</li> </ol>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":""},{"location":"developer-guide/contributing/#versioning","title":"Versioning","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"developer-guide/contributing/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update version numbers</li> <li>Update CHANGELOG.md</li> <li>Create release notes</li> <li>Tag release</li> <li>Deploy to production</li> </ol>"},{"location":"developer-guide/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"developer-guide/contributing/#communication","title":"Communication","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discussions: General questions and ideas</li> </ul>"},{"location":"developer-guide/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check existing docs first</li> <li>Search Issues: Look for similar problems</li> <li>Ask Questions: Create a discussion for help</li> <li>Be Patient: Maintainers are volunteers</li> </ul>"},{"location":"developer-guide/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - CONTRIBUTORS.md file - Release notes - Project documentation - Annual contributor highlights</p>"},{"location":"developer-guide/contributing/#security","title":"Security","text":""},{"location":"developer-guide/contributing/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, email culicidaelab@gmail.com with: - Description of the vulnerability - Steps to reproduce - Potential impact - Suggested fix (if any)</p>"},{"location":"developer-guide/contributing/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Never commit secrets or API keys</li> <li>Validate all user inputs</li> <li>Use parameterized queries</li> <li>Follow OWASP guidelines</li> <li>Keep dependencies updated</li> </ul>"},{"location":"developer-guide/contributing/#license","title":"License","text":"<p>By contributing to CulicidaeLab Server, you agree that your contributions will be licensed under the AGPL-3.0 License. See LICENSE for details.</p>"},{"location":"developer-guide/contributing/#questions","title":"Questions?","text":"<p>If you have questions about contributing:</p> <ol> <li>Check the FAQ</li> <li>Search existing GitHub Issues</li> <li>Create a new Discussion</li> <li>Contact maintainers via email</li> </ol> <p>Thank you for contributing to CulicidaeLab Server! Your efforts help advance mosquito research and public health initiatives worldwide.</p>"},{"location":"developer-guide/frontend-development/","title":"Frontend Development Guide","text":"<p>This guide covers frontend development for the CulicidaeLab Server using Solara, a pure Python reactive web framework that enables building modern web applications without JavaScript.</p>"},{"location":"developer-guide/frontend-development/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"developer-guide/frontend-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Backend server running (see Backend Development Guide)</li> <li>Modern web browser for testing</li> </ul>"},{"location":"developer-guide/frontend-development/#frontend-setup","title":"Frontend Setup","text":"<ol> <li> <p>Ensure backend is running: <pre><code># In one terminal, start the backend\nuvicorn backend.main:app --port 8000 --host 127.0.0.1 --reload\n</code></pre></p> </li> <li> <p>Start the frontend development server: <pre><code># In another terminal\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nsolara run frontend.main --host 127.0.0.1 --port 8765\n</code></pre></p> </li> </ol> <p>The frontend will be available at http://localhost:8765</p>"},{"location":"developer-guide/frontend-development/#hot-reloading","title":"Hot Reloading","text":"<p>Solara supports hot reloading for rapid development: - Changes to Python files automatically reload the application - State is preserved across reloads when possible - Browser automatically refreshes to show changes</p>"},{"location":"developer-guide/frontend-development/#project-structure","title":"Project Structure","text":"<pre><code>frontend/\n\u251c\u2500\u2500 main.py                 # Application entry point and routing\n\u251c\u2500\u2500 config.py              # Configuration and styling\n\u251c\u2500\u2500 state.py               # Global state management\n\u251c\u2500\u2500 pages/                 # Page components\n\u2502   \u251c\u2500\u2500 home.py            # Landing page\n\u2502   \u251c\u2500\u2500 prediction.py      # Species prediction interface\n\u2502   \u251c\u2500\u2500 map_visualization.py # Interactive map\n\u2502   \u251c\u2500\u2500 species.py         # Species gallery and details\n\u2502   \u251c\u2500\u2500 diseases.py        # Disease information\n\u2502   \u2514\u2500\u2500 about.py           # About page\n\u251c\u2500\u2500 components/            # Reusable UI components\n\u2502   \u251c\u2500\u2500 common/            # Shared components\n\u2502   \u251c\u2500\u2500 prediction/        # Prediction-specific components\n\u2502   \u251c\u2500\u2500 map_module/        # Map components\n\u2502   \u251c\u2500\u2500 species/           # Species-related components\n\u2502   \u2514\u2500\u2500 diseases/          # Disease-related components\n\u251c\u2500\u2500 translations/          # Internationalization files\n\u2502   \u251c\u2500\u2500 home.en.yml        # English translations\n\u2502   \u251c\u2500\u2500 home.ru.yml        # Russian translations\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 assets/                # Static assets\n    \u251c\u2500\u2500 custom.css         # Custom styles\n    \u2514\u2500\u2500 theme.js           # Theme configuration\n</code></pre>"},{"location":"developer-guide/frontend-development/#solara-framework-fundamentals","title":"Solara Framework Fundamentals","text":""},{"location":"developer-guide/frontend-development/#component-architecture","title":"Component Architecture","text":"<p>Solara uses a component-based architecture similar to React:</p> <pre><code>import solara\n\n@solara.component\ndef MyComponent(title: str, items: list[str]):\n    \"\"\"A simple component example.\n\n    Args:\n        title: Component title\n        items: List of items to display\n    \"\"\"\n    with solara.Card(title):\n        for item in items:\n            solara.Text(item)\n\n# Usage\n@solara.component  \ndef Page():\n    MyComponent(\"My List\", [\"Item 1\", \"Item 2\", \"Item 3\"])\n</code></pre>"},{"location":"developer-guide/frontend-development/#reactive-state-management","title":"Reactive State Management","text":"<p>Solara uses reactive variables for state management:</p> <pre><code>import solara\n\n# Global reactive state\ncounter = solara.reactive(0)\nselected_items = solara.reactive([])\n\n@solara.component\ndef Counter():\n    \"\"\"Component with reactive state.\"\"\"\n\n    def increment():\n        counter.value += 1\n\n    def decrement():\n        counter.value -= 1\n\n    with solara.Row():\n        solara.Button(\"\u2212\", on_click=decrement)\n        solara.Text(f\"Count: {counter.value}\")\n        solara.Button(\"+\", on_click=increment)\n</code></pre>"},{"location":"developer-guide/frontend-development/#hooks-and-effects","title":"Hooks and Effects","text":"<p>Use hooks for side effects and lifecycle management:</p> <pre><code>import solara\nimport httpx\n\n@solara.component\ndef DataLoader():\n    \"\"\"Component that loads data on mount.\"\"\"\n    data, set_data = solara.use_state(None)\n    loading, set_loading = solara.use_state(True)\n\n    async def load_data():\n        set_loading(True)\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(\"/api/data\")\n                set_data(response.json())\n        finally:\n            set_loading(False)\n\n    # Load data when component mounts\n    solara.use_effect(load_data, [])\n\n    if loading:\n        solara.SpinnerSolara()\n    elif data:\n        solara.Text(f\"Loaded {len(data)} items\")\n    else:\n        solara.Text(\"No data available\")\n</code></pre>"},{"location":"developer-guide/frontend-development/#application-architecture","title":"Application Architecture","text":""},{"location":"developer-guide/frontend-development/#routing-system","title":"Routing System","text":"<p>The main application defines routes and layout:</p> <pre><code># main.py\nimport solara\nfrom frontend.pages import home, prediction, species\n\n@solara.component\ndef Layout(children):\n    \"\"\"Main application layout.\"\"\"\n    route_current, routes_all = solara.use_route()\n\n    with solara.AppLayout(toolbar_dark=True):\n        with solara.AppBar():\n            with solara.AppBarTitle():\n                solara.Text(\"CulicidaeLab\")\n\n            # Navigation buttons\n            for route in routes_all:\n                with solara.Link(route):\n                    solara.Button(route.label)\n\n        # Page content\n        with solara.Column(children=children):\n            pass\n\n# Route configuration\nroutes = [\n    solara.Route(\"/\", component=home.Home, label=\"Home\", layout=Layout),\n    solara.Route(\"predict\", component=prediction.Page, label=\"Predict\"),\n    solara.Route(\"species\", component=species.Page, label=\"Species\"),\n]\n</code></pre>"},{"location":"developer-guide/frontend-development/#state-management-pattern","title":"State Management Pattern","text":"<p>Global state is managed in <code>state.py</code>:</p> <pre><code># state.py\nimport solara\nfrom typing import Optional\n\n# Application state\ncurrent_user_id = solara.reactive(None)\nselected_species = solara.reactive([])\nmap_center = solara.reactive((40.4168, -3.7038))\nloading_states = {\n    'species': solara.reactive(False),\n    'predictions': solara.reactive(False),\n    'observations': solara.reactive(False)\n}\n\n# API data caches\nspecies_data = solara.reactive([])\nfilter_options = solara.reactive({})\n\nasync def fetch_species_data():\n    \"\"\"Fetch and cache species data.\"\"\"\n    if loading_states['species'].value:\n        return\n\n    loading_states['species'].value = True\n    try:\n        # API call logic\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\"/api/species\")\n            species_data.value = response.json()\n    finally:\n        loading_states['species'].value = False\n</code></pre>"},{"location":"developer-guide/frontend-development/#component-development-patterns","title":"Component Development Patterns","text":""},{"location":"developer-guide/frontend-development/#page-components","title":"Page Components","text":"<p>Page components represent full application views:</p> <pre><code># pages/species.py\nimport solara\nfrom frontend.components.species import SpeciesGallery, SpeciesDetail\nfrom frontend.state import selected_species_item_id\n\n@solara.component\ndef Page():\n    \"\"\"Species page with gallery and detail views.\"\"\"\n    route_current, _ = solara.use_route()\n    species_id = route_current.params.get(\"species_id\")\n\n    if species_id:\n        # Show species detail\n        SpeciesDetail(species_id=species_id)\n    else:\n        # Show species gallery\n        SpeciesGallery()\n</code></pre>"},{"location":"developer-guide/frontend-development/#reusable-components","title":"Reusable Components","text":"<p>Create modular, reusable components:</p> <pre><code># components/common/loading_spinner.py\nimport solara\n\n@solara.component\ndef LoadingSpinner(message: str = \"Loading...\"):\n    \"\"\"Reusable loading spinner component.\"\"\"\n    with solara.Column(align=\"center\"):\n        solara.SpinnerSolara()\n        solara.Text(message, style={\"margin-top\": \"1rem\"})\n\n# components/common/error_message.py\n@solara.component  \ndef ErrorMessage(error: str, retry_callback=None):\n    \"\"\"Reusable error message component.\"\"\"\n    with solara.Card():\n        solara.Error(f\"Error: {error}\")\n        if retry_callback:\n            solara.Button(\"Retry\", on_click=retry_callback)\n</code></pre>"},{"location":"developer-guide/frontend-development/#form-components","title":"Form Components","text":"<p>Handle user input with form components:</p> <pre><code># components/prediction/upload_form.py\nimport solara\nfrom typing import Optional\n\n@solara.component\ndef ImageUploadForm(on_upload_complete=None):\n    \"\"\"Image upload form for species prediction.\"\"\"\n    uploaded_file, set_uploaded_file = solara.use_state(None)\n    uploading, set_uploading = solara.use_state(False)\n\n    def handle_file_upload(file_info):\n        set_uploaded_file(file_info)\n\n    async def submit_prediction():\n        if not uploaded_file:\n            return\n\n        set_uploading(True)\n        try:\n            # Upload and predict\n            async with httpx.AsyncClient() as client:\n                files = {\"file\": uploaded_file[\"file_obj\"]}\n                response = await client.post(\"/api/predict_species/\", files=files)\n                result = response.json()\n\n                if on_upload_complete:\n                    on_upload_complete(result)\n        finally:\n            set_uploading(False)\n\n    with solara.Card(\"Upload Image for Prediction\"):\n        solara.FileDrop(\n            on_file=handle_file_upload,\n            accept=\".jpg,.jpeg,.png\",\n            multiple=False\n        )\n\n        if uploaded_file:\n            solara.Text(f\"Selected: {uploaded_file['name']}\")\n\n        solara.Button(\n            \"Predict Species\",\n            on_click=submit_prediction,\n            disabled=not uploaded_file or uploading\n        )\n\n        if uploading:\n            LoadingSpinner(\"Analyzing image...\")\n</code></pre>"},{"location":"developer-guide/frontend-development/#working-with-maps","title":"Working with Maps","text":""},{"location":"developer-guide/frontend-development/#interactive-maps-with-ipyleaflet","title":"Interactive Maps with ipyleaflet","text":"<p>The application uses ipyleaflet for interactive mapping:</p> <pre><code># components/map_module/observation_map.py\nimport solara\nimport ipyleaflet\nfrom frontend.state import current_map_center, observations_data\n\n@solara.component\ndef ObservationMap():\n    \"\"\"Interactive map showing mosquito observations.\"\"\"\n\n    # Create map widget\n    map_widget = ipyleaflet.Map(\n        center=current_map_center.value,\n        zoom=5,\n        scroll_wheel_zoom=True\n    )\n\n    # Add observation markers\n    def update_markers():\n        # Clear existing markers\n        map_widget.layers = [map_widget.layers[0]]  # Keep base layer\n\n        # Add observation markers\n        for obs in observations_data.value:\n            marker = ipyleaflet.Marker(\n                location=(obs['latitude'], obs['longitude']),\n                popup=ipyleaflet.Popup(\n                    child=solara.HTML(f\"\"\"\n                        &lt;div&gt;\n                            &lt;h4&gt;{obs['species']}&lt;/h4&gt;\n                            &lt;p&gt;Confidence: {obs['confidence']:.2%}&lt;/p&gt;\n                            &lt;p&gt;Date: {obs['date']}&lt;/p&gt;\n                        &lt;/div&gt;\n                    \"\"\")\n                )\n            )\n            map_widget.add_layer(marker)\n\n    # Update markers when data changes\n    solara.use_effect(update_markers, [observations_data.value])\n\n    # Handle map interactions\n    def on_map_click(**kwargs):\n        location = kwargs.get('coordinates')\n        if location:\n            # Handle map click\n            print(f\"Clicked at: {location}\")\n\n    map_widget.on_interaction(on_map_click)\n\n    # Display map\n    solara.display(map_widget)\n</code></pre>"},{"location":"developer-guide/frontend-development/#data-visualization","title":"Data Visualization","text":""},{"location":"developer-guide/frontend-development/#plotly-integration","title":"Plotly Integration","text":"<p>Use Plotly for interactive charts and graphs:</p> <pre><code># components/species/distribution_chart.py\nimport solara\nimport plotly.graph_objects as go\nfrom frontend.state import species_data\n\n@solara.component\ndef SpeciesDistributionChart():\n    \"\"\"Chart showing species distribution by region.\"\"\"\n\n    def create_chart():\n        if not species_data.value:\n            return go.Figure()\n\n        # Process data for chart\n        regions = {}\n        for species in species_data.value:\n            for region in species.get('regions', []):\n                regions[region] = regions.get(region, 0) + 1\n\n        # Create bar chart\n        fig = go.Figure(data=[\n            go.Bar(\n                x=list(regions.keys()),\n                y=list(regions.values()),\n                marker_color='#009688'\n            )\n        ])\n\n        fig.update_layout(\n            title=\"Species Distribution by Region\",\n            xaxis_title=\"Region\",\n            yaxis_title=\"Number of Species\",\n            template=\"plotly_white\"\n        )\n\n        return fig\n\n    chart = create_chart()\n    solara.FigurePlotly(chart)\n</code></pre>"},{"location":"developer-guide/frontend-development/#internationalization-i18n","title":"Internationalization (i18n)","text":""},{"location":"developer-guide/frontend-development/#translation-system","title":"Translation System","text":"<p>The application supports multiple languages:</p> <pre><code># Using translations in components\nimport i18n\n\n@solara.component\ndef WelcomeMessage():\n    \"\"\"Component with internationalized text.\"\"\"\n\n    # Load translations\n    title = i18n.t(\"home.welcome_title\")\n    description = i18n.t(\"home.welcome_description\")\n\n    with solara.Column():\n        solara.Markdown(f\"# {title}\")\n        solara.Text(description)\n\n# Translation files (translations/home.en.yml)\n# home:\n#   welcome_title: \"Welcome to CulicidaeLab\"\n#   welcome_description: \"Mosquito research and analysis platform\"\n\n# Translation files (translations/home.ru.yml)  \n# home:\n#   welcome_title: \"\u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 CulicidaeLab\"\n#   welcome_description: \"\u041f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430 \u0434\u043b\u044f \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0430\u043d\u0430\u043b\u0438\u0437\u0430 \u043a\u043e\u043c\u0430\u0440\u043e\u0432\"\n</code></pre>"},{"location":"developer-guide/frontend-development/#language-switching","title":"Language Switching","text":"<p>Implement language switching:</p> <pre><code># components/common/locale_selector.py\nimport solara\nimport i18n\nfrom frontend.state import current_locale\n\n@solara.component\ndef LocaleSelector():\n    \"\"\"Language selection component.\"\"\"\n\n    languages = [\n        (\"en\", \"English\"),\n        (\"ru\", \"\u0420\u0443\u0441\u0441\u043a\u0438\u0439\")\n    ]\n\n    def change_language(new_locale):\n        current_locale.value = new_locale\n        i18n.set(\"locale\", new_locale)\n\n    with solara.Select(\n        label=\"Language\",\n        value=current_locale.value,\n        values=[lang[0] for lang in languages],\n        on_value=change_language\n    ):\n        for code, name in languages:\n            solara.Option(code, name)\n</code></pre>"},{"location":"developer-guide/frontend-development/#styling-and-theming","title":"Styling and Theming","text":""},{"location":"developer-guide/frontend-development/#material-design-theme","title":"Material Design Theme","text":"<p>The application uses Material Design components:</p> <pre><code># config.py - Theme configuration\nimport solara.lab\n\ndef load_themes(theme):\n    \"\"\"Configure Material Design theme.\"\"\"\n    theme.themes.light.primary = \"#009688\"\n    theme.themes.light.secondary = \"#B2DFDB\"\n    theme.themes.light.accent = \"#00796B\"\n\n    theme.themes.dark.primary = \"#009688\"\n    theme.themes.dark.secondary = \"#B2DFDB\"\n    theme.themes.dark.accent = \"#00796B\"\n\n    return theme\n\n# Apply theme at startup\ntheme = load_themes(solara.lab.theme)\n</code></pre>"},{"location":"developer-guide/frontend-development/#custom-styling","title":"Custom Styling","text":"<p>Add custom CSS for enhanced styling:</p> <pre><code># Using inline styles\n@solara.component\ndef StyledCard():\n    card_style = {\n        \"background\": \"linear-gradient(135deg, #667eea 0%, #764ba2 100%)\",\n        \"color\": \"white\",\n        \"border-radius\": \"12px\",\n        \"padding\": \"2rem\"\n    }\n\n    with solara.Card(style=card_style):\n        solara.Text(\"Styled content\")\n\n# Using CSS classes (assets/custom.css)\n\"\"\"\n.prediction-card {\n    border: 2px solid #009688;\n    border-radius: 8px;\n    transition: transform 0.2s;\n}\n\n.prediction-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n}\n\"\"\"\n\n@solara.component\ndef PredictionCard():\n    with solara.Card(classes=[\"prediction-card\"]):\n        solara.Text(\"Prediction result\")\n</code></pre>"},{"location":"developer-guide/frontend-development/#performance-optimization","title":"Performance Optimization","text":""},{"location":"developer-guide/frontend-development/#efficient-state-updates","title":"Efficient State Updates","text":"<p>Minimize unnecessary re-renders:</p> <pre><code>import solara\n\n# Use local state for UI-only changes\n@solara.component\ndef SearchBox():\n    query, set_query = solara.use_state(\"\")\n\n    # Debounce search to avoid excessive API calls\n    def debounced_search():\n        if len(query) &gt;= 3:\n            # Trigger search after delay\n            pass\n\n    solara.use_effect(debounced_search, [query])\n\n    solara.InputText(\n        label=\"Search species\",\n        value=query,\n        on_value=set_query\n    )\n\n# Memoize expensive computations\n@solara.component\ndef ExpensiveChart(data: list):\n    # Only recalculate when data changes\n    processed_data = solara.use_memo(\n        lambda: process_chart_data(data),\n        [data]\n    )\n\n    chart = create_chart(processed_data)\n    solara.FigurePlotly(chart)\n</code></pre>"},{"location":"developer-guide/frontend-development/#lazy-loading","title":"Lazy Loading","text":"<p>Implement lazy loading for better performance:</p> <pre><code>@solara.component\ndef LazySpeciesGallery():\n    \"\"\"Species gallery with lazy loading.\"\"\"\n    page, set_page = solara.use_state(1)\n    species_list, set_species_list = solara.use_state([])\n\n    async def load_more_species():\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"/api/species?page={page}\")\n            new_species = response.json()\n            set_species_list(species_list + new_species)\n            set_page(page + 1)\n\n    # Initial load\n    solara.use_effect(load_more_species, [])\n\n    # Display species\n    for species in species_list:\n        SpeciesCard(species=species)\n\n    # Load more button\n    solara.Button(\"Load More\", on_click=load_more_species)\n</code></pre>"},{"location":"developer-guide/frontend-development/#testing-frontend-components","title":"Testing Frontend Components","text":""},{"location":"developer-guide/frontend-development/#component-testing","title":"Component Testing","text":"<p>Test components in isolation:</p> <pre><code># tests/test_components.py\nimport pytest\nimport solara\nfrom frontend.components.common.loading_spinner import LoadingSpinner\n\ndef test_loading_spinner():\n    \"\"\"Test loading spinner component.\"\"\"\n\n    @solara.component\n    def TestApp():\n        LoadingSpinner(\"Test message\")\n\n    # Test component renders without errors\n    box, rc = solara.render(TestApp(), handle_error=False)\n\n    # Verify component structure\n    assert \"Test message\" in str(box)\n\ndef test_species_card():\n    \"\"\"Test species card component.\"\"\"\n    test_species = {\n        \"id\": \"aedes_aegypti\",\n        \"scientific_name\": \"Aedes aegypti\",\n        \"common_names\": {\"en\": \"Yellow fever mosquito\"}\n    }\n\n    @solara.component\n    def TestApp():\n        SpeciesCard(species=test_species)\n\n    box, rc = solara.render(TestApp(), handle_error=False)\n    assert \"Aedes aegypti\" in str(box)\n</code></pre>"},{"location":"developer-guide/frontend-development/#integration-testing","title":"Integration Testing","text":"<p>Test component interactions:</p> <pre><code>def test_prediction_workflow():\n    \"\"\"Test complete prediction workflow.\"\"\"\n\n    @solara.component\n    def TestPredictionPage():\n        PredictionPage()\n\n    box, rc = solara.render(TestPredictionPage(), handle_error=False)\n\n    # Simulate file upload\n    # Test prediction results display\n    # Verify state updates\n</code></pre>"},{"location":"developer-guide/frontend-development/#debugging-and-development-tools","title":"Debugging and Development Tools","text":""},{"location":"developer-guide/frontend-development/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode for development:</p> <pre><code># Run with debug mode\nsolara run frontend.main --debug\n\n# Add debug prints in components\n@solara.component\ndef DebugComponent():\n    data, set_data = solara.use_state([])\n\n    # Debug state changes\n    def debug_effect():\n        print(f\"Data updated: {len(data)} items\")\n\n    solara.use_effect(debug_effect, [data])\n</code></pre>"},{"location":"developer-guide/frontend-development/#browser-developer-tools","title":"Browser Developer Tools","text":"<p>Use browser tools for debugging: - React DevTools: Inspect component hierarchy - Network Tab: Monitor API calls - Console: View JavaScript errors and logs - Performance Tab: Profile rendering performance</p> <p>This guide provides the foundation for frontend development with Solara. The framework's Python-first approach makes it accessible to backend developers while providing the power and flexibility needed for modern web applications.</p>"},{"location":"developer-guide/testing/","title":"Testing Guidelines","text":"<p>This document outlines testing strategies, best practices, and guidelines for the CulicidaeLab Server project, covering both backend and frontend testing approaches.</p>"},{"location":"developer-guide/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>The CulicidaeLab Server follows a comprehensive testing strategy that emphasizes:</p> <ul> <li>Test-Driven Development (TDD): Write tests before implementation when possible</li> <li>Pyramid Testing: More unit tests, fewer integration tests, minimal end-to-end tests</li> <li>Fast Feedback: Quick test execution for rapid development cycles</li> <li>Realistic Testing: Use real data and scenarios that mirror production usage</li> <li>Automated Testing: Continuous integration with automated test execution</li> </ul>"},{"location":"developer-guide/testing/#testing-stack","title":"Testing Stack","text":""},{"location":"developer-guide/testing/#backend-testing-tools","title":"Backend Testing Tools","text":"<ul> <li>pytest: Primary testing framework for Python</li> <li>pytest-asyncio: Async test support for FastAPI endpoints</li> <li>httpx: HTTP client for API testing</li> <li>pytest-cov: Code coverage reporting</li> <li>pytest-mock: Mocking and patching utilities</li> </ul>"},{"location":"developer-guide/testing/#frontend-testing-tools","title":"Frontend Testing Tools","text":"<ul> <li>pytest: Component and integration testing</li> <li>Solara testing utilities: Component rendering and interaction testing</li> <li>Selenium (optional): End-to-end browser testing</li> </ul>"},{"location":"developer-guide/testing/#performance-testing","title":"Performance Testing","text":"<ul> <li>pytest-benchmark: Performance benchmarking</li> <li>locust: Load testing for API endpoints</li> <li>psutil: System resource monitoring during tests</li> </ul>"},{"location":"developer-guide/testing/#test-organization","title":"Test Organization","text":""},{"location":"developer-guide/testing/#directory-structure","title":"Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py                 # Shared test configuration\n\u251c\u2500\u2500 backend/                    # Backend tests\n\u2502   \u251c\u2500\u2500 test_api/              # API endpoint tests\n\u2502   \u2502   \u251c\u2500\u2500 test_species.py    # Species API tests\n\u2502   \u2502   \u251c\u2500\u2500 test_diseases.py   # Disease API tests\n\u2502   \u2502   \u251c\u2500\u2500 test_prediction.py # Prediction API tests\n\u2502   \u2502   \u2514\u2500\u2500 test_geo.py        # Geographic API tests\n\u2502   \u251c\u2500\u2500 test_services/         # Service layer tests\n\u2502   \u2502   \u251c\u2500\u2500 test_species_service.py\n\u2502   \u2502   \u251c\u2500\u2500 test_prediction_service.py\n\u2502   \u2502   \u2514\u2500\u2500 test_database.py\n\u2502   \u2514\u2500\u2500 test_utils/            # Utility function tests\n\u251c\u2500\u2500 frontend/                   # Frontend tests\n\u2502   \u251c\u2500\u2500 test_components/       # Component tests\n\u2502   \u251c\u2500\u2500 test_pages/           # Page tests\n\u2502   \u2514\u2500\u2500 test_state/           # State management tests\n\u251c\u2500\u2500 load_tests/                # Performance tests\n\u251c\u2500\u2500 performance_tests/         # Benchmark tests\n\u2514\u2500\u2500 fixtures/                  # Test data and fixtures\n    \u251c\u2500\u2500 sample_images/         # Test images\n    \u251c\u2500\u2500 sample_data.json       # Test datasets\n    \u2514\u2500\u2500 mock_responses/        # API response mocks\n</code></pre>"},{"location":"developer-guide/testing/#backend-testing","title":"Backend Testing","text":""},{"location":"developer-guide/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"developer-guide/testing/#service-layer-testing","title":"Service Layer Testing","text":"<p>Test business logic in isolation:</p> <pre><code># tests/backend/test_services/test_species_service.py\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom backend.services.species_service import SpeciesService\nfrom backend.schemas.species_schemas import SpeciesResponse\n\nclass TestSpeciesService:\n    \"\"\"Test suite for SpeciesService.\"\"\"\n\n    @pytest.fixture\n    def mock_db(self):\n        \"\"\"Mock database connection.\"\"\"\n        return Mock()\n\n    @pytest.fixture\n    def species_service(self, mock_db):\n        \"\"\"Species service with mocked dependencies.\"\"\"\n        with patch('backend.services.species_service.get_db', return_value=mock_db):\n            return SpeciesService()\n\n    @pytest.mark.asyncio\n    async def test_get_species_by_id_success(self, species_service, mock_db):\n        \"\"\"Test successful species retrieval by ID.\"\"\"\n        # Arrange\n        expected_species = {\n            \"id\": \"aedes_aegypti\",\n            \"scientific_name\": \"Aedes aegypti\",\n            \"common_names\": {\"en\": \"Yellow fever mosquito\"}\n        }\n        mock_table = Mock()\n        mock_table.search.return_value.where.return_value.limit.return_value.to_list.return_value = [expected_species]\n        mock_db.open_table.return_value = mock_table\n\n        # Act\n        result = await species_service.get_by_id(\"aedes_aegypti\")\n\n        # Assert\n        assert result is not None\n        assert result.scientific_name == \"Aedes aegypti\"\n        mock_table.search.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_get_species_by_id_not_found(self, species_service, mock_db):\n        \"\"\"Test species not found scenario.\"\"\"\n        # Arrange\n        mock_table = Mock()\n        mock_table.search.return_value.where.return_value.limit.return_value.to_list.return_value = []\n        mock_db.open_table.return_value = mock_table\n\n        # Act &amp; Assert\n        with pytest.raises(ValueError, match=\"Species .* not found\"):\n            await species_service.get_by_id(\"nonexistent_species\")\n\n    @pytest.mark.asyncio\n    async def test_search_species_with_filters(self, species_service, mock_db):\n        \"\"\"Test species search with filters.\"\"\"\n        # Arrange\n        mock_results = [\n            {\"id\": \"aedes_aegypti\", \"scientific_name\": \"Aedes aegypti\"},\n            {\"id\": \"aedes_albopictus\", \"scientific_name\": \"Aedes albopictus\"}\n        ]\n        mock_table = Mock()\n        mock_table.search.return_value.where.return_value.limit.return_value.to_list.return_value = mock_results\n        mock_db.open_table.return_value = mock_table\n\n        # Act\n        results = await species_service.search(region=\"Europe\", limit=10)\n\n        # Assert\n        assert len(results) == 2\n        assert all(isinstance(r, SpeciesResponse) for r in results)\n</code></pre>"},{"location":"developer-guide/testing/#database-testing","title":"Database Testing","text":"<p>Test database operations with real LanceDB:</p> <pre><code># tests/backend/test_services/test_database.py\nimport pytest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nimport pandas as pd\nfrom backend.services.database import get_db, get_table\n\nclass TestDatabase:\n    \"\"\"Test database operations.\"\"\"\n\n    @pytest.fixture\n    def temp_db_path(self):\n        \"\"\"Create temporary database for testing.\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        yield temp_dir\n        shutil.rmtree(temp_dir)\n\n    @pytest.fixture\n    def test_db(self, temp_db_path):\n        \"\"\"Create test database with sample data.\"\"\"\n        import lancedb\n\n        db = lancedb.connect(temp_db_path)\n\n        # Create test species table\n        species_data = pd.DataFrame([\n            {\n                \"id\": \"aedes_aegypti\",\n                \"scientific_name\": \"Aedes aegypti\",\n                \"common_names\": '{\"en\": \"Yellow fever mosquito\"}',\n                \"region\": \"Global\"\n            },\n            {\n                \"id\": \"aedes_albopictus\", \n                \"scientific_name\": \"Aedes albopictus\",\n                \"common_names\": '{\"en\": \"Asian tiger mosquito\"}',\n                \"region\": \"Asia\"\n            }\n        ])\n\n        db.create_table(\"species\", species_data, mode=\"overwrite\")\n        return db\n\n    def test_get_table_success(self, test_db):\n        \"\"\"Test successful table retrieval.\"\"\"\n        table = get_table(test_db, \"species\")\n        assert table is not None\n\n        # Verify table contents\n        results = table.search().to_list()\n        assert len(results) == 2\n\n    def test_get_table_not_found(self, test_db):\n        \"\"\"Test handling of non-existent table.\"\"\"\n        with pytest.raises(ValueError, match=\"Table 'nonexistent' not found\"):\n            get_table(test_db, \"nonexistent\")\n\n    def test_species_search_by_region(self, test_db):\n        \"\"\"Test region-based species search.\"\"\"\n        table = get_table(test_db, \"species\")\n\n        # Search for Asian species\n        results = table.search().where(\"region = 'Asia'\").to_list()\n        assert len(results) == 1\n        assert results[0][\"scientific_name\"] == \"Aedes albopictus\"\n</code></pre>"},{"location":"developer-guide/testing/#api-testing","title":"API Testing","text":""},{"location":"developer-guide/testing/#endpoint-testing","title":"Endpoint Testing","text":"<p>Test FastAPI endpoints with realistic scenarios:</p> <pre><code># tests/backend/test_api/test_species.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\n\nclass TestSpeciesAPI:\n    \"\"\"Test species API endpoints.\"\"\"\n\n    @pytest.fixture\n    def client(self):\n        \"\"\"Test client for API calls.\"\"\"\n        return TestClient(app)\n\n    def test_get_species_list(self, client):\n        \"\"\"Test species list endpoint.\"\"\"\n        response = client.get(\"/api/species\")\n\n        assert response.status_code == 200\n        data = response.json()\n        assert isinstance(data, list)\n\n        # Verify response structure\n        if data:\n            species = data[0]\n            assert \"id\" in species\n            assert \"scientific_name\" in species\n            assert \"common_names\" in species\n\n    def test_get_species_by_id(self, client):\n        \"\"\"Test species detail endpoint.\"\"\"\n        # First get a valid species ID\n        list_response = client.get(\"/api/species\")\n        species_list = list_response.json()\n\n        if species_list:\n            species_id = species_list[0][\"id\"]\n\n            # Test detail endpoint\n            response = client.get(f\"/api/species/{species_id}\")\n            assert response.status_code == 200\n\n            species = response.json()\n            assert species[\"id\"] == species_id\n\n    def test_get_species_not_found(self, client):\n        \"\"\"Test species not found scenario.\"\"\"\n        response = client.get(\"/api/species/nonexistent_species\")\n        assert response.status_code == 404\n\n        error = response.json()\n        assert \"detail\" in error\n\n    def test_species_search_with_filters(self, client):\n        \"\"\"Test species search with query parameters.\"\"\"\n        response = client.get(\"/api/species\", params={\n            \"region\": \"Europe\",\n            \"limit\": 5\n        })\n\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data) &lt;= 5\n\n    def test_species_search_invalid_limit(self, client):\n        \"\"\"Test validation of search parameters.\"\"\"\n        response = client.get(\"/api/species\", params={\"limit\": -1})\n        assert response.status_code == 422  # Validation error\n</code></pre>"},{"location":"developer-guide/testing/#prediction-api-testing","title":"Prediction API Testing","text":"<p>Test AI prediction endpoints with image uploads:</p> <pre><code># tests/backend/test_api/test_prediction.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\nimport io\nfrom PIL import Image\n\nclass TestPredictionAPI:\n    \"\"\"Test prediction API endpoints.\"\"\"\n\n    @pytest.fixture\n    def client(self):\n        return TestClient(app)\n\n    @pytest.fixture\n    def test_image(self):\n        \"\"\"Create a test image for upload.\"\"\"\n        # Create a simple test image\n        img = Image.new('RGB', (224, 224), color='red')\n        img_bytes = io.BytesIO()\n        img.save(img_bytes, format='JPEG')\n        img_bytes.seek(0)\n        return img_bytes\n\n    def test_predict_species_success(self, client, test_image):\n        \"\"\"Test successful species prediction.\"\"\"\n        response = client.post(\n            \"/api/predict_species/\",\n            files={\"file\": (\"test.jpg\", test_image, \"image/jpeg\")}\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n\n        # Verify response structure\n        assert \"species\" in data\n        assert \"confidence\" in data\n        assert \"alternatives\" in data\n        assert isinstance(data[\"confidence\"], float)\n        assert 0 &lt;= data[\"confidence\"] &lt;= 1\n\n    def test_predict_species_invalid_file(self, client):\n        \"\"\"Test prediction with invalid file type.\"\"\"\n        # Create a text file instead of image\n        text_file = io.BytesIO(b\"This is not an image\")\n\n        response = client.post(\n            \"/api/predict_species/\",\n            files={\"file\": (\"test.txt\", text_file, \"text/plain\")}\n        )\n\n        assert response.status_code == 400\n        error = response.json()\n        assert \"Invalid file type\" in error[\"detail\"]\n\n    def test_predict_species_no_file(self, client):\n        \"\"\"Test prediction without file upload.\"\"\"\n        response = client.post(\"/api/predict_species/\")\n        assert response.status_code == 422  # Missing required field\n</code></pre>"},{"location":"developer-guide/testing/#integration-testing","title":"Integration Testing","text":"<p>Test complete workflows across multiple components:</p> <pre><code># tests/backend/test_integration/test_prediction_workflow.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\nclass TestPredictionWorkflow:\n    \"\"\"Test complete prediction workflow.\"\"\"\n\n    @pytest.fixture\n    def client(self):\n        return TestClient(app)\n\n    @pytest.fixture\n    def sample_mosquito_image(self):\n        \"\"\"Load a real mosquito image for testing.\"\"\"\n        # Use a sample image from test fixtures\n        image_path = Path(\"tests/fixtures/sample_images/aedes_aegypti.jpg\")\n        if image_path.exists():\n            return image_path.open(\"rb\")\n        else:\n            pytest.skip(\"Sample image not available\")\n\n    def test_complete_prediction_and_observation_workflow(self, client, sample_mosquito_image):\n        \"\"\"Test prediction followed by observation storage.\"\"\"\n\n        # Step 1: Predict species\n        prediction_response = client.post(\n            \"/api/predict_species/\",\n            files={\"file\": (\"mosquito.jpg\", sample_mosquito_image, \"image/jpeg\")}\n        )\n\n        assert prediction_response.status_code == 200\n        prediction_data = prediction_response.json()\n\n        # Step 2: Store observation based on prediction\n        observation_data = {\n            \"species_id\": prediction_data[\"species\"],\n            \"latitude\": 40.4168,\n            \"longitude\": -3.7038,\n            \"confidence\": prediction_data[\"confidence\"],\n            \"notes\": \"Test observation from integration test\"\n        }\n\n        observation_response = client.post(\"/api/observations/\", json=observation_data)\n        assert observation_response.status_code == 201\n\n        stored_observation = observation_response.json()\n        assert stored_observation[\"species_id\"] == prediction_data[\"species\"]\n\n        # Step 3: Verify observation can be retrieved\n        observation_id = stored_observation[\"id\"]\n        get_response = client.get(f\"/api/observations/{observation_id}\")\n        assert get_response.status_code == 200\n\n        retrieved_observation = get_response.json()\n        assert retrieved_observation[\"id\"] == observation_id\n</code></pre>"},{"location":"developer-guide/testing/#frontend-testing","title":"Frontend Testing","text":""},{"location":"developer-guide/testing/#component-testing","title":"Component Testing","text":"<p>Test Solara components in isolation:</p> <pre><code># tests/frontend/test_components/test_species_card.py\nimport pytest\nimport solara\nfrom frontend.components.species.species_card import SpeciesCard\n\nclass TestSpeciesCard:\n    \"\"\"Test SpeciesCard component.\"\"\"\n\n    @pytest.fixture\n    def sample_species(self):\n        \"\"\"Sample species data for testing.\"\"\"\n        return {\n            \"id\": \"aedes_aegypti\",\n            \"scientific_name\": \"Aedes aegypti\",\n            \"common_names\": {\"en\": \"Yellow fever mosquito\"},\n            \"description\": {\"en\": \"A mosquito species...\"},\n            \"images\": [\"aedes_aegypti_1.jpg\"]\n        }\n\n    def test_species_card_renders(self, sample_species):\n        \"\"\"Test that species card renders without errors.\"\"\"\n\n        @solara.component\n        def TestApp():\n            SpeciesCard(species=sample_species)\n\n        # Render component\n        box, rc = solara.render(TestApp(), handle_error=False)\n\n        # Verify content is present\n        rendered_content = str(box)\n        assert \"Aedes aegypti\" in rendered_content\n        assert \"Yellow fever mosquito\" in rendered_content\n\n    def test_species_card_click_interaction(self, sample_species):\n        \"\"\"Test species card click handling.\"\"\"\n        clicked_species = None\n\n        def on_species_click(species):\n            nonlocal clicked_species\n            clicked_species = species\n\n        @solara.component\n        def TestApp():\n            SpeciesCard(\n                species=sample_species,\n                on_click=on_species_click\n            )\n\n        box, rc = solara.render(TestApp(), handle_error=False)\n\n        # Simulate click (this would require more sophisticated testing setup)\n        # For now, verify the component structure supports interaction\n        assert \"on_click\" in str(box) or \"click\" in str(box).lower()\n</code></pre>"},{"location":"developer-guide/testing/#page-testing","title":"Page Testing","text":"<p>Test complete page components:</p> <pre><code># tests/frontend/test_pages/test_prediction_page.py\nimport pytest\nimport solara\nfrom unittest.mock import patch, AsyncMock\nfrom frontend.pages.prediction import Page as PredictionPage\n\nclass TestPredictionPage:\n    \"\"\"Test prediction page functionality.\"\"\"\n\n    def test_prediction_page_renders(self):\n        \"\"\"Test that prediction page renders without errors.\"\"\"\n\n        @solara.component\n        def TestApp():\n            PredictionPage()\n\n        box, rc = solara.render(TestApp(), handle_error=False)\n\n        # Verify key elements are present\n        rendered_content = str(box)\n        assert \"predict\" in rendered_content.lower() or \"upload\" in rendered_content.lower()\n\n    @patch('frontend.state.fetch_api_data')\n    def test_prediction_page_with_mock_api(self, mock_fetch):\n        \"\"\"Test prediction page with mocked API calls.\"\"\"\n        # Mock API response\n        mock_fetch.return_value = AsyncMock(return_value={\n            \"species\": \"Aedes aegypti\",\n            \"confidence\": 0.95,\n            \"alternatives\": []\n        })\n\n        @solara.component\n        def TestApp():\n            PredictionPage()\n\n        box, rc = solara.render(TestApp(), handle_error=False)\n\n        # Verify component handles API integration\n        assert mock_fetch.called or True  # Basic structure test\n</code></pre>"},{"location":"developer-guide/testing/#state-management-testing","title":"State Management Testing","text":"<p>Test reactive state behavior:</p> <pre><code># tests/frontend/test_state/test_species_state.py\nimport pytest\nimport solara\nfrom frontend.state import selected_species_reactive, species_data_reactive\n\nclass TestSpeciesState:\n    \"\"\"Test species-related state management.\"\"\"\n\n    def test_selected_species_reactive(self):\n        \"\"\"Test species selection state.\"\"\"\n        # Initial state\n        assert selected_species_reactive.value == [\"Aedes albopictus\", \"Anopheles gambiae\"]\n\n        # Update state\n        new_selection = [\"Aedes aegypti\", \"Culex pipiens\"]\n        selected_species_reactive.value = new_selection\n\n        assert selected_species_reactive.value == new_selection\n\n    def test_species_data_caching(self):\n        \"\"\"Test species data caching behavior.\"\"\"\n        # Initial empty state\n        species_data_reactive.value = []\n        assert len(species_data_reactive.value) == 0\n\n        # Add species data\n        test_species = [\n            {\"id\": \"aedes_aegypti\", \"scientific_name\": \"Aedes aegypti\"},\n            {\"id\": \"culex_pipiens\", \"scientific_name\": \"Culex pipiens\"}\n        ]\n        species_data_reactive.value = test_species\n\n        assert len(species_data_reactive.value) == 2\n        assert species_data_reactive.value[0][\"id\"] == \"aedes_aegypti\"\n</code></pre>"},{"location":"developer-guide/testing/#performance-testing_1","title":"Performance Testing","text":""},{"location":"developer-guide/testing/#backend-performance-tests","title":"Backend Performance Tests","text":"<p>Test API performance and resource usage:</p> <pre><code># tests/performance_tests/test_api_performance.py\nimport pytest\nimport time\nimport asyncio\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\n\nclass TestAPIPerformance:\n    \"\"\"Test API performance characteristics.\"\"\"\n\n    @pytest.fixture\n    def client(self):\n        return TestClient(app)\n\n    def test_species_list_performance(self, client):\n        \"\"\"Test species list endpoint performance.\"\"\"\n        start_time = time.time()\n\n        response = client.get(\"/api/species?limit=100\")\n\n        end_time = time.time()\n        response_time = end_time - start_time\n\n        assert response.status_code == 200\n        assert response_time &lt; 2.0  # Should respond within 2 seconds\n\n    def test_prediction_performance(self, client):\n        \"\"\"Test prediction endpoint performance.\"\"\"\n        # Create test image\n        import io\n        from PIL import Image\n\n        img = Image.new('RGB', (224, 224), color='red')\n        img_bytes = io.BytesIO()\n        img.save(img_bytes, format='JPEG')\n        img_bytes.seek(0)\n\n        start_time = time.time()\n\n        response = client.post(\n            \"/api/predict_species/\",\n            files={\"file\": (\"test.jpg\", img_bytes, \"image/jpeg\")}\n        )\n\n        end_time = time.time()\n        response_time = end_time - start_time\n\n        assert response.status_code == 200\n        assert response_time &lt; 10.0  # Prediction should complete within 10 seconds\n\n    @pytest.mark.benchmark\n    def test_database_query_performance(self, benchmark):\n        \"\"\"Benchmark database query performance.\"\"\"\n        from backend.services.database import get_db, get_table\n\n        def query_species():\n            db = get_db()\n            table = get_table(db, \"species\")\n            return table.search().limit(50).to_list()\n\n        result = benchmark(query_species)\n        assert len(result) &lt;= 50\n</code></pre>"},{"location":"developer-guide/testing/#load-testing","title":"Load Testing","text":"<p>Use locust for load testing:</p> <pre><code># tests/load_tests/locustfile.py\nfrom locust import HttpUser, task, between\n\nclass CulicidaeLabUser(HttpUser):\n    \"\"\"Simulated user for load testing.\"\"\"\n\n    wait_time = between(1, 3)  # Wait 1-3 seconds between requests\n\n    def on_start(self):\n        \"\"\"Called when user starts.\"\"\"\n        pass\n\n    @task(3)\n    def view_species_list(self):\n        \"\"\"Most common task - viewing species list.\"\"\"\n        self.client.get(\"/api/species?limit=20\")\n\n    @task(2)\n    def view_species_detail(self):\n        \"\"\"View individual species details.\"\"\"\n        # Get species list first\n        response = self.client.get(\"/api/species?limit=5\")\n        if response.status_code == 200:\n            species_list = response.json()\n            if species_list:\n                species_id = species_list[0][\"id\"]\n                self.client.get(f\"/api/species/{species_id}\")\n\n    @task(1)\n    def search_species(self):\n        \"\"\"Search species with filters.\"\"\"\n        self.client.get(\"/api/species\", params={\n            \"region\": \"Europe\",\n            \"limit\": 10\n        })\n\n    @task(1)\n    def get_filter_options(self):\n        \"\"\"Get filter options for UI.\"\"\"\n        self.client.get(\"/api/filter_options\")\n\n# Run with: locust -f tests/load_tests/locustfile.py --host=http://localhost:8000\n</code></pre>"},{"location":"developer-guide/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"developer-guide/testing/#fixtures-and-test-data","title":"Fixtures and Test Data","text":"<p>Organize test data effectively:</p> <pre><code># tests/conftest.py\nimport pytest\nimport json\nfrom pathlib import Path\n\n@pytest.fixture(scope=\"session\")\ndef test_data_dir():\n    \"\"\"Path to test data directory.\"\"\"\n    return Path(__file__).parent / \"fixtures\"\n\n@pytest.fixture(scope=\"session\")\ndef sample_species_data(test_data_dir):\n    \"\"\"Load sample species data.\"\"\"\n    data_file = test_data_dir / \"sample_data.json\"\n    if data_file.exists():\n        with open(data_file) as f:\n            return json.load(f)[\"species\"]\n    return []\n\n@pytest.fixture(scope=\"session\")\ndef sample_images_dir(test_data_dir):\n    \"\"\"Path to sample images directory.\"\"\"\n    return test_data_dir / \"sample_images\"\n\n@pytest.fixture\ndef mock_prediction_response():\n    \"\"\"Mock prediction API response.\"\"\"\n    return {\n        \"species\": \"Aedes aegypti\",\n        \"confidence\": 0.95,\n        \"alternatives\": [\n            {\"species\": \"Aedes albopictus\", \"confidence\": 0.03},\n            {\"species\": \"Culex pipiens\", \"confidence\": 0.02}\n        ]\n    }\n</code></pre>"},{"location":"developer-guide/testing/#database-test-setup","title":"Database Test Setup","text":"<p>Set up test databases:</p> <pre><code># tests/conftest.py (continued)\nimport tempfile\nimport shutil\nimport pandas as pd\nimport lancedb\n\n@pytest.fixture(scope=\"function\")\ndef test_database():\n    \"\"\"Create temporary test database.\"\"\"\n    temp_dir = tempfile.mkdtemp()\n\n    try:\n        db = lancedb.connect(temp_dir)\n\n        # Create test tables with sample data\n        species_df = pd.DataFrame([\n            {\n                \"id\": \"aedes_aegypti\",\n                \"scientific_name\": \"Aedes aegypti\",\n                \"common_names\": '{\"en\": \"Yellow fever mosquito\"}',\n                \"region\": \"Global\"\n            }\n        ])\n\n        db.create_table(\"species\", species_df, mode=\"overwrite\")\n\n        yield db\n\n    finally:\n        shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"developer-guide/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"developer-guide/testing/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code># .github/workflows/test.yml\nname: Tests\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.11, 3.12]\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -e .\n        pip install pytest pytest-cov pytest-asyncio\n\n    - name: Run tests\n      run: |\n        pytest tests/ -v --cov=backend --cov=frontend --cov-report=xml\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"developer-guide/testing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: pytest-check\n        name: pytest-check\n        entry: pytest\n        language: system\n        pass_filenames: false\n        always_run: true\n        args: [tests/backend/test_services/, -v, --tb=short]\n</code></pre>"},{"location":"developer-guide/testing/#test-coverage-and-quality","title":"Test Coverage and Quality","text":""},{"location":"developer-guide/testing/#coverage-requirements","title":"Coverage Requirements","text":"<p>Maintain high test coverage:</p> <pre><code># pytest.ini\n[tool:pytest]\naddopts = \n    --cov=backend\n    --cov=frontend\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=80\n    -v\n\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\n</code></pre>"},{"location":"developer-guide/testing/#quality-metrics","title":"Quality Metrics","text":"<p>Monitor test quality:</p> <ul> <li>Coverage: Aim for &gt;80% code coverage</li> <li>Performance: API responses &lt;2s, predictions &lt;10s</li> <li>Reliability: Tests should pass consistently</li> <li>Maintainability: Clear test names and documentation</li> </ul>"},{"location":"developer-guide/testing/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Write Clear Test Names: Test names should describe what is being tested</li> <li>Use Fixtures: Reuse test setup code with pytest fixtures</li> <li>Mock External Dependencies: Isolate units under test</li> <li>Test Edge Cases: Include error conditions and boundary values</li> <li>Keep Tests Fast: Unit tests should run in milliseconds</li> <li>Test Behavior, Not Implementation: Focus on what the code does, not how</li> <li>Use Real Data: Test with realistic data when possible</li> <li>Automate Everything: Run tests automatically on every change</li> <li>Monitor Performance: Track test execution time and system performance</li> <li>Document Test Requirements: Clear setup instructions for new developers</li> </ol> <p>This testing strategy ensures the CulicidaeLab Server maintains high quality, reliability, and performance as it evolves.</p>"},{"location":"developer-guide/api-reference/","title":"API Reference","text":"<p>Comprehensive API documentation for CulicidaeLab Server backend services.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#overview","title":"Overview","text":"<p>The CulicidaeLab Server provides a RESTful API built with FastAPI for mosquito research, surveillance, and data analysis. The API offers endpoints for species identification, disease tracking, geographic data management, and observation recording.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#base-url","title":"Base URL","text":"<pre><code>http://localhost:8000/api/v1\n</code></pre>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#authentication","title":"Authentication","text":"<p>Currently, the API does not require authentication for most endpoints. Future versions may implement API key or OAuth2 authentication.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#response-format","title":"Response Format","text":"<p>All API responses follow a consistent JSON format with appropriate HTTP status codes:</p> <ul> <li><code>200 OK</code>: Successful request</li> <li><code>404 Not Found</code>: Resource not found</li> <li><code>422 Unprocessable Entity</code>: Validation error</li> <li><code>500 Internal Server Error</code>: Server error</li> </ul>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#interactive-api-documentation","title":"Interactive API Documentation","text":"<p>For interactive API exploration, visit the automatically generated documentation:</p> <ul> <li>Swagger UI: http://localhost:8000/docs</li> <li>ReDoc: http://localhost:8000/redoc</li> </ul>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#api-modules","title":"API Modules","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#core-application","title":"Core Application","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main","title":"<code>backend.main</code>","text":"<p>Main application module for CulicidaeLab API backend.</p> <p>This module initializes and configures the FastAPI application, including: - Application startup and shutdown lifecycle management - CORS middleware configuration - Static file serving setup - API router registration - Health check and root endpoints</p> <p>The application serves as the main entry point for the CulicidaeLab API server, providing endpoints for species identification, disease tracking, geographic data, and observation management.</p> Example <p>python -m backend.main</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main--starts-the-server-on-httplocalhost8000","title":"Starts the server on http://localhost:8000","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main--or-run-with-custom-hostport","title":"Or run with custom host/port","text":"<p>uvicorn backend.main:app --host 0.0.0.0 --port 8000 --reload</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.api_router_prefix","title":"<code>api_router_prefix = ''</code>  <code>module-attribute</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.backend_dir","title":"<code>backend_dir = 'C:\\\\Users\\\\lenova\\\\culicidaelab-server\\\\backend'</code>  <code>module-attribute</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.settings","title":"<code>settings = AppSettings(APP_NAME='CulicidaeLab API', API_V1_STR='/api', DATABASE_PATH='backend/data/.lancedb', SAVE_PREDICTED_IMAGES='1', BACKEND_CORS_ORIGINS=['http://localhost:8765', 'http://127.0.0.1:8765'])</code>  <code>module-attribute</code>","text":"<p>Application settings configuration for CulicidaeLab API backend.</p> <p>This class defines all configuration parameters for the CulicidaeLab API server, using Pydantic BaseSettings for environment variable support and validation. Settings can be overridden via environment variables with the CULICIDAELAB_ prefix.</p> <p>Attributes:</p> Name Type Description <code>APP_NAME</code> <code>str</code> <p>Name of the application displayed in API documentation.</p> <code>API_V1_STR</code> <code>str</code> <p>Base path prefix for API version 1 endpoints.</p> <code>DATABASE_PATH</code> <code>str</code> <p>File system path to the LanceDB database directory.</p> <code>SAVE_PREDICTED_IMAGES</code> <code>str | bool</code> <p>Whether to save predicted images to disk.</p> <code>BACKEND_CORS_ORIGINS</code> <code>list[str]</code> <p>List of allowed CORS origins for frontend access.</p> Example <p>settings = AppSettings() print(f\"App name: {settings.APP_NAME}\") App name: CulicidaeLab API print(f\"Database path: {settings.DATABASE_PATH}\") Database path: .lancedb</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.static_dir","title":"<code>static_dir = 'C:\\\\Users\\\\lenova\\\\culicidaelab-server\\\\backend\\\\static'</code>  <code>module-attribute</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.lifespan","title":"<code>lifespan(app: FastAPI)</code>","text":"<p>Manages application startup and shutdown lifecycle.</p> <p>This context manager handles the initialization of database connections, cache loading, and other startup tasks when the FastAPI application starts, and cleanup when it shuts down.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI application instance.</p> required <p>Yields:</p> Name Type Description <code>None</code> <p>Control is yielded back to FastAPI after startup initialization.</p> Example <p>@asynccontextmanager async def lifespan(app: FastAPI):     # Initialize resources     db = await init_database()     app.state.db = db     yield     # Cleanup resources     await db.close()</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.read_root","title":"<code>read_root()</code>  <code>async</code>","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.health_check","title":"<code>health_check()</code>  <code>async</code>","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.get_db","title":"<code>get_db()</code>","text":"<p>Establish a connection to the LanceDB database.</p> <p>This function creates a cached connection to the LanceDB database using the path specified in the application settings. The connection is cached to avoid repeated connection overhead.</p> <p>Returns:</p> Type Description <p>lancedb.DBConnection: A connection object to the LanceDB database.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the database connection fails, the original exception is re-raised after logging the error.</p> Example <p>db_connection = get_db() print(f\"Connected to: {db_connection}\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.load_all_datasource_translations","title":"<code>load_all_datasource_translations(db: object, supported_langs: list[str]) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Load all data source translations from the database for multiple languages.</p> <p>This function queries the data_sources table and extracts translations for all supported languages, using English as a fallback for missing translations. Returns an empty dictionary if the query fails.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>object</code> <p>The database connection object.</p> required <code>supported_langs</code> <code>list[str]</code> <p>A list of language codes to load (e.g., ['en', 'ru', 'es']).</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: A nested dictionary structured as {language_code: {source_id: translated_name}}. Returns an empty dictionary if the query fails. Missing translations fall back to English or the source ID itself.</p> Example <p>db = get_db() translations = load_all_datasource_translations(db, [\"en\", \"ru\"]) print(translations[\"en\"][\"gbif\"])  # \"GBIF\" print(translations[\"ru\"][\"gbif\"])  # \"GBIF\"</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.load_all_region_translations","title":"<code>load_all_region_translations(db: object, supported_langs: list[str]) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Load all region translations from the database for multiple languages.</p> <p>This function queries the regions table and extracts translations for all supported languages, using English as a fallback for missing translations. The data is loaded once at application startup for performance.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>object</code> <p>The database connection object.</p> required <code>supported_langs</code> <code>list[str]</code> <p>A list of language codes to load (e.g., ['en', 'ru', 'es']).</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: A nested dictionary structured as {language_code: {region_id: translated_name}}. Missing translations fall back to English or the region ID itself.</p> Example <p>db = get_db() translations = load_all_region_translations(db, [\"en\", \"ru\"]) print(translations[\"en\"][\"us\"])  # \"United States\" print(translations[\"ru\"][\"us\"])  # \"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u043d\u044b\u0435 \u0428\u0442\u0430\u0442\u044b\"</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.main.load_all_species_names","title":"<code>load_all_species_names(db: object) -&gt; list[str]</code>","text":"<p>Load a sorted list of all unique species scientific names from the database.</p> <p>This function queries the species table and extracts all unique scientific names, returning them as a sorted list. Returns an empty list if the query fails.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>object</code> <p>The database connection object.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A sorted list of unique species scientific names. Returns an empty list if the query fails or no species are found.</p> Example <p>db = get_db() species_names = load_all_species_names(db) print(len(species_names))  # Number of species print(species_names[:3])  # First 3 species names</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#species-management","title":"Species Management","text":"<p>The Species API provides endpoints for retrieving mosquito species information, including detailed species data and disease vector information.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species","title":"<code>backend.routers.species</code>","text":"<p>Species router module for the Culicidae Lab Server.</p> <p>This module provides FastAPI route handlers for mosquito species-related operations in the Culicidae Lab application. It handles retrieval of species information, including species lists, detailed species information, and disease vector species.</p> <p>The router integrates with the species service layer to perform database queries and return properly formatted responses according to the defined Pydantic schemas.</p> Routes <ul> <li>GET /species: Retrieve a paginated list of mosquito species with optional search</li> <li>GET /species/{species_id}: Retrieve detailed information for a specific species</li> <li>GET /vector-species: Retrieve species that are known disease vectors</li> </ul> Example <p>The router is typically mounted in the main FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom backend.routers.species import router as species_router\n\napp = FastAPI()\napp.include_router(species_router, prefix=\"/api/v1\")\n</code></pre>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesBase","title":"<code>SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesDetail","title":"<code>SpeciesDetail</code>","text":"<p>Detailed species model with extended information.</p> <p>Extends the base species model with additional descriptive fields for comprehensive species information.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesDetail.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesListResponse","title":"<code>SpeciesListResponse</code>","text":"<p>Response model for paginated species lists.</p> <p>Contains the total count and list of species for API responses.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.SpeciesListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.get_species_list_endpoint","title":"<code>get_species_list_endpoint(request: Request, db: DBConnection = Depends(get_db), search: str | None = Query(None), limit: int = Query(50), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve a list of mosquito species, optionally filtered by a search term.</p> <p>This endpoint allows clients to fetch a paginated list of mosquito species from the database. The search functionality supports partial matching against scientific names and common names in English and Russian.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>search</code> <code>str | None</code> <p>Optional search term to filter species by name. Supports partial matching against scientific names and common names in multiple languages.</p> <code>Query(None)</code> <code>limit</code> <code>int</code> <p>Maximum number of species to return (1-200). Defaults to 50.</p> <code>Query(50)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>SpeciesListResponse</code> <p>A response containing the count of species and the list of species matching the criteria.</p> Example <p>Get the first 25 mosquito species in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/species\",\n        params={\"limit\": 25, \"lang\": \"en\"}\n    )\n    species_data = response.json()\n    print(f\"Found {species_data['count']} species\")\n</code></pre> <p>Search for species containing \"aedes\":</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species\",\n    params={\"search\": \"aedes\", \"limit\": 10, \"lang\": \"en\"}\n)\n</code></pre>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.get_species_detail_endpoint","title":"<code>get_species_detail_endpoint(species_id: str, request: Request, region_cache: dict[str, dict[str, str]] = Depends(get_region_cache), db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve detailed information for a specific mosquito species by ID.</p> <p>This endpoint fetches comprehensive information about a single mosquito species including its scientific name, common names in multiple languages, vector status, habitat preferences, geographic regions, and associated diseases. The response includes translated content based on the requested language.</p> <p>Parameters:</p> Name Type Description Default <code>species_id</code> <code>str</code> <p>The unique identifier for the species (e.g., 'aedes-aegypti').</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>region_cache</code> <code>dict[str, dict[str, str]]</code> <p>Pre-loaded cache of region translations for localization.</p> <code>Depends(get_region_cache)</code> <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>SpeciesDetail</code> <p>Detailed information about the requested species including scientific name, common names, descriptions, characteristics, habitat preferences, geographic regions, and related diseases.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the species with the given ID is not found, returns a 404 status code with detail message \"Species not found\".</p> Example <p>Get detailed information for Aedes aegypti in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/species/aedes-aegypti\",\n        params={\"lang\": \"en\"}\n    )\n    if response.status_code == 200:\n        species = response.json()\n        print(f\"Species: {species['scientific_name']}\")\n        print(f\"Common name: {species['common_name']}\")\n        print(f\"Vector status: {species['vector_status']}\")\n    else:\n        print(\"Species not found\")\n</code></pre> <p>Get species information in Spanish:</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species/anopheles-gambiae\",\n    params={\"lang\": \"es\"}\n)\n</code></pre>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.get_vector_species_endpoint","title":"<code>get_vector_species_endpoint(request: Request, db: DBConnection = Depends(get_db), disease_id: str | None = Query(None), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve mosquito species that are disease vectors, optionally filtered by disease.</p> <p>This endpoint returns a list of mosquito species known to be vectors for various diseases. When a specific disease ID is provided, only species that are vectors for that particular disease are returned. Without a disease filter, all species marked as vectors (excluding 'None' and 'Unknown' status) are returned.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>disease_id</code> <code>str | None</code> <p>Optional specific disease ID to filter vectors. If provided, only species that are vectors for this disease will be returned.</p> <code>Query(None)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Type Description <p>list[SpeciesBase]: A list of mosquito species that are disease vectors, filtered by the specified criteria.</p> Example <p>Get all mosquito species that are disease vectors in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/vector-species\",\n        params={\"lang\": \"en\"}\n    )\n    vector_species = response.json()\n    print(f\"Found {len(vector_species)} vector species\")\n    for species in vector_species:\n        print(f\"- {species['scientific_name']}: {species['vector_status']}\")\n</code></pre> <p>Get only species that are vectors for malaria:</p> <pre><code># First, you'd need to know the disease ID for malaria\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/vector-species\",\n    params={\"disease_id\": \"malaria\", \"lang\": \"en\"}\n)\nmalaria_vectors = response.json()\n</code></pre> <p>Get vector species in Russian:</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/vector-species\",\n    params={\"lang\": \"ru\"}\n)\n</code></pre>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.species.get_region_cache","title":"<code>get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the regions translation cache.</p> <p>Provides access to the cached region translations data, which maps region codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to region translation dictionaries.</p> Example <p>@app.get(\"/regions/{language}\") async def get_regions_by_language(     regions: dict = Depends(get_region_cache),     language: str = \"en\" ):     return regions.get(language, {})</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#disease-information","title":"Disease Information","text":"<p>The Diseases API manages disease-related data and provides endpoints for retrieving information about mosquito-borne diseases.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases","title":"<code>backend.routers.diseases</code>","text":"<p>Disease-related API endpoints for the CulicidaeLab server.</p> <p>This module provides FastAPI router endpoints for retrieving information about vector-borne diseases and their associated arthropod vectors. The endpoints support multiple languages and provide both list and detail views of diseases.</p> <p>The module includes the following endpoints: - GET /diseases: Retrieve a paginated list of diseases with optional search filtering - GET /diseases/{disease_id}: Retrieve detailed information for a specific disease - GET /diseases/{disease_id}/vectors: Retrieve vector species associated with a disease</p> <p>All endpoints support internationalization and return data in the requested language.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.Disease","title":"<code>Disease</code>","text":"<p>Complete disease model with unique identifier.</p> <p>Used for responses that include the database ID of the disease.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.Disease.model_config","title":"<code>model_config = {'from_attributes': True}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.Disease.Config","title":"<code>Config</code>","text":"<code>from_attributes = True</code> <code>class-attribute</code> \u00b6 <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.DiseaseListResponse","title":"<code>DiseaseListResponse</code>","text":"<p>Response model for paginated disease lists.</p> <p>Contains the total count and list of diseases for API responses.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.DiseaseListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.SpeciesBase","title":"<code>SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.get_disease_list_endpoint","title":"<code>get_disease_list_endpoint(request: Request, db: DBConnection = Depends(get_db), search: str | None = Query(None), limit: int = Query(50), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve a list of vector-borne diseases, optionally filtered by a search term.</p> <p>This endpoint provides a paginated list of diseases that can be filtered by name or description. Results are localized based on the requested language and support various query parameters for flexible disease discovery and analysis.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information and headers.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying disease data from the LanceDB vector database.</p> <code>Depends(get_db)</code> <code>search</code> <code>str | None</code> <p>Optional search term to filter diseases by name or description. Performs case-insensitive substring matching. If None, returns all diseases. Examples: \"malaria\", \"fever\", \"mosquito\".</p> <code>Query(None)</code> <code>limit</code> <code>int</code> <p>Maximum number of diseases to return per page (1-200). Defaults to 50. Use this parameter for pagination control when dealing with large result sets.</p> <code>Query(50)</code> <code>lang</code> <code>str</code> <p>Language code for response localization and internationalization. Supported languages: 'en' (English), 'es' (Spanish), 'fr' (French), 'pt' (Portuguese). Defaults to 'en' for English responses.</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>DiseaseListResponse</code> <p>A structured response containing: - count (int): Total number of diseases matching the search criteria - diseases (list[Disease]): List of disease objects with basic information</p> Example <p>Basic disease list retrieval: GET /diseases?limit=10&amp;lang=en</p> <p>Search for specific diseases: GET /diseases?search=malaria&amp;limit=5&amp;lang=en</p> <p>Multilingual support: GET /diseases?search=fiebre&amp;lang=en</p> <p>Response format: {     \"count\": 2,     \"diseases\": [         {             \"id\": \"malaria\",             \"name\": \"Malaria\",             \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",             \"vectors\": [\"Anopheles mosquito\"]         },         {             \"id\": \"dengue\",             \"name\": \"Dengue Fever\",             \"description\": \"A mosquito-borne viral infection causing flu-like illness...\",             \"vectors\": [\"Aedes aegypti\", \"Aedes albopictus\"]         }     ] }</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.get_disease_detail_endpoint","title":"<code>get_disease_detail_endpoint(disease_id: str, request: Request, db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve detailed information for a specific disease by ID.</p> <p>This endpoint provides comprehensive information about a specific vector-borne disease, including its description, associated vectors, symptoms, and other relevant details. Results are localized based on the requested language.</p> <p>Parameters:</p> Name Type Description Default <code>disease_id</code> <code>str</code> <p>Unique identifier for the disease (e.g., 'malaria', 'dengue'). This is typically the disease name in lowercase with hyphens.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying disease data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'fr'). Defaults to 'en' for English.</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>Disease</code> <p>A detailed disease object containing all available information about the specified disease, or None if the disease is not found.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the disease with the specified ID is not found (404 status code).</p> Example <p>GET /diseases/malaria?lang=en Response: {     \"id\": \"malaria\",     \"name\": \"Malaria\",     \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",     \"symptoms\": [\"Fever\", \"Chills\", \"Headache\"],     \"vectors\": [\"Anopheles gambiae\", \"Anopheles funestus\"],     \"regions\": [\"Sub-Saharan Africa\", \"Southeast Asia\"],     \"transmission\": \"Bite of infected female Anopheles mosquitoes\" }</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.diseases.get_disease_vectors_endpoint","title":"<code>get_disease_vectors_endpoint(disease_id: str, request: Request, db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve vector species associated with a specific disease.</p> <p>This endpoint returns a list of arthropod vectors (primarily mosquitoes, ticks, and flies) that are known to transmit the specified disease. This information is crucial for understanding disease transmission patterns and vector control strategies.</p> <p>Parameters:</p> Name Type Description Default <code>disease_id</code> <code>str</code> <p>Unique identifier for the disease (e.g., 'malaria', 'lyme-disease'). This is typically the disease name in lowercase with hyphens.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying species data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'fr'). Defaults to 'en' for English.</p> <code>Query(en)</code> <p>Returns:</p> Type Description <p>list[SpeciesBase]: A list of species objects that serve as vectors for the specified disease. Each species includes taxonomic information and habitat details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the disease with the specified ID is not found (404 status code).</p> Example <p>GET /diseases/malaria/vectors?lang=en Response: [     {         \"id\": \"anopheles-gambiae\",         \"scientific_name\": \"Anopheles gambiae\",         \"common_name\": \"African malaria mosquito\",         \"genus\": \"Anopheles\",         \"family\": \"Culicidae\",         \"habitat\": \"Tropical and subtropical regions\",         \"distribution\": \"Sub-Saharan Africa\"     },     {         \"id\": \"anopheles-funestus\",         \"scientific_name\": \"Anopheles funestus\",         \"common_name\": \"Common malaria mosquito\",         \"genus\": \"Anopheles\",         \"family\": \"Culicidae\",         \"habitat\": \"Rural and peri-urban areas\",         \"distribution\": \"Africa south of the Sahara\"     } ]</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#geographic-data","title":"Geographic Data","text":"<p>The Geographic API handles location-based data and provides endpoints for retrieving geographic information and regional data.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.geo","title":"<code>backend.routers.geo</code>","text":"<p>Geographic API endpoints for the CulicidaeLab server.</p> <p>This module provides FastAPI router endpoints for retrieving geographic data and spatial information related to arthropod vectors and vector-borne diseases. The endpoints support various layer types and filtering options for spatial analysis and mapping applications.</p> <p>The module includes the following endpoints: - GET /geo/{layer_type}: Retrieve geographic features for a specific layer type   with optional spatial, temporal, and species-based filtering</p> <p>All endpoints return GeoJSON-compliant data structures suitable for mapping applications and geographic information systems (GIS). The endpoints support bounding box filtering, date range filtering, and species-specific queries.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.geo.VALID_LAYER_TYPES","title":"<code>VALID_LAYER_TYPES = ['distribution', 'observations', 'modeled', 'breeding_sites']</code>  <code>module-attribute</code>","text":"<p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.geo.GeoJSONFeatureCollection","title":"<code>GeoJSONFeatureCollection</code>","text":"<p>GeoJSON FeatureCollection model.</p> <p>Represents a collection of GeoJSON Features for batch operations and API responses containing multiple geographic features.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.geo.GeoJSONFeatureCollection.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.geo.get_geographic_layer","title":"<code>get_geographic_layer(layer_type: str = Path(PydanticUndefined), db: DBConnection = Depends(get_db), species: str | None = Query(None), bbox: str | None = Query(None), start_date: str | None = Query(None), end_date: str | None = Query(None))</code>  <code>async</code>","text":"<p>Retrieve geographic features for a specific layer type with optional filtering.</p> <p>This endpoint provides access to various geographic data layers related to arthropod vectors and vector-borne diseases. Currently supports observation data with spatial, temporal, and species-based filtering capabilities.</p> <p>The endpoint returns GeoJSON FeatureCollection data that can be directly consumed by mapping libraries and GIS applications for visualization and spatial analysis.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The type of geographic layer to retrieve. Must be one of: 'distribution', 'observations', 'modeled', 'breeding_sites'.</p> <code>Path(PydanticUndefined)</code> <code>db</code> <code>DBConnection</code> <p>Database connection for querying geographic data.</p> <code>Depends(get_db)</code> <code>species</code> <code>str | None</code> <p>Comma-separated list of species scientific names to filter by. If provided, only features for the specified species will be returned. Example: \"Aedes aegypti,Anopheles gambiae,Culex quinquefasciatus\".</p> <code>Query(None)</code> <code>bbox</code> <code>str | None</code> <p>Bounding box filter in the format \"min_lon,min_lat,max_lon,max_lat\". Filters features to only include those within the specified geographic bounds. Example: \"-122.4194,37.7749,-122.0808,37.9128\" (San Francisco area).</p> <code>Query(None)</code> <code>start_date</code> <code>str | None</code> <p>Start date for temporal filtering in YYYY-MM-DD format. Only features observed on or after this date will be included. Example: \"2023-01-01\".</p> <code>Query(None)</code> <code>end_date</code> <code>str | None</code> <p>End date for temporal filtering in YYYY-MM-DD format. Only features observed on or before this date will be included. Example: \"2023-12-31\".</p> <code>Query(None)</code> <p>Returns:</p> Name Type Description <code>GeoJSONFeatureCollection</code> <p>A GeoJSON FeatureCollection containing the requested geographic features. Each feature includes geometry (Point) and properties with observation metadata such as species information, observation dates, and location details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If layer_type is invalid (400) or if bbox format is incorrect (400).</p> <p>Examples:</p> <p>Basic usage - retrieve all observation features: <pre><code>GET /geo/observations\n</code></pre></p> <p>Filter by species: <pre><code>GET /geo/observations?species=Aedes%20aegypti,Anopheles%20gambiae\n</code></pre></p> <p>Filter by geographic bounds (San Francisco): <pre><code>GET /geo/observations?bbox=-122.4194,37.7749,-122.0808,37.9128\n</code></pre></p> <p>Filter by date range: <pre><code>GET /geo/observations?start_date=2023-01-01&amp;end_date=2023-06-30\n</code></pre></p> <p>Combined filters - species and location: <pre><code>GET /geo/observations?species=Aedes%20aegypti&amp;bbox=-74.0,40.7,-71.0,45.0\n</code></pre></p> <p>Combined filters - all parameters: <pre><code>GET /geo/observations?species=Culex%20quinquefasciatus\n                    &amp;bbox=-118.5,34.0,-118.1,34.3\n                    &amp;start_date=2023-03-01&amp;end_date=2023-09-30\n</code></pre></p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#prediction-services","title":"Prediction Services","text":"<p>The Prediction API provides machine learning-based species identification and prediction services.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction","title":"<code>backend.routers.prediction</code>","text":"<p>Prediction router for mosquito species identification.</p> <p>This module provides FastAPI endpoints for predicting mosquito species from uploaded images using AI-powered classification. The router handles image validation, coordinates with the prediction service, and returns structured results.</p> Main Components <ul> <li>APIRouter instance configured for prediction endpoints</li> <li>predict_species endpoint for species identification</li> </ul> The prediction system supports <ul> <li>Multiple image formats (JPEG, PNG, etc.)</li> <li>Real-time species identification with confidence scores</li> <li>Optional image saving for predicted results</li> <li>Comprehensive error handling and logging</li> </ul> Example <p>from fastapi import FastAPI from backend.routers.prediction import router</p> <p>app = FastAPI() app.include_router(router, prefix=\"/api/v1\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction--now-available-at-post-apiv1predict","title":"Now available at POST /api/v1/predict","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.prediction_service","title":"<code>prediction_service = &lt;backend.services.prediction_service.PredictionService object at 0x00000274A9218790&gt;</code>  <code>module-attribute</code>","text":"<p>Service for mosquito species prediction using the CulicidaeLab <code>serve</code> API.</p> <p>This class provides a high-level interface for species identification from images. It is optimized for production use, leveraging an efficient inference backend with automatic model caching to ensure low latency.</p> <p>Attributes:</p> Name Type Description <code>save_predicted_images_enabled</code> <code>bool</code> <p>Whether to save predicted images.</p> <code>model_id</code> <code>str</code> <p>The identifier for the machine learning model being used.</p> Example <p>service = PredictionService() result, error = await service.predict_species(image_data, \"test.jpg\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.PredictionResult","title":"<code>PredictionResult</code>","text":"<p>Model for prediction results.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.PredictionResult.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.predict_species","title":"<code>predict_species(file: UploadFile = File(PydanticUndefined)) -&gt; PredictionResult</code>  <code>async</code>","text":"<p>Predict mosquito species from an uploaded image.</p> <p>This endpoint accepts an image file and uses AI-powered classification to identify the mosquito species. The prediction includes confidence scores and optional species information.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>UploadFile</code> <p>The image file to analyze. Must be a valid image format (JPEG, PNG, etc.). The file is validated for content type and non-empty content.</p> <code>File(PydanticUndefined)</code> <p>Returns:</p> Name Type Description <code>PredictionResult</code> <code>PredictionResult</code> <p>A structured response containing: - id: Species identifier (lowercase with underscores) - scientific_name: The predicted species name - probabilities: Dictionary of species -&gt; confidence scores - model_id: Identifier of the AI model used - confidence: Confidence score of the top prediction - image_url_species: URL to processed image (if saving enabled)</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the file is not an image (400 Bad Request)</p> <code>HTTPException</code> <p>If the file is empty (400 Bad Request)</p> <code>HTTPException</code> <p>If prediction fails (500 Internal Server Error)</p> Example <p>import requests</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.predict_species--using-curl-command","title":"Using curl command:","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.predict_species--curl-x-post-httplocalhost8000predict-h-accept-applicationjson-h-content-type-multipartform-data-f-filemosquito_imagejpg","title":"curl -X POST \"http://localhost:8000/predict\"         &gt;&gt;&gt; #      -H \"accept: application/json\"         &gt;&gt;&gt; #      -H \"Content-Type: multipart/form-data\"         &gt;&gt;&gt; #      -F \"file=@mosquito_image.jpg\"","text":"","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.prediction.predict_species--using-python-requests","title":"Using Python requests:","text":"<p>response = requests.post( ...     \"http://localhost:8000/predict\", ...     files={\"file\": open(\"mosquito_image.jpg\", \"rb\")} ... ) result = response.json() print(f\"Predicted species: {result['scientific_name']}\") print(f\"Confidence: {result['confidence']:.2%}\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#observation-management","title":"Observation Management","text":"<p>The Observation API handles mosquito observation data, including recording and retrieving observation records.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation","title":"<code>backend.routers.observation</code>","text":"<p>Observation Router Module for CulicidaeLab Server API.</p> <p>This module provides FastAPI router endpoints for managing mosquito observation records. It handles creation and retrieval of observation data, including species identification, location information, and metadata.</p> <p>The router integrates with the observation service layer to persist and retrieve data from the database while providing proper validation and error handling.</p> Typical usage example <p>from backend.routers.observation import router app.include_router(router, prefix=\"/api/v1\")</p> Endpoints <p>POST /observations - Create a new observation record GET /observations - Retrieve observations with optional filtering</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.Observation","title":"<code>Observation</code>","text":"<p>Complete observation model with unique identifier.</p> <p>Extends ObservationBase with system-generated fields for storing complete observation records.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.Observation.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.ObservationListResponse","title":"<code>ObservationListResponse</code>","text":"<p>Response model for paginated observation lists.</p> <p>Contains the total count and list of observations for API responses.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.ObservationListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.create_observation","title":"<code>create_observation(observation: Observation) -&gt; Observation</code>  <code>async</code>","text":"<p>Create a new mosquito observation record.</p> <p>This endpoint accepts a complete observation record and stores it in the database. The observation should include species identification, location data, and metadata. If no user_id is provided, a UUID will be automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>Observation</code> <p>Complete observation data including species information, location coordinates, count, and optional metadata. Must conform to the Observation schema with all required fields validated.</p> required <p>Returns:</p> Name Type Description <code>Observation</code> <code>Observation</code> <p>The created observation record with assigned ID and any server-generated fields.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If observation creation fails due to validation errors or database issues. Returns 500 status code for server errors.</p> Example <p>from backend.schemas.observation_schemas import Observation, Location observation_data = Observation( ...     species_scientific_name=\"Aedes aegypti\", ...     count=5, ...     location=Location(lat=40.7128, lng=-74.0060), ...     observed_at=\"2024-01-15T10:30:00Z\", ...     notes=\"Found near standing water\" ... ) result = await create_observation(observation_data) print(f\"Created observation with ID: {result.id}\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.get_observations","title":"<code>get_observations(species_id: str | None = None, limit: int = 100, offset: int = 0, user_id: str = 'default_user_id') -&gt; ObservationListResponse</code>  <code>async</code>","text":"<p>Retrieve mosquito observations with optional filtering.</p> <p>This endpoint returns a paginated list of observation records. Results can be filtered by species and user, with configurable pagination limits.</p> <p>Parameters:</p> Name Type Description Default <code>species_id</code> <code>str | None</code> <p>Optional species identifier to filter observations. If None, returns observations for all species. Should be a valid species UUID or identifier from the database.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of observations to return in a single response. Must be between 1 and 1000. Defaults to 100. Larger values are automatically capped at 1000 for performance.</p> <code>100</code> <code>offset</code> <code>int</code> <p>Number of observations to skip for pagination. Must be non-negative. Defaults to 0. Use with limit for paginated results.</p> <code>0</code> <code>user_id</code> <code>str</code> <p>Identifier for the user whose observations to retrieve. Currently defaults to \"default_user_id\" but should be replaced with proper authentication in production.</p> <code>'default_user_id'</code> <p>Returns:</p> Name Type Description <code>ObservationListResponse</code> <code>ObservationListResponse</code> <p>Paginated response containing the total count of matching observations and the list of observation records. Each observation includes full species, location, and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If observation retrieval fails due to database errors or invalid parameters. Returns 500 status code for server errors.</p> Example","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.get_observations--get-first-50-observations-for-all-species","title":"Get first 50 observations for all species","text":"<p>response = await get_observations(limit=50) print(f\"Total observations: {response.count}\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.get_observations--get-observations-for-a-specific-species-with-pagination","title":"Get observations for a specific species with pagination","text":"<p>response = await get_observations( ...     species_id=\"aedes-aegypti-uuid\", ...     limit=25, ...     offset=25 ... ) for obs in response.observations: ...     print(f\"Species: {obs.species_scientific_name}\")</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.get_observations--get-observations-for-a-specific-user-when-auth-is-implemented","title":"Get observations for a specific user (when auth is implemented)","text":"<p>response = await get_observations( ...     user_id=\"authenticated-user-id\", ...     limit=10 ... )</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.observation.get_observation_service","title":"<code>get_observation_service()</code>  <code>async</code>","text":"<p>Get or initialize the global observation service instance.</p> <p>This function implements a singleton pattern for the ObservationService, ensuring that only one instance exists and is properly initialized. If the service hasn't been created yet, it creates a new instance and initializes it.</p> <p>Returns:</p> Name Type Description <code>ObservationService</code> <p>The global observation service instance, initialized and ready for use.</p> Example <p>service = await get_observation_service() observations = await service.get_observations(limit=10)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#data-filtering","title":"Data Filtering","text":"<p>The Filters API provides endpoints for retrieving filter options and managing data filtering capabilities.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters","title":"<code>backend.routers.filters</code>","text":"<p>Router module for filter-related API endpoints in CulicidaeLab.</p> <p>This module provides FastAPI router endpoints for retrieving filter options used throughout the CulicidaeLab application. It handles requests for species, regions, and data source filtering options with multi-language support.</p> The module includes <ul> <li>Filter options endpoint for retrieving available filter criteria</li> <li>Integration with caching dependencies for performance</li> <li>Localization support for multiple languages</li> </ul> Typical usage example <p>from backend.routers.filters import router app.include_router(router)</p> <p>Attributes:</p> Name Type Description <code>router</code> <code>APIRouter</code> <p>FastAPI APIRouter instance containing filter-related endpoints.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.FilterOptions","title":"<code>FilterOptions</code>","text":"<p>Container model for all available filter options.</p> <p>Provides comprehensive filtering options including species, regions, and data sources for use in API endpoints that support filtering functionality.</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.FilterOptions.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_filter_options_endpoint","title":"<code>get_filter_options_endpoint(lang: str = Query(en), species_names: list[str] = Depends(get_species_cache), region_translations: dict = Depends(get_region_cache), data_source_translations: dict = Depends(get_data_source_cache))</code>  <code>async</code>","text":"<p>Retrieves available filter options for species, regions, and data sources.</p> <p>This endpoint provides comprehensive filtering options that can be used across the CulicidaeLab application to filter disease data by various criteria.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en' for English, 'es' for Spanish). Defaults to 'en'.</p> <code>Query(en)</code> <code>species_names</code> <code>list[str]</code> <p>List of available mosquito species names for filtering.</p> <code>Depends(get_species_cache)</code> <code>region_translations</code> <code>dict</code> <p>Dictionary mapping region codes to translated names.</p> <code>Depends(get_region_cache)</code> <code>data_source_translations</code> <code>dict</code> <p>Dictionary mapping data source codes to translated names.</p> <code>Depends(get_data_source_cache)</code> <p>Returns:</p> Name Type Description <code>FilterOptions</code> <p>A structured response containing: - species: List of available mosquito species with their display names - regions: List of geographical regions with translated names - data_sources: List of data sources with translated names</p> Example","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_filter_options_endpoint--get-filter-options-in-english","title":"Get filter options in English","text":"<p>response = await get_filter_options_endpoint(\"en\", [...], {...}, {...}) print(response.species)  # List of species options print(response.regions)  # List of region options</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_filter_options_endpoint--get-filter-options-in-spanish","title":"Get filter options in Spanish","text":"<p>response = await get_filter_options_endpoint(\"es\", [...], {...}, {...}) print(response.species)  # Lista de opciones de especies</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_data_source_cache","title":"<code>get_data_source_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the data sources translation cache.</p> <p>Provides access to the cached data source translations, which maps data source codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to data source translation dictionaries.</p> Example <p>@app.get(\"/datasources/{language}\") async def get_data_sources_by_language(     sources: dict = Depends(get_data_source_cache),     language: str = \"en\" ):     return sources.get(language, {})</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_region_cache","title":"<code>get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the regions translation cache.</p> <p>Provides access to the cached region translations data, which maps region codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to region translation dictionaries.</p> Example <p>@app.get(\"/regions/{language}\") async def get_regions_by_language(     regions: dict = Depends(get_region_cache),     language: str = \"en\" ):     return regions.get(language, {})</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/#backend.routers.filters.get_species_cache","title":"<code>get_species_cache(request: Request) -&gt; list[str]</code>","text":"<p>Dependency for the species names list cache.</p> <p>Provides access to the cached list of all available species names for validation and autocomplete functionality.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of all available species names in the system.</p> Example <p>@app.get(\"/species\") async def get_all_species(     species_list: list[str] = Depends(get_species_cache) ):     return {\"species\": species_list}</p>","tags":["api","reference","development","backend","fastapi"]},{"location":"developer-guide/api-reference/diseases/","title":"Diseases API","text":"<p>The Diseases API manages disease-related data and provides endpoints for retrieving information about mosquito-borne diseases.</p>"},{"location":"developer-guide/api-reference/diseases/#router-implementation","title":"Router Implementation","text":"<p>Disease-related API endpoints for the CulicidaeLab server.</p> <p>This module provides FastAPI router endpoints for retrieving information about vector-borne diseases and their associated arthropod vectors. The endpoints support multiple languages and provide both list and detail views of diseases.</p> <p>The module includes the following endpoints: - GET /diseases: Retrieve a paginated list of diseases with optional search filtering - GET /diseases/{disease_id}: Retrieve detailed information for a specific disease - GET /diseases/{disease_id}/vectors: Retrieve vector species associated with a disease</p> <p>All endpoints support internationalization and return data in the requested language.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.Disease","title":"<code>Disease</code>","text":"<p>Complete disease model with unique identifier.</p> <p>Used for responses that include the database ID of the disease.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.Disease.model_config","title":"<code>model_config = {'from_attributes': True}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.Disease.Config","title":"<code>Config</code>","text":""},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.Disease.Config.from_attributes","title":"<code>from_attributes = True</code>  <code>class-attribute</code>","text":"<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.DiseaseListResponse","title":"<code>DiseaseListResponse</code>","text":"<p>Response model for paginated disease lists.</p> <p>Contains the total count and list of diseases for API responses.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.DiseaseListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.SpeciesBase","title":"<code>SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.get_disease_list_endpoint","title":"<code>get_disease_list_endpoint(request: Request, db: DBConnection = Depends(get_db), search: str | None = Query(None), limit: int = Query(50), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve a list of vector-borne diseases, optionally filtered by a search term.</p> <p>This endpoint provides a paginated list of diseases that can be filtered by name or description. Results are localized based on the requested language and support various query parameters for flexible disease discovery and analysis.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information and headers.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying disease data from the LanceDB vector database.</p> <code>Depends(get_db)</code> <code>search</code> <code>str | None</code> <p>Optional search term to filter diseases by name or description. Performs case-insensitive substring matching. If None, returns all diseases. Examples: \"malaria\", \"fever\", \"mosquito\".</p> <code>Query(None)</code> <code>limit</code> <code>int</code> <p>Maximum number of diseases to return per page (1-200). Defaults to 50. Use this parameter for pagination control when dealing with large result sets.</p> <code>Query(50)</code> <code>lang</code> <code>str</code> <p>Language code for response localization and internationalization. Supported languages: 'en' (English), 'es' (Spanish), 'fr' (French), 'pt' (Portuguese). Defaults to 'en' for English responses.</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>DiseaseListResponse</code> <p>A structured response containing: - count (int): Total number of diseases matching the search criteria - diseases (list[Disease]): List of disease objects with basic information</p> Example <p>Basic disease list retrieval: GET /diseases?limit=10&amp;lang=en</p> <p>Search for specific diseases: GET /diseases?search=malaria&amp;limit=5&amp;lang=en</p> <p>Multilingual support: GET /diseases?search=fiebre&amp;lang=en</p> <p>Response format: {     \"count\": 2,     \"diseases\": [         {             \"id\": \"malaria\",             \"name\": \"Malaria\",             \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",             \"vectors\": [\"Anopheles mosquito\"]         },         {             \"id\": \"dengue\",             \"name\": \"Dengue Fever\",             \"description\": \"A mosquito-borne viral infection causing flu-like illness...\",             \"vectors\": [\"Aedes aegypti\", \"Aedes albopictus\"]         }     ] }</p> Source code in <code>backend\\routers\\diseases.py</code> <pre><code>@router.get(\"/diseases\", response_model=DiseaseListResponse)\nasync def get_disease_list_endpoint(\n    request: Request,\n    db: lancedb.DBConnection = Depends(database.get_db),\n    search: str | None = Query(None, description=\"Search term for disease name or description\"),\n    limit: int = Query(50, ge=1, le=200, description=\"Number of results to return\"),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve a list of vector-borne diseases, optionally filtered by a search term.\n\n    This endpoint provides a paginated list of diseases that can be filtered by name or description.\n    Results are localized based on the requested language and support various query parameters\n    for flexible disease discovery and analysis.\n\n    Args:\n        request (Request): The FastAPI request object containing client information and headers.\n        db (lancedb.DBConnection): Database connection dependency for querying disease data from\n            the LanceDB vector database.\n        search (str | None): Optional search term to filter diseases by name or description.\n            Performs case-insensitive substring matching. If None, returns all diseases.\n            Examples: \"malaria\", \"fever\", \"mosquito\".\n        limit (int): Maximum number of diseases to return per page (1-200). Defaults to 50.\n            Use this parameter for pagination control when dealing with large result sets.\n        lang (str): Language code for response localization and internationalization.\n            Supported languages: 'en' (English), 'es' (Spanish), 'fr' (French), 'pt' (Portuguese).\n            Defaults to 'en' for English responses.\n\n    Returns:\n        DiseaseListResponse: A structured response containing:\n            - count (int): Total number of diseases matching the search criteria\n            - diseases (list[Disease]): List of disease objects with basic information\n\n    Example:\n        Basic disease list retrieval:\n        GET /diseases?limit=10&amp;lang=en\n\n        Search for specific diseases:\n        GET /diseases?search=malaria&amp;limit=5&amp;lang=en\n\n        Multilingual support:\n        GET /diseases?search=fiebre&amp;lang=en\n\n        Response format:\n        {\n            \"count\": 2,\n            \"diseases\": [\n                {\n                    \"id\": \"malaria\",\n                    \"name\": \"Malaria\",\n                    \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",\n                    \"vectors\": [\"Anopheles mosquito\"]\n                },\n                {\n                    \"id\": \"dengue\",\n                    \"name\": \"Dengue Fever\",\n                    \"description\": \"A mosquito-borne viral infection causing flu-like illness...\",\n                    \"vectors\": [\"Aedes aegypti\", \"Aedes albopictus\"]\n                }\n            ]\n        }\n    \"\"\"\n    disease_list = disease_service.get_all_diseases(db, request, lang=lang, search=search, limit=limit)\n    return DiseaseListResponse(count=len(disease_list), diseases=disease_list)\n</code></pre>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.get_disease_detail_endpoint","title":"<code>get_disease_detail_endpoint(disease_id: str, request: Request, db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve detailed information for a specific disease by ID.</p> <p>This endpoint provides comprehensive information about a specific vector-borne disease, including its description, associated vectors, symptoms, and other relevant details. Results are localized based on the requested language.</p> <p>Parameters:</p> Name Type Description Default <code>disease_id</code> <code>str</code> <p>Unique identifier for the disease (e.g., 'malaria', 'dengue'). This is typically the disease name in lowercase with hyphens.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying disease data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'fr'). Defaults to 'en' for English.</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>Disease</code> <p>A detailed disease object containing all available information about the specified disease, or None if the disease is not found.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the disease with the specified ID is not found (404 status code).</p> Example <p>GET /diseases/malaria?lang=en Response: {     \"id\": \"malaria\",     \"name\": \"Malaria\",     \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",     \"symptoms\": [\"Fever\", \"Chills\", \"Headache\"],     \"vectors\": [\"Anopheles gambiae\", \"Anopheles funestus\"],     \"regions\": [\"Sub-Saharan Africa\", \"Southeast Asia\"],     \"transmission\": \"Bite of infected female Anopheles mosquitoes\" }</p> Source code in <code>backend\\routers\\diseases.py</code> <pre><code>@router.get(\"/diseases/{disease_id}\", response_model=Disease)\nasync def get_disease_detail_endpoint(\n    disease_id: str,\n    request: Request,\n    db: lancedb.DBConnection = Depends(database.get_db),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve detailed information for a specific disease by ID.\n\n    This endpoint provides comprehensive information about a specific vector-borne disease,\n    including its description, associated vectors, symptoms, and other relevant details.\n    Results are localized based on the requested language.\n\n    Args:\n        disease_id (str): Unique identifier for the disease (e.g., 'malaria', 'dengue').\n            This is typically the disease name in lowercase with hyphens.\n        request (Request): The FastAPI request object containing client information.\n        db (lancedb.DBConnection): Database connection dependency for querying disease data.\n        lang (str): Language code for response localization (e.g., 'en', 'es', 'fr').\n            Defaults to 'en' for English.\n\n    Returns:\n        Disease: A detailed disease object containing all available information about\n            the specified disease, or None if the disease is not found.\n\n    Raises:\n        HTTPException: If the disease with the specified ID is not found (404 status code).\n\n    Example:\n        GET /diseases/malaria?lang=en\n        Response:\n        {\n            \"id\": \"malaria\",\n            \"name\": \"Malaria\",\n            \"description\": \"A life-threatening disease caused by Plasmodium parasites...\",\n            \"symptoms\": [\"Fever\", \"Chills\", \"Headache\"],\n            \"vectors\": [\"Anopheles gambiae\", \"Anopheles funestus\"],\n            \"regions\": [\"Sub-Saharan Africa\", \"Southeast Asia\"],\n            \"transmission\": \"Bite of infected female Anopheles mosquitoes\"\n        }\n    \"\"\"\n    disease_detail = disease_service.get_disease_by_id(db, disease_id, lang, request)\n    if not disease_detail:\n        raise HTTPException(status_code=404, detail=\"Disease not found\")\n    return disease_detail\n</code></pre>"},{"location":"developer-guide/api-reference/diseases/#backend.routers.diseases.get_disease_vectors_endpoint","title":"<code>get_disease_vectors_endpoint(disease_id: str, request: Request, db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve vector species associated with a specific disease.</p> <p>This endpoint returns a list of arthropod vectors (primarily mosquitoes, ticks, and flies) that are known to transmit the specified disease. This information is crucial for understanding disease transmission patterns and vector control strategies.</p> <p>Parameters:</p> Name Type Description Default <code>disease_id</code> <code>str</code> <p>Unique identifier for the disease (e.g., 'malaria', 'lyme-disease'). This is typically the disease name in lowercase with hyphens.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object containing client information.</p> required <code>db</code> <code>DBConnection</code> <p>Database connection dependency for querying species data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'fr'). Defaults to 'en' for English.</p> <code>Query(en)</code> <p>Returns:</p> Type Description <p>list[SpeciesBase]: A list of species objects that serve as vectors for the specified disease. Each species includes taxonomic information and habitat details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the disease with the specified ID is not found (404 status code).</p> Example <p>GET /diseases/malaria/vectors?lang=en Response: [     {         \"id\": \"anopheles-gambiae\",         \"scientific_name\": \"Anopheles gambiae\",         \"common_name\": \"African malaria mosquito\",         \"genus\": \"Anopheles\",         \"family\": \"Culicidae\",         \"habitat\": \"Tropical and subtropical regions\",         \"distribution\": \"Sub-Saharan Africa\"     },     {         \"id\": \"anopheles-funestus\",         \"scientific_name\": \"Anopheles funestus\",         \"common_name\": \"Common malaria mosquito\",         \"genus\": \"Anopheles\",         \"family\": \"Culicidae\",         \"habitat\": \"Rural and peri-urban areas\",         \"distribution\": \"Africa south of the Sahara\"     } ]</p> Source code in <code>backend\\routers\\diseases.py</code> <pre><code>@router.get(\"/diseases/{disease_id}/vectors\", response_model=list[SpeciesBase])\nasync def get_disease_vectors_endpoint(\n    disease_id: str,\n    request: Request,\n    db: lancedb.DBConnection = Depends(database.get_db),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve vector species associated with a specific disease.\n\n    This endpoint returns a list of arthropod vectors (primarily mosquitoes, ticks, and flies)\n    that are known to transmit the specified disease. This information is crucial for\n    understanding disease transmission patterns and vector control strategies.\n\n    Args:\n        disease_id (str): Unique identifier for the disease (e.g., 'malaria', 'lyme-disease').\n            This is typically the disease name in lowercase with hyphens.\n        request (Request): The FastAPI request object containing client information.\n        db (lancedb.DBConnection): Database connection dependency for querying species data.\n        lang (str): Language code for response localization (e.g., 'en', 'es', 'fr').\n            Defaults to 'en' for English.\n\n    Returns:\n        list[SpeciesBase]: A list of species objects that serve as vectors for the specified\n            disease. Each species includes taxonomic information and habitat details.\n\n    Raises:\n        HTTPException: If the disease with the specified ID is not found (404 status code).\n\n    Example:\n        GET /diseases/malaria/vectors?lang=en\n        Response:\n        [\n            {\n                \"id\": \"anopheles-gambiae\",\n                \"scientific_name\": \"Anopheles gambiae\",\n                \"common_name\": \"African malaria mosquito\",\n                \"genus\": \"Anopheles\",\n                \"family\": \"Culicidae\",\n                \"habitat\": \"Tropical and subtropical regions\",\n                \"distribution\": \"Sub-Saharan Africa\"\n            },\n            {\n                \"id\": \"anopheles-funestus\",\n                \"scientific_name\": \"Anopheles funestus\",\n                \"common_name\": \"Common malaria mosquito\",\n                \"genus\": \"Anopheles\",\n                \"family\": \"Culicidae\",\n                \"habitat\": \"Rural and peri-urban areas\",\n                \"distribution\": \"Africa south of the Sahara\"\n            }\n        ]\n    \"\"\"\n    disease_detail = disease_service.get_disease_by_id(db, disease_id, lang, request)\n    if not disease_detail:\n        raise HTTPException(status_code=404, detail=\"Disease not found\")\n\n    vector_species = species_service.get_vector_species(db, request, lang=lang, disease_id=disease_id)\n    return vector_species\n</code></pre>"},{"location":"developer-guide/api-reference/diseases/#data-schemas","title":"Data Schemas","text":"<p>The Diseases API uses Pydantic schemas for request/response validation:</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas","title":"<code>backend.schemas.diseases_schemas</code>","text":"<p>Pydantic models for the Disease service.</p> <p>This module defines the schema models used for request/response validation in the Disease service endpoints.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.DiseaseBase","title":"<code>DiseaseBase</code>","text":"<p>Base model for disease information.</p> <p>Contains common fields that can be shared between request and response models.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.DiseaseBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.Disease","title":"<code>Disease</code>","text":"<p>Complete disease model with unique identifier.</p> <p>Used for responses that include the database ID of the disease.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.Disease.model_config","title":"<code>model_config = {'from_attributes': True}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.Disease.Config","title":"<code>Config</code>","text":"<code>from_attributes = True</code> <code>class-attribute</code> \u00b6 <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.DiseaseListResponse","title":"<code>DiseaseListResponse</code>","text":"<p>Response model for paginated disease lists.</p> <p>Contains the total count and list of diseases for API responses.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.schemas.diseases_schemas.DiseaseListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#service-layer","title":"Service Layer","text":"<p>The Diseases API integrates with the disease service layer:</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service","title":"<code>backend.services.disease_service</code>","text":"<p>Disease data service for managing mosquito-borne disease information.</p> <p>This module provides functionality for retrieving and filtering disease data from the database, including support for multiple languages, search functionality, and vector-based filtering. It handles the conversion of raw database records to properly formatted disease models.</p> Example <p>from backend.services.disease_service import get_all_diseases from backend.services.database import get_db from fastapi import Request db = get_db() diseases = get_all_diseases(db, request, \"en\", search=\"malaria\")</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.Disease","title":"<code>Disease</code>","text":"<p>Complete disease model with unique identifier.</p> <p>Used for responses that include the database ID of the disease.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.Disease.model_config","title":"<code>model_config = {'from_attributes': True}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.Disease.Config","title":"<code>Config</code>","text":"<code>from_attributes = True</code> <code>class-attribute</code> \u00b6 <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_all_diseases","title":"<code>get_all_diseases(db: DBConnection, request: Request, lang: str, search: str | None = None, limit: int = 50) -&gt; list[backend.schemas.diseases_schemas.Disease]</code>","text":"<p>Retrieve a list of diseases with optional search filtering.</p> <p>This function queries the diseases table and returns disease records, optionally filtered by search terms across multiple language fields. Results are returned as properly formatted Disease objects.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>search</code> <code>str | None</code> <p>Search term to filter diseases by. Searches across name and description fields in all languages. If None, returns all diseases.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of diseases to return. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>list[Disease]</code> <p>list[Disease]: A list of Disease objects matching the search criteria, or all diseases if no search term is provided.</p> Example <p>from backend.services.database import get_db db = get_db()</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_all_diseases--get-all-diseases","title":"Get all diseases","text":"<p>all_diseases = get_all_diseases(db, request, \"en\")</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_all_diseases--search-for-malaria-related-diseases","title":"Search for malaria-related diseases","text":"<p>malaria_diseases = get_all_diseases(db, request, \"en\", search=\"malaria\")</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_disease_by_id","title":"<code>get_disease_by_id(db: DBConnection, disease_id: str, lang: str, request: Request) -&gt; backend.schemas.diseases_schemas.Disease | None</code>","text":"<p>Retrieve detailed information for a specific disease by its ID.</p> <p>This function queries the diseases table for a specific disease record and returns it as a properly formatted Disease object. Returns None if the disease is not found.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>disease_id</code> <code>str</code> <p>The unique identifier for the disease to retrieve.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <p>Returns:</p> Type Description <code>Disease | None</code> <p>Disease | None: A Disease object if found, None if the disease does not exist in the database.</p> Example <p>from backend.services.database import get_db db = get_db() malaria = get_disease_by_id(db, \"malaria\", \"en\", request) if malaria: ...     print(f\"Disease: {malaria.name}\")</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_diseases_by_vector","title":"<code>get_diseases_by_vector(db: DBConnection, vector_id: str, lang: str, request: Request) -&gt; list[backend.schemas.diseases_schemas.Disease]</code>","text":"<p>Retrieve diseases associated with a specific mosquito vector species.</p> <p>This function queries the diseases table for diseases that are transmitted by the specified vector species. The vector relationship is determined by checking if the vector_id exists in the disease's vectors array.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>vector_id</code> <code>str</code> <p>The unique identifier of the vector species to search for.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <p>Returns:</p> Type Description <code>list[Disease]</code> <p>list[Disease]: A list of Disease objects that are transmitted by the specified vector species. Returns an empty list if no diseases are found or if the vector species doesn't exist.</p> Example <p>from backend.services.database import get_db db = get_db()</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_diseases_by_vector--get-diseases-transmitted-by-aedes-aegypti","title":"Get diseases transmitted by Aedes aegypti","text":"<p>aedes_diseases = get_diseases_by_vector(db, \"aedes_aegypti\", \"en\", request) for disease in aedes_diseases: ...     print(f\"{disease.name} - transmitted by Aedes aegypti\")</p>"},{"location":"developer-guide/api-reference/diseases/#backend.services.disease_service.get_table","title":"<code>get_table(db: DBConnection, table_name: str)</code>","text":"<p>Retrieve a specific table from the LanceDB database.</p> <p>Opens and returns a reference to the specified table in the database. This function validates that the table exists and is accessible.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to retrieve.</p> required <p>Returns:</p> Type Description <p>lancedb.table.Table: A table object for the specified table name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table is not found or cannot be opened.</p> Example <p>db = get_db() observations_table = get_table(db, \"observations\") results = observations_table.search().limit(10).to_list()</p>"},{"location":"developer-guide/api-reference/diseases/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/diseases/#basic-disease-information-retrieval","title":"Basic Disease Information Retrieval","text":"<pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    # Get list of diseases\n    response = await client.get(\n        \"http://localhost:8000/api/v1/diseases\",\n        params={\"lang\": \"en\"}\n    )\n    diseases = response.json()\n\n    # Get specific disease details\n    response = await client.get(\n        \"http://localhost:8000/api/v1/diseases/malaria\",\n        params={\"lang\": \"en\"}\n    )\n    disease_detail = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/filters/","title":"Filters API","text":"<p>The Filters API provides endpoints for retrieving filter options and managing data filtering capabilities across the CulicidaeLab platform.</p>"},{"location":"developer-guide/api-reference/filters/#router-implementation","title":"Router Implementation","text":"<p>Router module for filter-related API endpoints in CulicidaeLab.</p> <p>This module provides FastAPI router endpoints for retrieving filter options used throughout the CulicidaeLab application. It handles requests for species, regions, and data source filtering options with multi-language support.</p> The module includes <ul> <li>Filter options endpoint for retrieving available filter criteria</li> <li>Integration with caching dependencies for performance</li> <li>Localization support for multiple languages</li> </ul> Typical usage example <p>from backend.routers.filters import router app.include_router(router)</p> <p>Attributes:</p> Name Type Description <code>router</code> <code>APIRouter</code> <p>FastAPI APIRouter instance containing filter-related endpoints.</p>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.FilterOptions","title":"<code>FilterOptions</code>","text":"<p>Container model for all available filter options.</p> <p>Provides comprehensive filtering options including species, regions, and data sources for use in API endpoints that support filtering functionality.</p>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.FilterOptions.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_filter_options_endpoint","title":"<code>get_filter_options_endpoint(lang: str = Query(en), species_names: list[str] = Depends(get_species_cache), region_translations: dict = Depends(get_region_cache), data_source_translations: dict = Depends(get_data_source_cache))</code>  <code>async</code>","text":"<p>Retrieves available filter options for species, regions, and data sources.</p> <p>This endpoint provides comprehensive filtering options that can be used across the CulicidaeLab application to filter disease data by various criteria.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en' for English, 'es' for Spanish). Defaults to 'en'.</p> <code>Query(en)</code> <code>species_names</code> <code>list[str]</code> <p>List of available mosquito species names for filtering.</p> <code>Depends(get_species_cache)</code> <code>region_translations</code> <code>dict</code> <p>Dictionary mapping region codes to translated names.</p> <code>Depends(get_region_cache)</code> <code>data_source_translations</code> <code>dict</code> <p>Dictionary mapping data source codes to translated names.</p> <code>Depends(get_data_source_cache)</code> <p>Returns:</p> Name Type Description <code>FilterOptions</code> <p>A structured response containing: - species: List of available mosquito species with their display names - regions: List of geographical regions with translated names - data_sources: List of data sources with translated names</p> Example Source code in <code>backend\\routers\\filters.py</code> <pre><code>@router.get(\"/filter_options\", response_model=FilterOptions)\nasync def get_filter_options_endpoint(\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n    species_names: list[str] = Depends(get_species_cache),\n    region_translations: dict = Depends(get_region_cache),\n    data_source_translations: dict = Depends(get_data_source_cache),\n):\n    \"\"\"Retrieves available filter options for species, regions, and data sources.\n\n    This endpoint provides comprehensive filtering options that can be used across\n    the CulicidaeLab application to filter disease data by various criteria.\n\n    Args:\n        lang: Language code for response localization (e.g., 'en' for English,\n            'es' for Spanish). Defaults to 'en'.\n        species_names: List of available mosquito species names for filtering.\n        region_translations: Dictionary mapping region codes to translated names.\n        data_source_translations: Dictionary mapping data source codes to translated names.\n\n    Returns:\n        FilterOptions: A structured response containing:\n            - species: List of available mosquito species with their display names\n            - regions: List of geographical regions with translated names\n            - data_sources: List of data sources with translated names\n\n    Example:\n        &gt;&gt;&gt; # Get filter options in English\n        &gt;&gt;&gt; response = await get_filter_options_endpoint(\"en\", [...], {...}, {...})\n        &gt;&gt;&gt; print(response.species)  # List of species options\n        &gt;&gt;&gt; print(response.regions)  # List of region options\n\n        &gt;&gt;&gt; # Get filter options in Spanish\n        &gt;&gt;&gt; response = await get_filter_options_endpoint(\"es\", [...], {...}, {...})\n        &gt;&gt;&gt; print(response.species)  # Lista de opciones de especies\n    \"\"\"\n    return filter_service.get_filter_options(\n        lang=lang,\n        species_names=species_names,\n        region_translations=region_translations,\n        data_source_translations=data_source_translations,\n    )\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_filter_options_endpoint--get-filter-options-in-english","title":"Get filter options in English","text":"<p>response = await get_filter_options_endpoint(\"en\", [...], {...}, {...}) print(response.species)  # List of species options print(response.regions)  # List of region options</p>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_filter_options_endpoint--get-filter-options-in-spanish","title":"Get filter options in Spanish","text":"<p>response = await get_filter_options_endpoint(\"es\", [...], {...}, {...}) print(response.species)  # Lista de opciones de especies</p>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_data_source_cache","title":"<code>get_data_source_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the data sources translation cache.</p> <p>Provides access to the cached data source translations, which maps data source codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to data source translation dictionaries.</p> Example <p>@app.get(\"/datasources/{language}\") async def get_data_sources_by_language(     sources: dict = Depends(get_data_source_cache),     language: str = \"en\" ):     return sources.get(language, {})</p> Source code in <code>backend\\dependencies.py</code> <pre><code>def get_data_source_cache(request: Request) -&gt; dict[str, dict[str, str]]:\n    \"\"\"Dependency for the data sources translation cache.\n\n    Provides access to the cached data source translations, which maps\n    data source codes to translated names in multiple languages.\n\n    Args:\n        request (Request): The FastAPI request object containing app state.\n\n    Returns:\n        dict[str, dict[str, str]]: Dictionary mapping language codes to data\n            source translation dictionaries.\n\n    Example:\n        &gt;&gt;&gt; @app.get(\"/datasources/{language}\")\n        &gt;&gt;&gt; async def get_data_sources_by_language(\n        &gt;&gt;&gt;     sources: dict = Depends(get_data_source_cache),\n        &gt;&gt;&gt;     language: str = \"en\"\n        &gt;&gt;&gt; ):\n        &gt;&gt;&gt;     return sources.get(language, {})\n    \"\"\"\n    return get_cache(request, \"DATASOURCE_TRANSLATIONS\")\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_region_cache","title":"<code>get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the regions translation cache.</p> <p>Provides access to the cached region translations data, which maps region codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to region translation dictionaries.</p> Example <p>@app.get(\"/regions/{language}\") async def get_regions_by_language(     regions: dict = Depends(get_region_cache),     language: str = \"en\" ):     return regions.get(language, {})</p> Source code in <code>backend\\dependencies.py</code> <pre><code>def get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]:\n    \"\"\"Dependency for the regions translation cache.\n\n    Provides access to the cached region translations data, which maps\n    region codes to translated names in multiple languages.\n\n    Args:\n        request (Request): The FastAPI request object containing app state.\n\n    Returns:\n        dict[str, dict[str, str]]: Dictionary mapping language codes to region\n            translation dictionaries.\n\n    Example:\n        &gt;&gt;&gt; @app.get(\"/regions/{language}\")\n        &gt;&gt;&gt; async def get_regions_by_language(\n        &gt;&gt;&gt;     regions: dict = Depends(get_region_cache),\n        &gt;&gt;&gt;     language: str = \"en\"\n        &gt;&gt;&gt; ):\n        &gt;&gt;&gt;     return regions.get(language, {})\n    \"\"\"\n    return get_cache(request, \"REGION_TRANSLATIONS\")\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#backend.routers.filters.get_species_cache","title":"<code>get_species_cache(request: Request) -&gt; list[str]</code>","text":"<p>Dependency for the species names list cache.</p> <p>Provides access to the cached list of all available species names for validation and autocomplete functionality.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of all available species names in the system.</p> Example <p>@app.get(\"/species\") async def get_all_species(     species_list: list[str] = Depends(get_species_cache) ):     return {\"species\": species_list}</p> Source code in <code>backend\\dependencies.py</code> <pre><code>def get_species_cache(request: Request) -&gt; list[str]:\n    \"\"\"Dependency for the species names list cache.\n\n    Provides access to the cached list of all available species names\n    for validation and autocomplete functionality.\n\n    Args:\n        request (Request): The FastAPI request object containing app state.\n\n    Returns:\n        list[str]: List of all available species names in the system.\n\n    Example:\n        &gt;&gt;&gt; @app.get(\"/species\")\n        &gt;&gt;&gt; async def get_all_species(\n        &gt;&gt;&gt;     species_list: list[str] = Depends(get_species_cache)\n        &gt;&gt;&gt; ):\n        &gt;&gt;&gt;     return {\"species\": species_list}\n    \"\"\"\n    return get_cache(request, \"SPECIES_NAMES\")\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#data-schemas","title":"Data Schemas","text":"<p>The Filters API uses Pydantic schemas for filter data validation:</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas","title":"<code>backend.schemas.filter_schemas</code>","text":"<p>Pydantic models for filtering functionality.</p> <p>This module defines the schema models used for filter options in API endpoints across different services.</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.RegionFilter","title":"<code>RegionFilter</code>","text":"<p>Filter model for geographic regions.</p> <p>Used to represent available regions for filtering observations and species data.</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.RegionFilter.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.DataSourceFilter","title":"<code>DataSourceFilter</code>","text":"<p>Filter model for data sources.</p> <p>Used to represent available data sources for filtering observations and species data.</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.DataSourceFilter.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.FilterOptions","title":"<code>FilterOptions</code>","text":"<p>Container model for all available filter options.</p> <p>Provides comprehensive filtering options including species, regions, and data sources for use in API endpoints that support filtering functionality.</p>"},{"location":"developer-guide/api-reference/filters/#backend.schemas.filter_schemas.FilterOptions.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#service-layer","title":"Service Layer","text":"<p>The Filters API integrates with filter service layers:</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service","title":"<code>backend.services.filter_service</code>","text":"<p>Filter options service for generating localized filter data.</p> <p>This module provides functionality for constructing translated filter options from cached data sources, regions, and species information. It supports multiple languages and generates filter objects suitable for frontend consumption.</p> Example <p>from backend.services.filter_service import get_filter_options options = get_filter_options( ...     lang=\"en\", ...     species_names=[\"Aedes aegypti\", \"Culex pipiens\"], ...     region_translations={\"en\": {\"reg1\": \"Region 1\"}}, ...     data_source_translations={\"en\": {\"src1\": \"Source 1\"}} ... )</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.DataSourceFilter","title":"<code>DataSourceFilter</code>","text":"<p>Filter model for data sources.</p> <p>Used to represent available data sources for filtering observations and species data.</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.DataSourceFilter.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.FilterOptions","title":"<code>FilterOptions</code>","text":"<p>Container model for all available filter options.</p> <p>Provides comprehensive filtering options including species, regions, and data sources for use in API endpoints that support filtering functionality.</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.FilterOptions.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.RegionFilter","title":"<code>RegionFilter</code>","text":"<p>Filter model for geographic regions.</p> <p>Used to represent available regions for filtering observations and species data.</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.RegionFilter.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/filters/#backend.services.filter_service.get_filter_options","title":"<code>get_filter_options(lang: str, species_names: list[str], region_translations: dict[str, dict[str, str]], data_source_translations: dict[str, dict[str, str]]) -&gt; FilterOptions</code>","text":"<p>Construct translated filter options from pre-loaded, cached data.</p> <p>This function processes cached translation data to generate filter options for species, regions, and data sources in the specified language. All options are sorted alphabetically for consistent presentation.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>The target language code (e.g., 'en', 'ru') for which to generate translated filter options.</p> required <code>species_names</code> <code>list[str]</code> <p>A list of scientific species names to include in the filter options.</p> required <code>region_translations</code> <code>dict[str, dict[str, str]]</code> <p>A nested dictionary containing region translations structured as {lang: {region_id: name}}.</p> required <code>data_source_translations</code> <code>dict[str, dict[str, str]]</code> <p>A nested dictionary containing data source translations structured as {lang: {source_id: name}}.</p> required <p>Returns:</p> Name Type Description <code>FilterOptions</code> <code>FilterOptions</code> <p>A structured object containing sorted filter options for species, regions, and data sources in the specified language.</p> Example <p>species = [\"Aedes aegypti\", \"Culex quinquefasciatus\"] regions = {\"en\": {\"us\": \"United States\", \"br\": \"Brazil\"}} sources = {\"en\": {\"gbif\": \"GBIF\", \"citizen\": \"Citizen Science\"}} options = get_filter_options(\"en\", species, regions, sources) print(len(options.regions))  # Number of region options 2</p>"},{"location":"developer-guide/api-reference/filters/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/filters/#get-available-filters","title":"Get Available Filters","text":"<pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    # Get all available filter options\n    response = await client.get(\n        \"http://localhost:8000/api/v1/filters\",\n        params={\"lang\": \"en\"}\n    )\n    filters = response.json()\n\n    print(\"Available filters:\")\n    for filter_type, options in filters.items():\n        print(f\"- {filter_type}: {len(options)} options\")\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#get-specific-filter-type","title":"Get Specific Filter Type","text":"<pre><code># Get species filter options\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/filters/species\",\n    params={\"lang\": \"en\"}\n)\nspecies_filters = response.json()\n\n# Get region filter options\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/filters/regions\",\n    params={\"lang\": \"en\"}\n)\nregion_filters = response.json()\n\n# Get disease filter options\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/filters/diseases\",\n    params={\"lang\": \"en\"}\n)\ndisease_filters = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/filters/#apply-filters-to-data-queries","title":"Apply Filters to Data Queries","text":"<pre><code># Use filters in species queries\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/species\",\n    params={\n        \"region\": \"north-america\",\n        \"vector_status\": \"primary\",\n        \"disease\": \"malaria\",\n        \"lang\": \"en\"\n    }\n)\nfiltered_species = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/geo/","title":"Geographic Data API","text":"<p>The Geographic API handles location-based data and provides endpoints for retrieving geographic information and regional data.</p>"},{"location":"developer-guide/api-reference/geo/#router-implementation","title":"Router Implementation","text":"<p>Geographic API endpoints for the CulicidaeLab server.</p> <p>This module provides FastAPI router endpoints for retrieving geographic data and spatial information related to arthropod vectors and vector-borne diseases. The endpoints support various layer types and filtering options for spatial analysis and mapping applications.</p> <p>The module includes the following endpoints: - GET /geo/{layer_type}: Retrieve geographic features for a specific layer type   with optional spatial, temporal, and species-based filtering</p> <p>All endpoints return GeoJSON-compliant data structures suitable for mapping applications and geographic information systems (GIS). The endpoints support bounding box filtering, date range filtering, and species-specific queries.</p>"},{"location":"developer-guide/api-reference/geo/#backend.routers.geo.VALID_LAYER_TYPES","title":"<code>VALID_LAYER_TYPES = ['distribution', 'observations', 'modeled', 'breeding_sites']</code>  <code>module-attribute</code>","text":"<p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"developer-guide/api-reference/geo/#backend.routers.geo.GeoJSONFeatureCollection","title":"<code>GeoJSONFeatureCollection</code>","text":"<p>GeoJSON FeatureCollection model.</p> <p>Represents a collection of GeoJSON Features for batch operations and API responses containing multiple geographic features.</p>"},{"location":"developer-guide/api-reference/geo/#backend.routers.geo.GeoJSONFeatureCollection.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.routers.geo.get_geographic_layer","title":"<code>get_geographic_layer(layer_type: str = Path(PydanticUndefined), db: DBConnection = Depends(get_db), species: str | None = Query(None), bbox: str | None = Query(None), start_date: str | None = Query(None), end_date: str | None = Query(None))</code>  <code>async</code>","text":"<p>Retrieve geographic features for a specific layer type with optional filtering.</p> <p>This endpoint provides access to various geographic data layers related to arthropod vectors and vector-borne diseases. Currently supports observation data with spatial, temporal, and species-based filtering capabilities.</p> <p>The endpoint returns GeoJSON FeatureCollection data that can be directly consumed by mapping libraries and GIS applications for visualization and spatial analysis.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The type of geographic layer to retrieve. Must be one of: 'distribution', 'observations', 'modeled', 'breeding_sites'.</p> <code>Path(PydanticUndefined)</code> <code>db</code> <code>DBConnection</code> <p>Database connection for querying geographic data.</p> <code>Depends(get_db)</code> <code>species</code> <code>str | None</code> <p>Comma-separated list of species scientific names to filter by. If provided, only features for the specified species will be returned. Example: \"Aedes aegypti,Anopheles gambiae,Culex quinquefasciatus\".</p> <code>Query(None)</code> <code>bbox</code> <code>str | None</code> <p>Bounding box filter in the format \"min_lon,min_lat,max_lon,max_lat\". Filters features to only include those within the specified geographic bounds. Example: \"-122.4194,37.7749,-122.0808,37.9128\" (San Francisco area).</p> <code>Query(None)</code> <code>start_date</code> <code>str | None</code> <p>Start date for temporal filtering in YYYY-MM-DD format. Only features observed on or after this date will be included. Example: \"2023-01-01\".</p> <code>Query(None)</code> <code>end_date</code> <code>str | None</code> <p>End date for temporal filtering in YYYY-MM-DD format. Only features observed on or before this date will be included. Example: \"2023-12-31\".</p> <code>Query(None)</code> <p>Returns:</p> Name Type Description <code>GeoJSONFeatureCollection</code> <p>A GeoJSON FeatureCollection containing the requested geographic features. Each feature includes geometry (Point) and properties with observation metadata such as species information, observation dates, and location details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If layer_type is invalid (400) or if bbox format is incorrect (400).</p> <p>Examples:</p> <p>Basic usage - retrieve all observation features: <pre><code>GET /geo/observations\n</code></pre></p> <p>Filter by species: <pre><code>GET /geo/observations?species=Aedes%20aegypti,Anopheles%20gambiae\n</code></pre></p> <p>Filter by geographic bounds (San Francisco): <pre><code>GET /geo/observations?bbox=-122.4194,37.7749,-122.0808,37.9128\n</code></pre></p> <p>Filter by date range: <pre><code>GET /geo/observations?start_date=2023-01-01&amp;end_date=2023-06-30\n</code></pre></p> <p>Combined filters - species and location: <pre><code>GET /geo/observations?species=Aedes%20aegypti&amp;bbox=-74.0,40.7,-71.0,45.0\n</code></pre></p> <p>Combined filters - all parameters: <pre><code>GET /geo/observations?species=Culex%20quinquefasciatus\n                    &amp;bbox=-118.5,34.0,-118.1,34.3\n                    &amp;start_date=2023-03-01&amp;end_date=2023-09-30\n</code></pre></p> Source code in <code>backend\\routers\\geo.py</code> <pre><code>@router.get(\"/geo/{layer_type}\", response_model=GeoJSONFeatureCollection)\nasync def get_geographic_layer(\n    layer_type: str = Path(..., description=f\"Type of geographic layer. Valid types: {', '.join(VALID_LAYER_TYPES)}\"),\n    db: lancedb.DBConnection = Depends(database.get_db),\n    species: str | None = Query(None, description=\"Comma-separated list of species scientific names to filter by\"),\n    bbox: str | None = Query(None, description=\"Bounding box filter: min_lon,min_lat,max_lon,max_lat\"),\n    start_date: str | None = Query(None, description=\"Start date for filtering (YYYY-MM-DD)\"),\n    end_date: str | None = Query(None, description=\"End date for filtering (YYYY-MM-DD)\"),\n):\n    \"\"\"\n    Retrieve geographic features for a specific layer type with optional filtering.\n\n    This endpoint provides access to various geographic data layers related to arthropod\n    vectors and vector-borne diseases. Currently supports observation data with spatial,\n    temporal, and species-based filtering capabilities.\n\n    The endpoint returns GeoJSON FeatureCollection data that can be directly consumed\n    by mapping libraries and GIS applications for visualization and spatial analysis.\n\n    Args:\n        layer_type (str): The type of geographic layer to retrieve. Must be one of:\n            'distribution', 'observations', 'modeled', 'breeding_sites'.\n        db (lancedb.DBConnection): Database connection for querying geographic data.\n        species (str | None): Comma-separated list of species scientific names to filter by.\n            If provided, only features for the specified species will be returned.\n            Example: \"Aedes aegypti,Anopheles gambiae,Culex quinquefasciatus\".\n        bbox (str | None): Bounding box filter in the format \"min_lon,min_lat,max_lon,max_lat\".\n            Filters features to only include those within the specified geographic bounds.\n            Example: \"-122.4194,37.7749,-122.0808,37.9128\" (San Francisco area).\n        start_date (str | None): Start date for temporal filtering in YYYY-MM-DD format.\n            Only features observed on or after this date will be included.\n            Example: \"2023-01-01\".\n        end_date (str | None): End date for temporal filtering in YYYY-MM-DD format.\n            Only features observed on or before this date will be included.\n            Example: \"2023-12-31\".\n\n    Returns:\n        GeoJSONFeatureCollection: A GeoJSON FeatureCollection containing the requested\n            geographic features. Each feature includes geometry (Point) and properties\n            with observation metadata such as species information, observation dates,\n            and location details.\n\n    Raises:\n        HTTPException: If layer_type is invalid (400) or if bbox format is incorrect (400).\n\n    Examples:\n        Basic usage - retrieve all observation features:\n        ```\n        GET /geo/observations\n        ```\n\n        Filter by species:\n        ```\n        GET /geo/observations?species=Aedes%20aegypti,Anopheles%20gambiae\n        ```\n\n        Filter by geographic bounds (San Francisco):\n        ```\n        GET /geo/observations?bbox=-122.4194,37.7749,-122.0808,37.9128\n        ```\n\n        Filter by date range:\n        ```\n        GET /geo/observations?start_date=2023-01-01&amp;end_date=2023-06-30\n        ```\n\n        Combined filters - species and location:\n        ```\n        GET /geo/observations?species=Aedes%20aegypti&amp;bbox=-74.0,40.7,-71.0,45.0\n        ```\n\n        Combined filters - all parameters:\n        ```\n        GET /geo/observations?species=Culex%20quinquefasciatus\n                            &amp;bbox=-118.5,34.0,-118.1,34.3\n                            &amp;start_date=2023-03-01&amp;end_date=2023-09-30\n        ```\n    \"\"\"\n    if layer_type not in VALID_LAYER_TYPES:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid layer type. Valid types are: {', '.join(VALID_LAYER_TYPES)}\",\n        )\n\n    species_list: list[str] | None = None\n    if species:\n        species_list = [s.strip() for s in species.split(\",\") if s.strip()]\n\n    bbox_filter: tuple[float, float, float, float] | None = None\n    if bbox:\n        try:\n            coords = [float(c.strip()) for c in bbox.split(\",\")]\n            if len(coords) == 4:\n                bbox_filter = (coords[0], coords[1], coords[2], coords[3])\n            else:\n                raise ValueError(\"Bounding box must have 4 coordinates.\")\n        except ValueError as e:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Invalid bbox format: {e}. Use min_lon,min_lat,max_lon,max_lat\",\n            )\n\n    if start_date and not geo_service.is_valid_date_str(start_date):\n        raise HTTPException(status_code=400, detail=\"Invalid start_date format. Use YYYY-MM-DD\")\n    if end_date and not geo_service.is_valid_date_str(end_date):\n        raise HTTPException(status_code=400, detail=\"Invalid end_date format. Use YYYY-MM-DD\")\n\n    geojson_collection = geo_service.get_geo_layer(\n        db=db,\n        layer_type=layer_type,\n        species_list=species_list,\n        bbox_filter=bbox_filter,\n        start_date_str=start_date,\n        end_date_str=end_date,\n    )\n    return geojson_collection\n</code></pre>"},{"location":"developer-guide/api-reference/geo/#data-schemas","title":"Data Schemas","text":"<p>The Geographic API uses Pydantic schemas for geographic data validation:</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas","title":"<code>backend.schemas.geo_schemas</code>","text":"<p>Pydantic models for geographic data and GeoJSON structures.</p> <p>This module defines the schema models used for handling geographic data, GeoJSON structures, and map layer responses.</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONGeometry","title":"<code>GeoJSONGeometry</code>","text":"<p>GeoJSON geometry model.</p> <p>Represents the geometry component of a GeoJSON Feature, containing type and coordinates information.</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONGeometry.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONFeature","title":"<code>GeoJSONFeature</code>","text":"<p>GeoJSON Feature model.</p> <p>Represents a complete GeoJSON Feature with type, properties, and geometry. Used for representing geographic features with associated data.</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONFeature.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONFeatureCollection","title":"<code>GeoJSONFeatureCollection</code>","text":"<p>GeoJSON FeatureCollection model.</p> <p>Represents a collection of GeoJSON Features for batch operations and API responses containing multiple geographic features.</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.GeoJSONFeatureCollection.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.MapLayerResponse","title":"<code>MapLayerResponse</code>","text":"<p>Response model for map layer data.</p> <p>Contains layer metadata and GeoJSON data for rendering map layers in the frontend application.</p>"},{"location":"developer-guide/api-reference/geo/#backend.schemas.geo_schemas.MapLayerResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#service-layer","title":"Service Layer","text":"<p>The Geographic API integrates with geographic service layers:</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service","title":"<code>backend.services.geo_service</code>","text":"<p>Geographic data service for handling spatial queries and filtering.</p> <p>This module provides functionality for querying and filtering geographic data, particularly observation data with spatial and temporal filtering capabilities. It supports bounding box filtering, date range filtering, and species-based filtering for geographic visualization.</p> Example <p>from backend.services.geo_service import get_geo_layer from backend.services.database import get_db db = get_db() features = get_geo_layer(db, \"observations\", species_list=[\"Aedes aegypti\"])</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONFeature","title":"<code>GeoJSONFeature</code>","text":"<p>GeoJSON Feature model.</p> <p>Represents a complete GeoJSON Feature with type, properties, and geometry. Used for representing geographic features with associated data.</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONFeature.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONFeatureCollection","title":"<code>GeoJSONFeatureCollection</code>","text":"<p>GeoJSON FeatureCollection model.</p> <p>Represents a collection of GeoJSON Features for batch operations and API responses containing multiple geographic features.</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONFeatureCollection.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONGeometry","title":"<code>GeoJSONGeometry</code>","text":"<p>GeoJSON geometry model.</p> <p>Represents the geometry component of a GeoJSON Feature, containing type and coordinates information.</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.GeoJSONGeometry.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.is_valid_date_str","title":"<code>is_valid_date_str(date_str: str) -&gt; bool</code>","text":"<p>Validate if a string represents a valid YYYY-MM-DD date format.</p> <p>This helper function checks if the provided string can be parsed as a date in the expected format used throughout the application.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is a valid YYYY-MM-DD date, False otherwise.</p> Example <p>is_valid_date_str(\"2023-12-25\") True is_valid_date_str(\"invalid-date\") False</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.get_geo_layer","title":"<code>get_geo_layer(db: DBConnection, layer_type: str, species_list: list[str] | None = None, bbox_filter: tuple[float, float, float, float] | None = None, start_date_str: str | None = None, end_date_str: str | None = None, limit: int = 10000) -&gt; GeoJSONFeatureCollection</code>","text":"<p>Retrieve geographic features for a specific layer with optional filtering.</p> <p>This function queries observation data and applies multiple filters including species, bounding box, and date range filters. It returns GeoJSON formatted features suitable for mapping applications.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>layer_type</code> <code>str</code> <p>The type of layer to retrieve. Currently supports \"observations\". Other types return empty collections.</p> required <code>species_list</code> <code>list[str] | None</code> <p>List of species scientific names to filter by. If None, no species filtering is applied.</p> <code>None</code> <code>bbox_filter</code> <code>tuple[float, float, float, float] | None</code> <p>A bounding box as (min_lon, min_lat, max_lon, max_lat). If None, no spatial filtering is applied.</p> <code>None</code> <code>start_date_str</code> <code>str | None</code> <p>Start date in YYYY-MM-DD format. If None, no start date filtering is applied.</p> <code>None</code> <code>end_date_str</code> <code>str | None</code> <p>End date in YYYY-MM-DD format. If None, no end date filtering is applied.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return. Defaults to 10000.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>GeoJSONFeatureCollection</code> <code>GeoJSONFeatureCollection</code> <p>A GeoJSON FeatureCollection containing the filtered observation features with their properties and geometry.</p> Example <p>from backend.services.database import get_db db = get_db()</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.get_geo_layer--get-all-aedes-aegypti-observations-in-a-specific-region","title":"Get all Aedes aegypti observations in a specific region","text":"<p>features = get_geo_layer( ...     db, ...     \"observations\", ...     species_list=[\"Aedes aegypti\"], ...     bbox_filter=(-74.1, 40.6, -71.9, 41.3),  # NYC area ...     start_date_str=\"2023-01-01\", ...     end_date_str=\"2023-12-31\" ... ) print(len(features.features))  # Number of observations</p>"},{"location":"developer-guide/api-reference/geo/#backend.services.geo_service.get_table","title":"<code>get_table(db: DBConnection, table_name: str)</code>","text":"<p>Retrieve a specific table from the LanceDB database.</p> <p>Opens and returns a reference to the specified table in the database. This function validates that the table exists and is accessible.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to retrieve.</p> required <p>Returns:</p> Type Description <p>lancedb.table.Table: A table object for the specified table name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table is not found or cannot be opened.</p> Example <p>db = get_db() observations_table = get_table(db, \"observations\") results = observations_table.search().limit(10).to_list()</p>"},{"location":"developer-guide/api-reference/geo/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/geo/#geographic-data-retrieval","title":"Geographic Data Retrieval","text":"<pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    # Get regional data\n    response = await client.get(\n        \"http://localhost:8000/api/v1/regions\",\n        params={\"lang\": \"en\"}\n    )\n    regions = response.json()\n\n    # Get country information\n    response = await client.get(\n        \"http://localhost:8000/api/v1/countries\",\n        params={\"lang\": \"en\"}\n    )\n    countries = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/observation/","title":"Observation API","text":"<p>The Observation API handles mosquito observation data, including recording new observations and retrieving existing observation records.</p>"},{"location":"developer-guide/api-reference/observation/#router-implementation","title":"Router Implementation","text":"<p>Observation Router Module for CulicidaeLab Server API.</p> <p>This module provides FastAPI router endpoints for managing mosquito observation records. It handles creation and retrieval of observation data, including species identification, location information, and metadata.</p> <p>The router integrates with the observation service layer to persist and retrieve data from the database while providing proper validation and error handling.</p> Typical usage example <p>from backend.routers.observation import router app.include_router(router, prefix=\"/api/v1\")</p> Endpoints <p>POST /observations - Create a new observation record GET /observations - Retrieve observations with optional filtering</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.Observation","title":"<code>Observation</code>","text":"<p>Complete observation model with unique identifier.</p> <p>Extends ObservationBase with system-generated fields for storing complete observation records.</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.Observation.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.ObservationListResponse","title":"<code>ObservationListResponse</code>","text":"<p>Response model for paginated observation lists.</p> <p>Contains the total count and list of observations for API responses.</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.ObservationListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.create_observation","title":"<code>create_observation(observation: Observation) -&gt; Observation</code>  <code>async</code>","text":"<p>Create a new mosquito observation record.</p> <p>This endpoint accepts a complete observation record and stores it in the database. The observation should include species identification, location data, and metadata. If no user_id is provided, a UUID will be automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>Observation</code> <p>Complete observation data including species information, location coordinates, count, and optional metadata. Must conform to the Observation schema with all required fields validated.</p> required <p>Returns:</p> Name Type Description <code>Observation</code> <code>Observation</code> <p>The created observation record with assigned ID and any server-generated fields.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If observation creation fails due to validation errors or database issues. Returns 500 status code for server errors.</p> Example <p>from backend.schemas.observation_schemas import Observation, Location observation_data = Observation( ...     species_scientific_name=\"Aedes aegypti\", ...     count=5, ...     location=Location(lat=40.7128, lng=-74.0060), ...     observed_at=\"2024-01-15T10:30:00Z\", ...     notes=\"Found near standing water\" ... ) result = await create_observation(observation_data) print(f\"Created observation with ID: {result.id}\")</p> Source code in <code>backend\\routers\\observation.py</code> <pre><code>@router.post(\n    \"/observations\",\n    response_model=Observation,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Submit a new observation\",\n    description=\"Submit a complete observation record. Prediction must be done beforehand.\",\n)\nasync def create_observation(\n    observation: Observation,\n) -&gt; Observation:\n    \"\"\"Create a new mosquito observation record.\n\n    This endpoint accepts a complete observation record and stores it in the database.\n    The observation should include species identification, location data, and metadata.\n    If no user_id is provided, a UUID will be automatically generated.\n\n    Args:\n        observation: Complete observation data including species information,\n            location coordinates, count, and optional metadata. Must conform\n            to the Observation schema with all required fields validated.\n\n    Returns:\n        Observation: The created observation record with assigned ID and\n            any server-generated fields.\n\n    Raises:\n        HTTPException: If observation creation fails due to validation errors\n            or database issues. Returns 500 status code for server errors.\n\n    Example:\n        &gt;&gt;&gt; from backend.schemas.observation_schemas import Observation, Location\n        &gt;&gt;&gt; observation_data = Observation(\n        ...     species_scientific_name=\"Aedes aegypti\",\n        ...     count=5,\n        ...     location=Location(lat=40.7128, lng=-74.0060),\n        ...     observed_at=\"2024-01-15T10:30:00Z\",\n        ...     notes=\"Found near standing water\"\n        ... )\n        &gt;&gt;&gt; result = await create_observation(observation_data)\n        &gt;&gt;&gt; print(f\"Created observation with ID: {result.id}\")\n    \"\"\"\n    print(\"\\n--- [ROUTER] Received request to CREATE observation ---\")\n    try:\n        # FastAPI has already validated the incoming JSON against the Observation model.\n        # All we need to do is add any final business logic.\n\n        # Ensure user_id exists\n        if not observation.user_id:\n            observation.user_id = str(uuid4())\n            print(f\"[ROUTER] Generated new user_id: {observation.user_id}\")\n\n        print(\"[ROUTER] Observation data is valid. Calling observation service to save...\")\n        service = await get_observation_service()\n        new_observation = await service.create_observation(observation)\n        print(f\"[ROUTER] Observation created successfully with ID: {new_observation.id}\")\n        return new_observation\n\n    except HTTPException:\n        # Re-raise exceptions from services or validation\n        raise\n    except Exception as e:\n        # Catch any other unexpected errors\n        print(f\"[ROUTER] CRITICAL ERROR in /observations: {type(e).__name__} - {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to create observation: {str(e)}\",\n        )\n</code></pre>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.get_observations","title":"<code>get_observations(species_id: str | None = None, limit: int = 100, offset: int = 0, user_id: str = 'default_user_id') -&gt; ObservationListResponse</code>  <code>async</code>","text":"<p>Retrieve mosquito observations with optional filtering.</p> <p>This endpoint returns a paginated list of observation records. Results can be filtered by species and user, with configurable pagination limits.</p> <p>Parameters:</p> Name Type Description Default <code>species_id</code> <code>str | None</code> <p>Optional species identifier to filter observations. If None, returns observations for all species. Should be a valid species UUID or identifier from the database.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of observations to return in a single response. Must be between 1 and 1000. Defaults to 100. Larger values are automatically capped at 1000 for performance.</p> <code>100</code> <code>offset</code> <code>int</code> <p>Number of observations to skip for pagination. Must be non-negative. Defaults to 0. Use with limit for paginated results.</p> <code>0</code> <code>user_id</code> <code>str</code> <p>Identifier for the user whose observations to retrieve. Currently defaults to \"default_user_id\" but should be replaced with proper authentication in production.</p> <code>'default_user_id'</code> <p>Returns:</p> Name Type Description <code>ObservationListResponse</code> <code>ObservationListResponse</code> <p>Paginated response containing the total count of matching observations and the list of observation records. Each observation includes full species, location, and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If observation retrieval fails due to database errors or invalid parameters. Returns 500 status code for server errors.</p> Example Source code in <code>backend\\routers\\observation.py</code> <pre><code>@router.get(\n    \"/observations\",\n    response_model=ObservationListResponse,\n    summary=\"Get observations\",\n)\nasync def get_observations(\n    species_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n    user_id: str = \"default_user_id\",  # This should likely be replaced with auth\n) -&gt; ObservationListResponse:\n    \"\"\"Retrieve mosquito observations with optional filtering.\n\n    This endpoint returns a paginated list of observation records. Results can be\n    filtered by species and user, with configurable pagination limits.\n\n    Args:\n        species_id: Optional species identifier to filter observations. If None,\n            returns observations for all species. Should be a valid species UUID\n            or identifier from the database.\n        limit: Maximum number of observations to return in a single response.\n            Must be between 1 and 1000. Defaults to 100. Larger values are\n            automatically capped at 1000 for performance.\n        offset: Number of observations to skip for pagination. Must be non-negative.\n            Defaults to 0. Use with limit for paginated results.\n        user_id: Identifier for the user whose observations to retrieve. Currently\n            defaults to \"default_user_id\" but should be replaced with proper\n            authentication in production.\n\n    Returns:\n        ObservationListResponse: Paginated response containing the total count\n            of matching observations and the list of observation records.\n            Each observation includes full species, location, and metadata.\n\n    Raises:\n        HTTPException: If observation retrieval fails due to database errors\n            or invalid parameters. Returns 500 status code for server errors.\n\n    Example:\n        &gt;&gt;&gt; # Get first 50 observations for all species\n        &gt;&gt;&gt; response = await get_observations(limit=50)\n        &gt;&gt;&gt; print(f\"Total observations: {response.count}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Get observations for a specific species with pagination\n        &gt;&gt;&gt; response = await get_observations(\n        ...     species_id=\"aedes-aegypti-uuid\",\n        ...     limit=25,\n        ...     offset=25\n        ... )\n        &gt;&gt;&gt; for obs in response.observations:\n        ...     print(f\"Species: {obs.species_scientific_name}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Get observations for a specific user (when auth is implemented)\n        &gt;&gt;&gt; response = await get_observations(\n        ...     user_id=\"authenticated-user-id\",\n        ...     limit=10\n        ... )\n    \"\"\"\n    print(\"\\n--- [ROUTER] Received request for /observations (GET) ---\")\n    print(f\"[ROUTER] Params: species_id='{species_id}', limit={limit}, offset={offset}, user_id='{user_id}'\")\n    try:\n        service = await get_observation_service()\n        print(\"[ROUTER] Calling service.get_observations...\")\n        result = await service.get_observations(\n            user_id=user_id,\n            species_id=species_id,\n            limit=min(limit, 1000),  # Ensure limit is not excessive\n            offset=max(offset, 0),  # Ensure offset is non-negative\n        )\n        print(f\"[ROUTER] Retrieved {len(result.observations)} observations.\")\n        return result\n    except HTTPException as http_exc:\n        print(f\"[ROUTER] Caught HTTPException: {http_exc.status_code} - {http_exc.detail}\")\n        raise\n    except Exception as e:\n        print(f\"[ROUTER] CRITICAL ERROR in GET /observations: {type(e).__name__} - {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to retrieve observations: {str(e)}\",\n        )\n</code></pre>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.get_observations--get-first-50-observations-for-all-species","title":"Get first 50 observations for all species","text":"<p>response = await get_observations(limit=50) print(f\"Total observations: {response.count}\")</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.get_observations--get-observations-for-a-specific-species-with-pagination","title":"Get observations for a specific species with pagination","text":"<p>response = await get_observations( ...     species_id=\"aedes-aegypti-uuid\", ...     limit=25, ...     offset=25 ... ) for obs in response.observations: ...     print(f\"Species: {obs.species_scientific_name}\")</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.get_observations--get-observations-for-a-specific-user-when-auth-is-implemented","title":"Get observations for a specific user (when auth is implemented)","text":"<p>response = await get_observations( ...     user_id=\"authenticated-user-id\", ...     limit=10 ... )</p>"},{"location":"developer-guide/api-reference/observation/#backend.routers.observation.get_observation_service","title":"<code>get_observation_service()</code>  <code>async</code>","text":"<p>Get or initialize the global observation service instance.</p> <p>This function implements a singleton pattern for the ObservationService, ensuring that only one instance exists and is properly initialized. If the service hasn't been created yet, it creates a new instance and initializes it.</p> <p>Returns:</p> Name Type Description <code>ObservationService</code> <p>The global observation service instance, initialized and ready for use.</p> Example <p>service = await get_observation_service() observations = await service.get_observations(limit=10)</p> Source code in <code>backend\\services\\observation_service.py</code> <pre><code>async def get_observation_service():\n    \"\"\"Get or initialize the global observation service instance.\n\n    This function implements a singleton pattern for the ObservationService,\n    ensuring that only one instance exists and is properly initialized.\n    If the service hasn't been created yet, it creates a new instance\n    and initializes it.\n\n    Returns:\n        ObservationService: The global observation service instance,\n            initialized and ready for use.\n\n    Example:\n        &gt;&gt;&gt; service = await get_observation_service()\n        &gt;&gt;&gt; observations = await service.get_observations(limit=10)\n    \"\"\"\n    global observation_service\n    if observation_service is None:\n        observation_service = ObservationService()\n        await observation_service.initialize()\n    return observation_service\n</code></pre>"},{"location":"developer-guide/api-reference/observation/#data-schemas","title":"Data Schemas","text":"<p>The Observation API uses Pydantic schemas for observation data validation:</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas","title":"<code>backend.schemas.observation_schemas</code>","text":"<p>Pydantic models for the Observation service.</p> <p>This module defines the schema models used for request/response validation in the Observation service endpoints.</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.Location","title":"<code>Location</code>","text":"<p>Geographic location model.</p> <p>Represents latitude and longitude coordinates for observations.</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.Location.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.ObservationBase","title":"<code>ObservationBase</code>","text":"<p>Base model for observation data.</p> <p>Contains core observation fields used for creating and validating observation records.</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.ObservationBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.Observation","title":"<code>Observation</code>","text":"<p>Complete observation model with unique identifier.</p> <p>Extends ObservationBase with system-generated fields for storing complete observation records.</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.Observation.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.ObservationListResponse","title":"<code>ObservationListResponse</code>","text":"<p>Response model for paginated observation lists.</p> <p>Contains the total count and list of observations for API responses.</p>"},{"location":"developer-guide/api-reference/observation/#backend.schemas.observation_schemas.ObservationListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#service-layer","title":"Service Layer","text":"<p>The Observation API integrates with observation service layers:</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service","title":"<code>backend.services.observation_service</code>","text":"<p>Observation service for managing mosquito observation data.</p> <p>This module provides functionality for creating, storing, and retrieving mosquito observation records in the LanceDB database. It handles data validation, transformation, and provides both synchronous and asynchronous methods for observation management.</p> Example <p>from backend.services.observation_service import get_observation_service service = await get_observation_service() observation = await service.create_observation(obs_data)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService","title":"<code>ObservationService()</code>","text":"<p>Service for managing mosquito observation data.</p> <p>This class provides methods for creating new observations, retrieving existing observations with filtering options, and managing the database connection lifecycle.</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>The name of the database table for observations.</p> <code>db</code> <code>str</code> <p>The LanceDB database connection object.</p> Example <p>service = ObservationService() await service.initialize() observations = await service.get_observations(limit=10)</p> <p>Initialize the ObservationService with default configuration.</p> <p>Sets up the service with the observations table name and prepares for database connection initialization.</p> Example <p>service = ObservationService() print(service.table_name)  # \"observations\"</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the database connection and ensure required tables exist.</p> <p>This method establishes a connection to the LanceDB database through the LanceDB manager and prepares the service for observation operations. The observations table will be created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>ObservationService</code> <p>The initialized service instance for method chaining.</p> Example <p>service = ObservationService() await service.initialize() print(f\"Connected to DB: {service.db is not None}\")</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService.create_observation","title":"<code>create_observation(observation_data: Observation) -&gt; Observation</code>","text":"<p>Create a new observation record in the database.</p> <p>This method transforms the Pydantic Observation model into the appropriate LanceDB schema format and inserts it into the observations table. It handles JSON serialization for complex fields like metadata and data_source.</p> <p>Parameters:</p> Name Type Description Default <code>observation_data</code> <code>Observation</code> <p>The observation data to store in the database.</p> required <p>Returns:</p> Name Type Description <code>Observation</code> <code>Observation</code> <p>The same observation data that was passed in, confirming successful storage.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there's an error saving the observation to the database, an HTTP 500 error is raised with details about the failure.</p> Example <p>from backend.schemas.observation_schemas import Observation, Location obs = Observation( ...     id=\"obs_001\", ...     species_scientific_name=\"Aedes aegypti\", ...     location=Location(lat=40.7128, lng=-74.0060), ...     observed_at=\"2023-06-15T10:30:00Z\" ... ) result = await service.create_observation(obs)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService.get_observations","title":"<code>get_observations(user_id: str | None = None, species_id: str | None = None, limit: int = 100, offset: int = 0) -&gt; ObservationListResponse</code>","text":"<p>Retrieve observations with optional filtering by user and species.</p> <p>This method queries the observations table and returns filtered results based on user ID and/or species. It supports pagination and returns properly formatted Observation objects.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str | None</code> <p>Filter observations by a specific user ID. If None or \"default_user_id\", no user filtering is applied.</p> <code>None</code> <code>species_id</code> <code>str | None</code> <p>Filter observations by species scientific name. If None, no species filtering is applied.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of observations to return. Defaults to 100.</p> <code>100</code> <code>offset</code> <code>int</code> <p>Number of observations to skip for pagination. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>ObservationListResponse</code> <code>ObservationListResponse</code> <p>A response object containing the total count and list of matching observations.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there's an error retrieving observations from the database, an HTTP 500 error is raised with details about the failure.</p> Example"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService.get_observations--get-recent-observations-for-a-specific-user","title":"Get recent observations for a specific user","text":"<p>user_obs = await service.get_observations(user_id=\"user123\", limit=50) print(f\"Found {user_obs.count} observations\")</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationService.get_observations--get-aedes-aegypti-observations-with-pagination","title":"Get Aedes aegypti observations with pagination","text":"<p>aedes_obs = await service.get_observations( ...     species_id=\"Aedes aegypti\", ...     limit=20, ...     offset=40 ... )</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.Location","title":"<code>Location</code>","text":"<p>Geographic location model.</p> <p>Represents latitude and longitude coordinates for observations.</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.Location.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.Observation","title":"<code>Observation</code>","text":"<p>Complete observation model with unique identifier.</p> <p>Extends ObservationBase with system-generated fields for storing complete observation records.</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.Observation.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationListResponse","title":"<code>ObservationListResponse</code>","text":"<p>Response model for paginated observation lists.</p> <p>Contains the total count and list of observations for API responses.</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.ObservationListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.get_observation_service","title":"<code>get_observation_service()</code>  <code>async</code>","text":"<p>Get or initialize the global observation service instance.</p> <p>This function implements a singleton pattern for the ObservationService, ensuring that only one instance exists and is properly initialized. If the service hasn't been created yet, it creates a new instance and initializes it.</p> <p>Returns:</p> Name Type Description <code>ObservationService</code> <p>The global observation service instance, initialized and ready for use.</p> Example <p>service = await get_observation_service() observations = await service.get_observations(limit=10)</p>"},{"location":"developer-guide/api-reference/observation/#backend.services.observation_service.get_lancedb_manager","title":"<code>get_lancedb_manager() -&gt; LanceDBManager</code>  <code>async</code>","text":"<p>Get the global LanceDB manager instance.</p> <p>This function returns the singleton LanceDB manager instance, ensuring it's connected before returning.</p> <p>Returns:</p> Type Description <code>LanceDBManager</code> <p>The connected LanceDB manager instance.</p>"},{"location":"developer-guide/api-reference/observation/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/observation/#create-new-observation","title":"Create New Observation","text":"<pre><code>import httpx\nfrom datetime import datetime\n\nasync with httpx.AsyncClient() as client:\n    observation_data = {\n        \"species_id\": \"aedes-aegypti\",\n        \"location\": {\n            \"latitude\": 40.7128,\n            \"longitude\": -74.0060\n        },\n        \"observed_at\": datetime.now().isoformat(),\n        \"observer_name\": \"Dr. Smith\",\n        \"notes\": \"Found in urban area near standing water\"\n    }\n\n    response = await client.post(\n        \"http://localhost:8000/api/v1/observations\",\n        json=observation_data\n    )\n    observation = response.json()\n    print(f\"Created observation ID: {observation['id']}\")\n</code></pre>"},{"location":"developer-guide/api-reference/observation/#retrieve-observations","title":"Retrieve Observations","text":"<pre><code># Get list of observations with filters\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/observations\",\n    params={\n        \"species_id\": \"aedes-aegypti\",\n        \"start_date\": \"2024-01-01\",\n        \"end_date\": \"2024-12-31\",\n        \"limit\": 50\n    }\n)\nobservations = response.json()\n\n# Get specific observation details\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/observations/12345\"\n)\nobservation_detail = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/observation/#update-observation","title":"Update Observation","text":"<pre><code># Update existing observation\nupdate_data = {\n    \"notes\": \"Updated notes with additional details\",\n    \"verified\": True\n}\n\nresponse = await client.patch(\n    \"http://localhost:8000/api/v1/observations/12345\",\n    json=update_data\n)\nupdated_observation = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/","title":"OpenAPI Integration","text":"<p>The CulicidaeLab Server automatically generates comprehensive OpenAPI documentation using FastAPI's built-in capabilities.</p>"},{"location":"developer-guide/api-reference/openapi/#interactive-documentation","title":"Interactive Documentation","text":"<p>FastAPI provides two interactive documentation interfaces out of the box:</p>"},{"location":"developer-guide/api-reference/openapi/#swagger-ui","title":"Swagger UI","text":"<p>Access the Swagger UI at: http://localhost:8000/docs</p> <p>The Swagger UI provides: - Interactive API exploration - Request/response examples - Schema validation - Try-it-out functionality - Authentication testing (when implemented)</p>"},{"location":"developer-guide/api-reference/openapi/#redoc","title":"ReDoc","text":"<p>Access ReDoc at: http://localhost:8000/redoc</p> <p>ReDoc offers: - Clean, readable documentation - Detailed schema information - Code samples in multiple languages - Responsive design for mobile devices</p>"},{"location":"developer-guide/api-reference/openapi/#openapi-specification","title":"OpenAPI Specification","text":""},{"location":"developer-guide/api-reference/openapi/#json-format","title":"JSON Format","text":"<p>The complete OpenAPI specification is available in JSON format: <pre><code>http://localhost:8000/api/v1/openapi.json\n</code></pre></p>"},{"location":"developer-guide/api-reference/openapi/#yaml-format","title":"YAML Format","text":"<p>You can also retrieve the specification in YAML format by adding the Accept header: <pre><code>curl -H \"Accept: application/x-yaml\" http://localhost:8000/api/v1/openapi.json\n</code></pre></p>"},{"location":"developer-guide/api-reference/openapi/#using-the-openapi-specification","title":"Using the OpenAPI Specification","text":""},{"location":"developer-guide/api-reference/openapi/#code-generation","title":"Code Generation","text":"<p>Generate client libraries using the OpenAPI specification:</p>"},{"location":"developer-guide/api-reference/openapi/#python-client-with-openapi-generator","title":"Python Client with openapi-generator","text":"<pre><code># Install openapi-generator\nnpm install @openapitools/openapi-generator-cli -g\n\n# Generate Python client\nopenapi-generator-cli generate \\\n  -i http://localhost:8000/api/v1/openapi.json \\\n  -g python \\\n  -o ./culicidae-client-python \\\n  --package-name culicidae_client\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#javascript-client","title":"JavaScript Client","text":"<pre><code># Generate JavaScript/TypeScript client\nopenapi-generator-cli generate \\\n  -i http://localhost:8000/api/v1/openapi.json \\\n  -g typescript-axios \\\n  -o ./culicidae-client-js\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#api-testing-with-postman","title":"API Testing with Postman","text":"<ol> <li>Import the OpenAPI specification into Postman:</li> <li>Open Postman</li> <li>Click \"Import\"</li> <li>Enter URL: <code>http://localhost:8000/api/v1/openapi.json</code></li> <li> <p>Postman will create a collection with all endpoints</p> </li> <li> <p>Set up environment variables:    <pre><code>{\n  \"base_url\": \"http://localhost:8000\",\n  \"api_version\": \"v1\"\n}\n</code></pre></p> </li> </ol>"},{"location":"developer-guide/api-reference/openapi/#mock-server-creation","title":"Mock Server Creation","text":"<p>Create a mock server using the OpenAPI specification:</p>"},{"location":"developer-guide/api-reference/openapi/#using-prism","title":"Using Prism","text":"<pre><code># Install Prism\nnpm install -g @stoplight/prism-cli\n\n# Start mock server\nprism mock http://localhost:8000/api/v1/openapi.json\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#using-wiremock","title":"Using WireMock","text":"<pre><code># Download WireMock\ncurl -o wiremock.jar https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.35.0/wiremock-jre8-standalone-2.35.0.jar\n\n# Start with OpenAPI\njava -jar wiremock.jar --port 8080 --global-response-templating \\\n  --extensions com.github.tomakehurst.wiremock.extension.responsetemplating.ResponseTemplateTransformer\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#customizing-openapi-documentation","title":"Customizing OpenAPI Documentation","text":""},{"location":"developer-guide/api-reference/openapi/#adding-metadata","title":"Adding Metadata","text":"<p>The OpenAPI documentation can be customized in the main FastAPI application:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI(\n    title=\"CulicidaeLab Server API\",\n    description=\"A sophisticated web platform for mosquito research, surveillance, and data analysis\",\n    version=\"1.0.0\",\n    terms_of_service=\"https://culicidaelab.ru/terms/\",\n    contact={\n        \"name\": \"CulicidaeLab Team\",\n        \"url\": \"https://culicidaelab.ru/contact/\",\n        \"email\": \"culicidaelab@gmail.com\",\n    },\n    license_info={\n        \"name\": \"MIT License\",\n        \"url\": \"https://opensource.org/licenses/MIT\",\n    },\n    openapi_tags=[\n        {\n            \"name\": \"Species\",\n            \"description\": \"Operations with mosquito species data\",\n        },\n        {\n            \"name\": \"Diseases\",\n            \"description\": \"Disease information and vector relationships\",\n        },\n        {\n            \"name\": \"Prediction\",\n            \"description\": \"AI-powered species identification\",\n        },\n    ]\n)\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#adding-examples-to-endpoints","title":"Adding Examples to Endpoints","text":"<p>Enhance endpoint documentation with examples:</p> <pre><code>from fastapi import FastAPI, Query\nfrom pydantic import BaseModel\n\nclass SpeciesResponse(BaseModel):\n    id: str\n    scientific_name: str\n    common_name: str\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"id\": \"aedes-aegypti\",\n                \"scientific_name\": \"Aedes aegypti\",\n                \"common_name\": \"Yellow fever mosquito\"\n            }\n        }\n\n@app.get(\n    \"/species/{species_id}\",\n    response_model=SpeciesResponse,\n    responses={\n        200: {\n            \"description\": \"Species found successfully\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\n                        \"id\": \"aedes-aegypti\",\n                        \"scientific_name\": \"Aedes aegypti\",\n                        \"common_name\": \"Yellow fever mosquito\",\n                        \"vector_status\": \"Primary vector\"\n                    }\n                }\n            }\n        },\n        404: {\n            \"description\": \"Species not found\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\"detail\": \"Species not found\"}\n                }\n            }\n        }\n    }\n)\nasync def get_species(species_id: str):\n    pass\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#swagger-ui-customization","title":"Swagger UI Customization","text":""},{"location":"developer-guide/api-reference/openapi/#custom-css-and-javascript","title":"Custom CSS and JavaScript","text":"<p>Add custom styling to Swagger UI by serving custom files:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.openapi.docs import get_swagger_ui_html\nfrom fastapi.staticfiles import StaticFiles\n\napp = FastAPI(docs_url=None)  # Disable default docs\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n@app.get(\"/docs\", include_in_schema=False)\nasync def custom_swagger_ui_html():\n    return get_swagger_ui_html(\n        openapi_url=app.openapi_url,\n        title=app.title + \" - Swagger UI\",\n        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,\n        swagger_js_url=\"/static/swagger-ui-bundle.js\",\n        swagger_css_url=\"/static/swagger-ui.css\",\n        swagger_ui_parameters={\"defaultModelsExpandDepth\": -1}\n    )\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#integration-with-mkdocs","title":"Integration with MkDocs","text":""},{"location":"developer-guide/api-reference/openapi/#embedding-swagger-ui","title":"Embedding Swagger UI","text":"<p>You can embed the Swagger UI directly in MkDocs documentation:</p> <pre><code># API Documentation\n\n&lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n\n&lt;script src=\"https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui-bundle.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nSwaggerUIBundle({\n  url: 'http://localhost:8000/api/v1/openapi.json',\n  dom_id: '#swagger-ui',\n  presets: [\n    SwaggerUIBundle.presets.apis,\n    SwaggerUIBundle.presets.standalone\n  ]\n});\n&lt;/script&gt;\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#using-swagger-ui-tag-plugin","title":"Using swagger-ui-tag Plugin","text":"<p>The <code>swagger-ui-tag</code> plugin allows embedding Swagger UI with a simple tag:</p> <pre><code># API Documentation\n\n{% swagger_ui %}\nhttp://localhost:8000/api/v1/openapi.json\n{% endswagger_ui %}\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"developer-guide/api-reference/openapi/#schema-validation","title":"Schema Validation","text":"<p>Use the OpenAPI specification for request/response validation:</p> <pre><code>import requests\nfrom openapi_spec_validator import validate_spec\nfrom openapi_spec_validator.readers import read_from_filename\n\n# Validate the OpenAPI specification\nspec_dict = requests.get('http://localhost:8000/api/v1/openapi.json').json()\nvalidate_spec(spec_dict)\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#automated-testing","title":"Automated Testing","text":"<p>Generate test cases from the OpenAPI specification:</p> <pre><code>import schemathesis\n\nschema = schemathesis.from_uri(\"http://localhost:8000/api/v1/openapi.json\")\n\n@schema.parametrize()\ndef test_api(case):\n    case.call_and_validate()\n</code></pre>"},{"location":"developer-guide/api-reference/openapi/#best-practices","title":"Best Practices","text":""},{"location":"developer-guide/api-reference/openapi/#documentation-guidelines","title":"Documentation Guidelines","text":"<ol> <li>Comprehensive Docstrings: Write detailed docstrings for all endpoints</li> <li>Response Examples: Provide realistic examples for all responses</li> <li>Error Documentation: Document all possible error conditions</li> <li>Schema Descriptions: Add descriptions to all Pydantic model fields</li> <li>Tags and Organization: Use tags to organize endpoints logically</li> </ol>"},{"location":"developer-guide/api-reference/openapi/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Caching: Cache the OpenAPI specification for production</li> <li>Compression: Enable gzip compression for the specification</li> <li>CDN: Serve Swagger UI assets from a CDN</li> <li>Lazy Loading: Load documentation on demand</li> </ol>"},{"location":"developer-guide/api-reference/openapi/#security","title":"Security","text":"<ol> <li>Sensitive Data: Never expose sensitive information in examples</li> <li>Authentication: Document authentication requirements clearly</li> <li>Rate Limiting: Document rate limiting policies</li> <li>CORS: Configure CORS appropriately for documentation access</li> </ol>"},{"location":"developer-guide/api-reference/prediction/","title":"Prediction API","text":"<p>The Prediction API provides machine learning-based species identification and prediction services for mosquito classification.</p>"},{"location":"developer-guide/api-reference/prediction/#router-implementation","title":"Router Implementation","text":"<p>Prediction router for mosquito species identification.</p> <p>This module provides FastAPI endpoints for predicting mosquito species from uploaded images using AI-powered classification. The router handles image validation, coordinates with the prediction service, and returns structured results.</p> Main Components <ul> <li>APIRouter instance configured for prediction endpoints</li> <li>predict_species endpoint for species identification</li> </ul> The prediction system supports <ul> <li>Multiple image formats (JPEG, PNG, etc.)</li> <li>Real-time species identification with confidence scores</li> <li>Optional image saving for predicted results</li> <li>Comprehensive error handling and logging</li> </ul> Example <p>from fastapi import FastAPI from backend.routers.prediction import router</p> <p>app = FastAPI() app.include_router(router, prefix=\"/api/v1\")</p>"},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction--now-available-at-post-apiv1predict","title":"Now available at POST /api/v1/predict","text":""},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.prediction_service","title":"<code>prediction_service = &lt;backend.services.prediction_service.PredictionService object at 0x00000274A9218790&gt;</code>  <code>module-attribute</code>","text":"<p>Service for mosquito species prediction using the CulicidaeLab <code>serve</code> API.</p> <p>This class provides a high-level interface for species identification from images. It is optimized for production use, leveraging an efficient inference backend with automatic model caching to ensure low latency.</p> <p>Attributes:</p> Name Type Description <code>save_predicted_images_enabled</code> <code>bool</code> <p>Whether to save predicted images.</p> <code>model_id</code> <code>str</code> <p>The identifier for the machine learning model being used.</p> Example <p>service = PredictionService() result, error = await service.predict_species(image_data, \"test.jpg\")</p>"},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.PredictionResult","title":"<code>PredictionResult</code>","text":"<p>Model for prediction results.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.PredictionResult.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.predict_species","title":"<code>predict_species(file: UploadFile = File(PydanticUndefined)) -&gt; PredictionResult</code>  <code>async</code>","text":"<p>Predict mosquito species from an uploaded image.</p> <p>This endpoint accepts an image file and uses AI-powered classification to identify the mosquito species. The prediction includes confidence scores and optional species information.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>UploadFile</code> <p>The image file to analyze. Must be a valid image format (JPEG, PNG, etc.). The file is validated for content type and non-empty content.</p> <code>File(PydanticUndefined)</code> <p>Returns:</p> Name Type Description <code>PredictionResult</code> <code>PredictionResult</code> <p>A structured response containing: - id: Species identifier (lowercase with underscores) - scientific_name: The predicted species name - probabilities: Dictionary of species -&gt; confidence scores - model_id: Identifier of the AI model used - confidence: Confidence score of the top prediction - image_url_species: URL to processed image (if saving enabled)</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the file is not an image (400 Bad Request)</p> <code>HTTPException</code> <p>If the file is empty (400 Bad Request)</p> <code>HTTPException</code> <p>If prediction fails (500 Internal Server Error)</p> Example <p>import requests</p> Source code in <code>backend\\routers\\prediction.py</code> <pre><code>@router.post(\n    \"/predict\",\n    response_model=PredictionResult,\n    summary=\"Predict mosquito species from image\",\n    description=\"Upload an image of a mosquito to identify its species using AI.\",\n)\nasync def predict_species(\n    file: UploadFile = File(...),\n) -&gt; PredictionResult:\n    \"\"\"Predict mosquito species from an uploaded image.\n\n    This endpoint accepts an image file and uses AI-powered classification\n    to identify the mosquito species. The prediction includes confidence scores\n    and optional species information.\n\n    Args:\n        file (UploadFile): The image file to analyze. Must be a valid image\n            format (JPEG, PNG, etc.). The file is validated for content type\n            and non-empty content.\n\n    Returns:\n        PredictionResult: A structured response containing:\n            - id: Species identifier (lowercase with underscores)\n            - scientific_name: The predicted species name\n            - probabilities: Dictionary of species -&gt; confidence scores\n            - model_id: Identifier of the AI model used\n            - confidence: Confidence score of the top prediction\n            - image_url_species: URL to processed image (if saving enabled)\n\n    Raises:\n        HTTPException: If the file is not an image (400 Bad Request)\n        HTTPException: If the file is empty (400 Bad Request)\n        HTTPException: If prediction fails (500 Internal Server Error)\n\n    Example:\n        &gt;&gt;&gt; import requests\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using curl command:\n        &gt;&gt;&gt; # curl -X POST \"http://localhost:8000/predict\" \\\n        &gt;&gt;&gt; #      -H \"accept: application/json\" \\\n        &gt;&gt;&gt; #      -H \"Content-Type: multipart/form-data\" \\\n        &gt;&gt;&gt; #      -F \"file=@mosquito_image.jpg\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using Python requests:\n        &gt;&gt;&gt; response = requests.post(\n        ...     \"http://localhost:8000/predict\",\n        ...     files={\"file\": open(\"mosquito_image.jpg\", \"rb\")}\n        ... )\n        &gt;&gt;&gt; result = response.json()\n        &gt;&gt;&gt; print(f\"Predicted species: {result['scientific_name']}\")\n        &gt;&gt;&gt; print(f\"Confidence: {result['confidence']:.2%}\")\n    \"\"\"\n    print(\"\\n--- [ROUTER] Received request for /predict ---\")\n    try:\n        content_type = file.content_type\n        print(f\"[ROUTER] File received. Filename: '{file.filename}', Content-Type: '{content_type}'\")\n\n        if not content_type or not content_type.startswith(\"image/\"):\n            print(\"[ROUTER] ERROR: Invalid content type. Raising 400 Bad Request.\")\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"File must be an image, got {content_type}\",\n            )\n\n        print(\"[ROUTER] Reading file contents...\")\n        contents = await file.read()\n        if not contents:\n            print(\"[ROUTER] ERROR: Empty file uploaded. Raising 400 Bad Request.\")\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Empty file\")\n\n        print(\"[ROUTER] File contents read ({len(contents)} bytes). Calling prediction_service...\")\n        result, error = await prediction_service.predict_species(contents, file.filename)\n        print(\"[ROUTER] Prediction service returned. Result: {result is not None}, Error: '{error}'\")\n\n        if error:\n            print(\"[ROUTER] ERROR: Prediction service returned an error. Raising 500 Internal Server Error.\")\n            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f\"Prediction failed: {error}\")\n\n        if not result:\n            print(\"[ROUTER] ERROR: Prediction service returned no result and no error. Raising 500.\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Prediction failed with no specific error\",\n            )\n\n        print(f\"[ROUTER] Prediction successful. Returning result for '{result.scientific_name}'.\")\n        return result\n\n    except HTTPException as http_exc:\n        # Re-raise HTTPExceptions to let FastAPI handle them\n        print(f\"[ROUTER] Caught HTTPException: {http_exc.status_code} - {http_exc.detail}\")\n        raise\n    except Exception as e:\n        # Catch any other unexpected errors\n        print(f\"[ROUTER] CRITICAL ERROR in /predict: {type(e).__name__} - {str(e)}\")\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f\"Prediction failed: {str(e)}\")\n</code></pre>"},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.predict_species--using-curl-command","title":"Using curl command:","text":""},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.predict_species--curl-x-post-httplocalhost8000predict-h-accept-applicationjson-h-content-type-multipartform-data-f-filemosquito_imagejpg","title":"curl -X POST \"http://localhost:8000/predict\"         &gt;&gt;&gt; #      -H \"accept: application/json\"         &gt;&gt;&gt; #      -H \"Content-Type: multipart/form-data\"         &gt;&gt;&gt; #      -F \"file=@mosquito_image.jpg\"","text":""},{"location":"developer-guide/api-reference/prediction/#backend.routers.prediction.predict_species--using-python-requests","title":"Using Python requests:","text":"<p>response = requests.post( ...     \"http://localhost:8000/predict\", ...     files={\"file\": open(\"mosquito_image.jpg\", \"rb\")} ... ) result = response.json() print(f\"Predicted species: {result['scientific_name']}\") print(f\"Confidence: {result['confidence']:.2%}\")</p>"},{"location":"developer-guide/api-reference/prediction/#data-schemas","title":"Data Schemas","text":"<p>The Prediction API uses Pydantic schemas for prediction request/response validation:</p>"},{"location":"developer-guide/api-reference/prediction/#backend.schemas.prediction_schemas","title":"<code>backend.schemas.prediction_schemas</code>","text":"<p>Pydantic models for the Prediction service.</p> <p>This module defines the schema models used for prediction results and model validation in API endpoints.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.schemas.prediction_schemas.annotations","title":"<code>annotations = _Feature((3, 7, 0, 'beta', 1), None, 16777216)</code>  <code>module-attribute</code>","text":""},{"location":"developer-guide/api-reference/prediction/#backend.schemas.prediction_schemas.PredictionResult","title":"<code>PredictionResult</code>","text":"<p>Model for prediction results.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.schemas.prediction_schemas.PredictionResult.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/prediction/#service-layer","title":"Service Layer","text":"<p>The Prediction API integrates with machine learning service layers:</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service","title":"<code>backend.services.prediction_service</code>","text":"<p>Machine learning prediction service for mosquito species identification.</p> <p>This module provides functionality for predicting mosquito species from images using a trained MosquitoClassifier model. It handles model loading, image processing, and prediction with confidence scoring and species identification.</p> Example <p>from backend.services.prediction_service import prediction_service result, error = await prediction_service.predict_species(image_data, \"mosquito.jpg\") if result: ...     print(f\"Predicted species: {result.scientific_name}\")</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.annotations","title":"<code>annotations = _Feature((3, 7, 0, 'beta', 1), None, 16777216)</code>  <code>module-attribute</code>","text":""},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.app_settings","title":"<code>app_settings = AppSettings(APP_NAME='CulicidaeLab API', API_V1_STR='/api', DATABASE_PATH='backend/data/.lancedb', SAVE_PREDICTED_IMAGES='1', BACKEND_CORS_ORIGINS=['http://localhost:8765', 'http://127.0.0.1:8765'])</code>  <code>module-attribute</code>","text":"<p>Application settings configuration for CulicidaeLab API backend.</p> <p>This class defines all configuration parameters for the CulicidaeLab API server, using Pydantic BaseSettings for environment variable support and validation. Settings can be overridden via environment variables with the CULICIDAELAB_ prefix.</p> <p>Attributes:</p> Name Type Description <code>APP_NAME</code> <code>str</code> <p>Name of the application displayed in API documentation.</p> <code>API_V1_STR</code> <code>str</code> <p>Base path prefix for API version 1 endpoints.</p> <code>DATABASE_PATH</code> <code>str</code> <p>File system path to the LanceDB database directory.</p> <code>SAVE_PREDICTED_IMAGES</code> <code>str | bool</code> <p>Whether to save predicted images to disk.</p> <code>BACKEND_CORS_ORIGINS</code> <code>list[str]</code> <p>List of allowed CORS origins for frontend access.</p> Example <p>settings = AppSettings() print(f\"App name: {settings.APP_NAME}\") App name: CulicidaeLab API print(f\"Database path: {settings.DATABASE_PATH}\") Database path: .lancedb</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.prediction_service","title":"<code>prediction_service = &lt;backend.services.prediction_service.PredictionService object at 0x00000274A9218790&gt;</code>  <code>module-attribute</code>","text":"<p>Service for mosquito species prediction using the CulicidaeLab <code>serve</code> API.</p> <p>This class provides a high-level interface for species identification from images. It is optimized for production use, leveraging an efficient inference backend with automatic model caching to ensure low latency.</p> <p>Attributes:</p> Name Type Description <code>save_predicted_images_enabled</code> <code>bool</code> <p>Whether to save predicted images.</p> <code>model_id</code> <code>str</code> <p>The identifier for the machine learning model being used.</p> Example <p>service = PredictionService() result, error = await service.predict_species(image_data, \"test.jpg\")</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.PredictionService","title":"<code>PredictionService()</code>","text":"<p>Service for mosquito species prediction using the CulicidaeLab <code>serve</code> API.</p> <p>This class provides a high-level interface for species identification from images. It is optimized for production use, leveraging an efficient inference backend with automatic model caching to ensure low latency.</p> <p>Attributes:</p> Name Type Description <code>save_predicted_images_enabled</code> <code>bool</code> <p>Whether to save predicted images.</p> <code>model_id</code> <code>str</code> <p>The identifier for the machine learning model being used.</p> Example <p>service = PredictionService() result, error = await service.predict_species(image_data, \"test.jpg\")</p> <p>Initialize the PredictionService and retrieve the model configuration.</p> <p>Sets up the service based on application settings and fetches the model architecture information from the CulicidaeLab library settings to generate a descriptive model ID.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.PredictionService.save_predicted_image","title":"<code>save_predicted_image(image_data: bytes, filename: str, quiet: bool = True)</code>","text":"<p>Asynchronously save the predicted image in multiple sizes.</p> <p>This method saves the original image along with resized versions (224x224 and 100x100) to the static images directory. Failures are handled silently to not disrupt the prediction flow unless quiet mode is disabled.</p> <p>Parameters:</p> Name Type Description Default <code>image_data</code> <code>bytes</code> <p>The raw image data to save.</p> required <code>filename</code> <code>str</code> <p>The filename to use for the saved images.</p> required <code>quiet</code> <code>bool</code> <p>If False, exceptions will be raised instead of being handled silently. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If quiet=False and an error occurs during image saving, the original exception is re-raised.</p> Example <p>service = PredictionService() await service.save_predicted_image(image_bytes, \"mosquito_001.jpg\")</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.PredictionService.predict_species","title":"<code>predict_species(image_data: bytes, filename: str) -&gt; tuple[PredictionResult | None, str | None]</code>","text":"<p>Predict mosquito species from image data using the <code>serve</code> API.</p> <p>This method processes image data using the high-performance <code>serve</code> function. It translates the library's output into the backend's <code>PredictionResult</code> schema, including the correct model ID.</p> <p>Parameters:</p> Name Type Description Default <code>image_data</code> <code>bytes</code> <p>The raw image data (e.g., JPEG, PNG).</p> required <code>filename</code> <code>str</code> <p>The original filename of the image.</p> required <p>Returns:</p> Type Description <code>PredictionResult | None</code> <p>A tuple containing the <code>PredictionResult</code> or None, and an error</p> <code>str | None</code> <p>message or None.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.PredictionResult","title":"<code>PredictionResult</code>","text":"<p>Model for prediction results.</p>"},{"location":"developer-guide/api-reference/prediction/#backend.services.prediction_service.PredictionResult.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/prediction/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/prediction/#species-prediction","title":"Species Prediction","text":"<pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    # Upload image for species prediction\n    with open(\"mosquito_image.jpg\", \"rb\") as image_file:\n        files = {\"image\": image_file}\n        response = await client.post(\n            \"http://localhost:8000/api/v1/predict\",\n            files=files,\n            data={\"confidence_threshold\": 0.7}\n        )\n        prediction = response.json()\n\n    print(f\"Predicted species: {prediction['species']}\")\n    print(f\"Confidence: {prediction['confidence']}\")\n</code></pre>"},{"location":"developer-guide/api-reference/species/","title":"Species API","text":"<p>The Species API provides comprehensive endpoints for retrieving mosquito species information, including species lists, detailed species data, and disease vector information.</p>"},{"location":"developer-guide/api-reference/species/#endpoints-overview","title":"Endpoints Overview","text":"Method Endpoint Description GET <code>/species</code> Retrieve paginated list of species with optional search GET <code>/species/{species_id}</code> Get detailed information for a specific species GET <code>/vector-species</code> Retrieve species that are disease vectors"},{"location":"developer-guide/api-reference/species/#router-implementation","title":"Router Implementation","text":"<p>Species router module for the Culicidae Lab Server.</p> <p>This module provides FastAPI route handlers for mosquito species-related operations in the Culicidae Lab application. It handles retrieval of species information, including species lists, detailed species information, and disease vector species.</p> <p>The router integrates with the species service layer to perform database queries and return properly formatted responses according to the defined Pydantic schemas.</p> Routes <ul> <li>GET /species: Retrieve a paginated list of mosquito species with optional search</li> <li>GET /species/{species_id}: Retrieve detailed information for a specific species</li> <li>GET /vector-species: Retrieve species that are known disease vectors</li> </ul> Example <p>The router is typically mounted in the main FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom backend.routers.species import router as species_router\n\napp = FastAPI()\napp.include_router(species_router, prefix=\"/api/v1\")\n</code></pre>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesBase","title":"<code>SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesDetail","title":"<code>SpeciesDetail</code>","text":"<p>Detailed species model with extended information.</p> <p>Extends the base species model with additional descriptive fields for comprehensive species information.</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesDetail.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesListResponse","title":"<code>SpeciesListResponse</code>","text":"<p>Response model for paginated species lists.</p> <p>Contains the total count and list of species for API responses.</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.SpeciesListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.get_species_list_endpoint","title":"<code>get_species_list_endpoint(request: Request, db: DBConnection = Depends(get_db), search: str | None = Query(None), limit: int = Query(50), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve a list of mosquito species, optionally filtered by a search term.</p> <p>This endpoint allows clients to fetch a paginated list of mosquito species from the database. The search functionality supports partial matching against scientific names and common names in English and Russian.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>search</code> <code>str | None</code> <p>Optional search term to filter species by name. Supports partial matching against scientific names and common names in multiple languages.</p> <code>Query(None)</code> <code>limit</code> <code>int</code> <p>Maximum number of species to return (1-200). Defaults to 50.</p> <code>Query(50)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>SpeciesListResponse</code> <p>A response containing the count of species and the list of species matching the criteria.</p> Example <p>Get the first 25 mosquito species in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/species\",\n        params={\"limit\": 25, \"lang\": \"en\"}\n    )\n    species_data = response.json()\n    print(f\"Found {species_data['count']} species\")\n</code></pre> <p>Search for species containing \"aedes\":</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species\",\n    params={\"search\": \"aedes\", \"limit\": 10, \"lang\": \"en\"}\n)\n</code></pre> Source code in <code>backend\\routers\\species.py</code> <pre><code>@router.get(\"/species\", response_model=SpeciesListResponse)\nasync def get_species_list_endpoint(\n    request: Request,\n    db: lancedb.DBConnection = Depends(database.get_db),\n    search: str | None = Query(None, description=\"Search term for species name\"),\n    limit: int = Query(50, ge=1, le=200, description=\"Number of results to return\"),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve a list of mosquito species, optionally filtered by a search term.\n\n    This endpoint allows clients to fetch a paginated list of mosquito species\n    from the database. The search functionality supports partial matching against\n    scientific names and common names in English and Russian.\n\n    Args:\n        request: The FastAPI request object used for URL construction.\n        db: LanceDB database connection for querying species data.\n        search: Optional search term to filter species by name. Supports partial\n            matching against scientific names and common names in multiple languages.\n        limit: Maximum number of species to return (1-200). Defaults to 50.\n        lang: Language code for response localization (e.g., 'en', 'es', 'ru').\n\n    Returns:\n        SpeciesListResponse: A response containing the count of species and the\n            list of species matching the criteria.\n\n    Raises:\n        No exceptions are raised directly by this endpoint, but database errors\n        may be logged and an empty result returned.\n\n    Example:\n        Get the first 25 mosquito species in English:\n\n        ```python\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"http://localhost:8000/api/v1/species\",\n                params={\"limit\": 25, \"lang\": \"en\"}\n            )\n            species_data = response.json()\n            print(f\"Found {species_data['count']} species\")\n        ```\n\n        Search for species containing \"aedes\":\n\n        ```python\n        response = await client.get(\n            \"http://localhost:8000/api/v1/species\",\n            params={\"search\": \"aedes\", \"limit\": 10, \"lang\": \"en\"}\n        )\n        ```\n    \"\"\"\n    species_list = species_service.get_all_species(db, request, lang=lang, search=search, limit=limit)\n    return SpeciesListResponse(count=len(species_list), species=species_list)\n</code></pre>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.get_species_detail_endpoint","title":"<code>get_species_detail_endpoint(species_id: str, request: Request, region_cache: dict[str, dict[str, str]] = Depends(get_region_cache), db: DBConnection = Depends(get_db), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve detailed information for a specific mosquito species by ID.</p> <p>This endpoint fetches comprehensive information about a single mosquito species including its scientific name, common names in multiple languages, vector status, habitat preferences, geographic regions, and associated diseases. The response includes translated content based on the requested language.</p> <p>Parameters:</p> Name Type Description Default <code>species_id</code> <code>str</code> <p>The unique identifier for the species (e.g., 'aedes-aegypti').</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>region_cache</code> <code>dict[str, dict[str, str]]</code> <p>Pre-loaded cache of region translations for localization.</p> <code>Depends(get_region_cache)</code> <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Name Type Description <code>SpeciesDetail</code> <p>Detailed information about the requested species including scientific name, common names, descriptions, characteristics, habitat preferences, geographic regions, and related diseases.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the species with the given ID is not found, returns a 404 status code with detail message \"Species not found\".</p> Example <p>Get detailed information for Aedes aegypti in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/species/aedes-aegypti\",\n        params={\"lang\": \"en\"}\n    )\n    if response.status_code == 200:\n        species = response.json()\n        print(f\"Species: {species['scientific_name']}\")\n        print(f\"Common name: {species['common_name']}\")\n        print(f\"Vector status: {species['vector_status']}\")\n    else:\n        print(\"Species not found\")\n</code></pre> <p>Get species information in Spanish:</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species/anopheles-gambiae\",\n    params={\"lang\": \"es\"}\n)\n</code></pre> Source code in <code>backend\\routers\\species.py</code> <pre><code>@router.get(\"/species/{species_id}\", response_model=SpeciesDetail)\nasync def get_species_detail_endpoint(\n    species_id: str,\n    request: Request,\n    region_cache: dict[str, dict[str, str]] = Depends(get_region_cache),\n    db: lancedb.DBConnection = Depends(database.get_db),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve detailed information for a specific mosquito species by ID.\n\n    This endpoint fetches comprehensive information about a single mosquito species\n    including its scientific name, common names in multiple languages, vector status,\n    habitat preferences, geographic regions, and associated diseases. The response\n    includes translated content based on the requested language.\n\n    Args:\n        species_id: The unique identifier for the species (e.g., 'aedes-aegypti').\n        request: The FastAPI request object used for URL construction.\n        region_cache: Pre-loaded cache of region translations for localization.\n        db: LanceDB database connection for querying species data.\n        lang: Language code for response localization (e.g., 'en', 'es', 'ru').\n\n    Returns:\n        SpeciesDetail: Detailed information about the requested species including\n            scientific name, common names, descriptions, characteristics, habitat\n            preferences, geographic regions, and related diseases.\n\n    Raises:\n        HTTPException: If the species with the given ID is not found, returns a\n            404 status code with detail message \"Species not found\".\n\n    Example:\n        Get detailed information for Aedes aegypti in English:\n\n        ```python\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"http://localhost:8000/api/v1/species/aedes-aegypti\",\n                params={\"lang\": \"en\"}\n            )\n            if response.status_code == 200:\n                species = response.json()\n                print(f\"Species: {species['scientific_name']}\")\n                print(f\"Common name: {species['common_name']}\")\n                print(f\"Vector status: {species['vector_status']}\")\n            else:\n                print(\"Species not found\")\n        ```\n\n        Get species information in Spanish:\n\n        ```python\n        response = await client.get(\n            \"http://localhost:8000/api/v1/species/anopheles-gambiae\",\n            params={\"lang\": \"es\"}\n        )\n        ```\n    \"\"\"\n    species_detail = species_service.get_species_by_id(db, species_id, lang, region_cache, request)\n    if not species_detail:\n        raise HTTPException(status_code=404, detail=\"Species not found\")\n    return species_detail\n</code></pre>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.get_vector_species_endpoint","title":"<code>get_vector_species_endpoint(request: Request, db: DBConnection = Depends(get_db), disease_id: str | None = Query(None), lang: str = Query(en))</code>  <code>async</code>","text":"<p>Retrieve mosquito species that are disease vectors, optionally filtered by disease.</p> <p>This endpoint returns a list of mosquito species known to be vectors for various diseases. When a specific disease ID is provided, only species that are vectors for that particular disease are returned. Without a disease filter, all species marked as vectors (excluding 'None' and 'Unknown' status) are returned.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object used for URL construction.</p> required <code>db</code> <code>DBConnection</code> <p>LanceDB database connection for querying species data.</p> <code>Depends(get_db)</code> <code>disease_id</code> <code>str | None</code> <p>Optional specific disease ID to filter vectors. If provided, only species that are vectors for this disease will be returned.</p> <code>Query(None)</code> <code>lang</code> <code>str</code> <p>Language code for response localization (e.g., 'en', 'es', 'ru').</p> <code>Query(en)</code> <p>Returns:</p> Type Description <p>list[SpeciesBase]: A list of mosquito species that are disease vectors, filtered by the specified criteria.</p> Example <p>Get all mosquito species that are disease vectors in English:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/vector-species\",\n        params={\"lang\": \"en\"}\n    )\n    vector_species = response.json()\n    print(f\"Found {len(vector_species)} vector species\")\n    for species in vector_species:\n        print(f\"- {species['scientific_name']}: {species['vector_status']}\")\n</code></pre> <p>Get only species that are vectors for malaria:</p> <pre><code># First, you'd need to know the disease ID for malaria\nresponse = await client.get(\n    \"http://localhost:8000/api/v1/vector-species\",\n    params={\"disease_id\": \"malaria\", \"lang\": \"en\"}\n)\nmalaria_vectors = response.json()\n</code></pre> <p>Get vector species in Russian:</p> <pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/vector-species\",\n    params={\"lang\": \"ru\"}\n)\n</code></pre> Source code in <code>backend\\routers\\species.py</code> <pre><code>@router.get(\"/vector-species\", response_model=list[SpeciesBase])\nasync def get_vector_species_endpoint(\n    request: Request,\n    db: lancedb.DBConnection = Depends(database.get_db),\n    disease_id: str | None = Query(None, description=\"Filter vectors by disease ID\"),\n    lang: str = Query(\"en\", description=\"Language code for response (e.g., 'en', 'es')\"),\n):\n    \"\"\"\n    Retrieve mosquito species that are disease vectors, optionally filtered by disease.\n\n    This endpoint returns a list of mosquito species known to be vectors for various\n    diseases. When a specific disease ID is provided, only species that are vectors\n    for that particular disease are returned. Without a disease filter, all species\n    marked as vectors (excluding 'None' and 'Unknown' status) are returned.\n\n    Args:\n        request: The FastAPI request object used for URL construction.\n        db: LanceDB database connection for querying species data.\n        disease_id: Optional specific disease ID to filter vectors. If provided,\n            only species that are vectors for this disease will be returned.\n        lang: Language code for response localization (e.g., 'en', 'es', 'ru').\n\n    Returns:\n        list[SpeciesBase]: A list of mosquito species that are disease vectors,\n            filtered by the specified criteria.\n\n    Raises:\n        No exceptions are raised directly by this endpoint, but database errors\n        may be logged and an empty result returned.\n\n    Example:\n        Get all mosquito species that are disease vectors in English:\n\n        ```python\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"http://localhost:8000/api/v1/vector-species\",\n                params={\"lang\": \"en\"}\n            )\n            vector_species = response.json()\n            print(f\"Found {len(vector_species)} vector species\")\n            for species in vector_species:\n                print(f\"- {species['scientific_name']}: {species['vector_status']}\")\n        ```\n\n        Get only species that are vectors for malaria:\n\n        ```python\n        # First, you'd need to know the disease ID for malaria\n        response = await client.get(\n            \"http://localhost:8000/api/v1/vector-species\",\n            params={\"disease_id\": \"malaria\", \"lang\": \"en\"}\n        )\n        malaria_vectors = response.json()\n        ```\n\n        Get vector species in Russian:\n\n        ```python\n        response = await client.get(\n            \"http://localhost:8000/api/v1/vector-species\",\n            params={\"lang\": \"ru\"}\n        )\n        ```\n    \"\"\"\n    vector_species = species_service.get_vector_species(db, request, lang=lang, disease_id=disease_id)\n    return vector_species\n</code></pre>"},{"location":"developer-guide/api-reference/species/#backend.routers.species.get_region_cache","title":"<code>get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]</code>","text":"<p>Dependency for the regions translation cache.</p> <p>Provides access to the cached region translations data, which maps region codes to translated names in multiple languages.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The FastAPI request object containing app state.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>dict[str, dict[str, str]]: Dictionary mapping language codes to region translation dictionaries.</p> Example <p>@app.get(\"/regions/{language}\") async def get_regions_by_language(     regions: dict = Depends(get_region_cache),     language: str = \"en\" ):     return regions.get(language, {})</p> Source code in <code>backend\\dependencies.py</code> <pre><code>def get_region_cache(request: Request) -&gt; dict[str, dict[str, str]]:\n    \"\"\"Dependency for the regions translation cache.\n\n    Provides access to the cached region translations data, which maps\n    region codes to translated names in multiple languages.\n\n    Args:\n        request (Request): The FastAPI request object containing app state.\n\n    Returns:\n        dict[str, dict[str, str]]: Dictionary mapping language codes to region\n            translation dictionaries.\n\n    Example:\n        &gt;&gt;&gt; @app.get(\"/regions/{language}\")\n        &gt;&gt;&gt; async def get_regions_by_language(\n        &gt;&gt;&gt;     regions: dict = Depends(get_region_cache),\n        &gt;&gt;&gt;     language: str = \"en\"\n        &gt;&gt;&gt; ):\n        &gt;&gt;&gt;     return regions.get(language, {})\n    \"\"\"\n    return get_cache(request, \"REGION_TRANSLATIONS\")\n</code></pre>"},{"location":"developer-guide/api-reference/species/#data-schemas","title":"Data Schemas","text":"<p>The Species API uses the following Pydantic schemas for request/response validation:</p>"},{"location":"developer-guide/api-reference/species/#speciesbase-schema","title":"SpeciesBase Schema","text":""},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesBase","title":"<code>backend.schemas.species_schemas.SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>"},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#speciesdetail-schema","title":"SpeciesDetail Schema","text":""},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesDetail","title":"<code>backend.schemas.species_schemas.SpeciesDetail</code>","text":"<p>Detailed species model with extended information.</p> <p>Extends the base species model with additional descriptive fields for comprehensive species information.</p>"},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesDetail.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#specieslistresponse-schema","title":"SpeciesListResponse Schema","text":""},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesListResponse","title":"<code>backend.schemas.species_schemas.SpeciesListResponse</code>","text":"<p>Response model for paginated species lists.</p> <p>Contains the total count and list of species for API responses.</p>"},{"location":"developer-guide/api-reference/species/#backend.schemas.species_schemas.SpeciesListResponse.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#service-layer","title":"Service Layer","text":"<p>The Species API integrates with the species service layer for business logic:</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service","title":"<code>backend.services.species_service</code>","text":"<p>Species data service for managing mosquito species information.</p> <p>This module provides functionality for retrieving and filtering species data from the database, including support for multiple languages, search functionality, and vector status filtering. It handles the conversion of raw database records to properly formatted species models with localized content.</p> Example <p>from backend.services.species_service import get_all_species from backend.services.database import get_db from fastapi import Request db = get_db() species = get_all_species(db, request, \"en\", search=\"aedes\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.SpeciesBase","title":"<code>SpeciesBase</code>","text":"<p>Base model for species information.</p> <p>Contains core species identification fields used across different species-related models.</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.SpeciesBase.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.SpeciesDetail","title":"<code>SpeciesDetail</code>","text":"<p>Detailed species model with extended information.</p> <p>Extends the base species model with additional descriptive fields for comprehensive species information.</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.SpeciesDetail.model_config","title":"<code>model_config = {}</code>  <code>class-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_all_species","title":"<code>get_all_species(db: DBConnection, request: Request, lang: str, search: str | None = None, limit: int = 100) -&gt; list[backend.schemas.species_schemas.SpeciesBase]</code>","text":"<p>Retrieve a list of species with optional search filtering.</p> <p>This function queries the species table and returns species records, optionally filtered by search terms across scientific names and common names in multiple languages. Results are returned as SpeciesBase objects.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>search</code> <code>str | None</code> <p>Search term to filter species by. Searches across scientific names and common names in all languages. If None, returns all species.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of species to return. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>list[SpeciesBase]</code> <p>list[SpeciesBase]: A list of SpeciesBase objects matching the search criteria, or all species if no search term is provided.</p> Example <p>from backend.services.database import get_db db = get_db()</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_all_species--get-all-species","title":"Get all species","text":"<p>all_species = get_all_species(db, request, \"en\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_all_species--search-for-aedes-species","title":"Search for Aedes species","text":"<p>aedes_species = get_all_species(db, request, \"en\", search=\"aedes\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_species_by_id","title":"<code>get_species_by_id(db: DBConnection, species_id: str, lang: str, region_translations: dict[str, dict[str, str]], request: Request) -&gt; backend.schemas.species_schemas.SpeciesDetail | None</code>","text":"<p>Retrieve detailed information for a specific species by its ID.</p> <p>This function queries the species table for a specific species record and returns it as a detailed SpeciesDetail object with full information including translated region names. Returns None if the species is not found.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>species_id</code> <code>str</code> <p>The unique identifier for the species to retrieve.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>region_translations</code> <code>dict[str, dict[str, str]]</code> <p>Pre-loaded region translations for localizing geographic region names.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <p>Returns:</p> Type Description <code>SpeciesDetail | None</code> <p>SpeciesDetail | None: A SpeciesDetail object if found, None if the species does not exist in the database.</p> Example <p>from backend.services.database import get_db db = get_db() aedes = get_species_by_id(db, \"aedes_aegypti\", \"en\", regions, request) if aedes: ...     print(f\"Species: {aedes.scientific_name}\") ...     print(f\"Regions: {aedes.geographic_regions}\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_vector_species","title":"<code>get_vector_species(db: DBConnection, request: Request, lang: str, disease_id: str | None = None) -&gt; list[backend.schemas.species_schemas.SpeciesBase]</code>","text":"<p>Retrieve species that are disease vectors, optionally filtered by disease.</p> <p>This function queries the species table for species marked as disease vectors. It can filter by a specific disease to find only species that transmit that disease, or return all vector species if no disease filter is applied.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>request</code> <code>Request</code> <p>The FastAPI request object for image URL construction.</p> required <code>lang</code> <code>str</code> <p>The target language code for localized content.</p> required <code>disease_id</code> <code>str | None</code> <p>Specific disease ID to filter by. If provided, only species that transmit this disease are returned. If None, all vector species are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SpeciesBase]</code> <p>list[SpeciesBase]: A list of SpeciesBase objects that are disease vectors, optionally filtered by the specified disease.</p> Example <p>from backend.services.database import get_db db = get_db()</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_vector_species--get-all-vector-species","title":"Get all vector species","text":"<p>all_vectors = get_vector_species(db, request, \"en\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_vector_species--get-species-that-transmit-malaria","title":"Get species that transmit malaria","text":"<p>malaria_vectors = get_vector_species(db, request, \"en\", \"malaria\")</p>"},{"location":"developer-guide/api-reference/species/#backend.services.species_service.get_table","title":"<code>get_table(db: DBConnection, table_name: str)</code>","text":"<p>Retrieve a specific table from the LanceDB database.</p> <p>Opens and returns a reference to the specified table in the database. This function validates that the table exists and is accessible.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DBConnection</code> <p>The database connection object.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to retrieve.</p> required <p>Returns:</p> Type Description <p>lancedb.table.Table: A table object for the specified table name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table is not found or cannot be opened.</p> Example <p>db = get_db() observations_table = get_table(db, \"observations\") results = observations_table.search().limit(10).to_list()</p>"},{"location":"developer-guide/api-reference/species/#example-usage","title":"Example Usage","text":""},{"location":"developer-guide/api-reference/species/#get-species-list","title":"Get Species List","text":"<pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        \"http://localhost:8000/api/v1/species\",\n        params={\"limit\": 25, \"lang\": \"en\"}\n    )\n    species_data = response.json()\n    print(f\"Found {species_data['count']} species\")\n</code></pre>"},{"location":"developer-guide/api-reference/species/#search-for-species","title":"Search for Species","text":"<pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species\",\n    params={\"search\": \"aedes\", \"limit\": 10, \"lang\": \"en\"}\n)\n</code></pre>"},{"location":"developer-guide/api-reference/species/#get-species-details","title":"Get Species Details","text":"<pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/species/aedes-aegypti\",\n    params={\"lang\": \"en\"}\n)\nspecies = response.json()\n</code></pre>"},{"location":"developer-guide/api-reference/species/#get-vector-species","title":"Get Vector Species","text":"<pre><code>response = await client.get(\n    \"http://localhost:8000/api/v1/vector-species\",\n    params={\"lang\": \"en\"}\n)\nvector_species = response.json()\n</code></pre>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>This guide covers the configuration options available for CulicidaeLab Server, including backend API settings, frontend configuration, and environment-specific customizations.</p>"},{"location":"getting-started/configuration/#configuration-overview","title":"Configuration Overview","text":"<p>CulicidaeLab Server uses multiple configuration files and environment variables to customize its behavior:</p> <ul> <li>Backend Configuration: Environment variables and <code>.env</code> files</li> <li>Frontend Configuration: Python configuration files</li> <li>Database Configuration: LanceDB settings and paths</li> <li>Model Configuration: AI model parameters and paths</li> </ul>"},{"location":"getting-started/configuration/#backend-configuration","title":"Backend Configuration","text":""},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>The backend uses environment variables for configuration. Create a <code>.env</code> file in the <code>backend/</code> directory:</p> <pre><code># Copy the example configuration\ncp backend/.env.example backend/.env\n</code></pre>"},{"location":"getting-started/configuration/#core-backend-settings","title":"Core Backend Settings","text":"<pre><code># Application Settings\nAPP_NAME=\"CulicidaeLab Server\"\nAPP_VERSION=\"1.0.0\"\nDEBUG=false\nENVIRONMENT=\"production\"  # development, staging, production\n\n# Server Settings\nHOST=\"0.0.0.0\"\nPORT=8000\nRELOAD=false  # Set to true for development\n\n# Database Settings\nLANCEDB_PATH=\"./data/lancedb\"\nLANCEDB_TABLE_PREFIX=\"culicidae_\"\n\n# CORS Settings\nALLOWED_ORIGINS=[\"http://localhost:8765\", \"https://yourdomain.com\"]\nALLOWED_METHODS=[\"GET\", \"POST\", \"PUT\", \"DELETE\"]\nALLOWED_HEADERS=[\"*\"]\n\n# File Upload Settings\nMAX_FILE_SIZE=10485760  # 10MB in bytes\nALLOWED_FILE_TYPES=[\"image/jpeg\", \"image/png\", \"image/jpg\"]\nUPLOAD_PATH=\"./uploads\"\n\n# AI Model Settings\nMODEL_CACHE_DIR=\"./models\"\nDEFAULT_CLASSIFICATION_MODEL=\"culico-net-cls-v1\"\nDEFAULT_DETECTION_MODEL=\"culico-net-det-v1\"\nDEFAULT_SEGMENTATION_MODEL=\"culico-net-segm-v1-nano\"\n\n# Performance Settings\nMAX_WORKERS=4\nBATCH_SIZE=1\nUSE_GPU=true\nGPU_MEMORY_FRACTION=0.8\n\n# Logging Settings\nLOG_LEVEL=\"INFO\"  # DEBUG, INFO, WARNING, ERROR, CRITICAL\nLOG_FILE=\"./logs/culicidaelab.log\"\nLOG_ROTATION=\"1 week\"\nLOG_RETENTION=\"4 weeks\"\n\n# Security Settings\nSECRET_KEY=\"your-secret-key-here\"  # Generate a secure random key\nACCESS_TOKEN_EXPIRE_MINUTES=30\nALGORITHM=\"HS256\"\n\n# External API Settings (if applicable)\nEXTERNAL_API_KEY=\"\"\nEXTERNAL_API_URL=\"\"\nAPI_RATE_LIMIT=100  # requests per minute\n</code></pre>"},{"location":"getting-started/configuration/#configuration-file-structure","title":"Configuration File Structure","text":"<p>The backend configuration is managed through several files:</p> <pre><code>backend/\n\u251c\u2500\u2500 config.py              # Main configuration module\n\u251c\u2500\u2500 .env                   # Environment variables\n\u251c\u2500\u2500 .env.example          # Example environment file\n\u2514\u2500\u2500 dependencies.py       # Dependency injection configuration\n</code></pre>"},{"location":"getting-started/configuration/#loading-configuration","title":"Loading Configuration","text":"<p>The configuration is loaded in <code>backend/config.py</code>:</p> <pre><code>from pydantic_settings import BaseSettings\nfrom typing import List, Optional\n\nclass Settings(BaseSettings):\n    # Application settings\n    app_name: str = \"CulicidaeLab Server\"\n    debug: bool = False\n    environment: str = \"production\"\n\n    # Server settings\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n\n    # Database settings\n    lancedb_path: str = \"./data/lancedb\"\n\n    # Model settings\n    model_cache_dir: str = \"./models\"\n    use_gpu: bool = True\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n\nsettings = Settings()\n</code></pre>"},{"location":"getting-started/configuration/#frontend-configuration","title":"Frontend Configuration","text":""},{"location":"getting-started/configuration/#frontend-settings-file","title":"Frontend Settings File","text":"<p>The frontend configuration is managed in <code>frontend/config.py</code>:</p> <pre><code>from typing import Dict, Any, List\nimport os\n\nclass FrontendConfig:\n    # Application settings\n    APP_TITLE = \"CulicidaeLab Server\"\n    APP_DESCRIPTION = \"Mosquito Research &amp; Analysis Platform\"\n\n    # API settings\n    API_BASE_URL = os.getenv(\"API_BASE_URL\", \"http://localhost:8000\")\n    API_TIMEOUT = 30  # seconds\n\n    # UI settings\n    THEME = \"light\"  # light, dark, auto\n    DEFAULT_MAP_CENTER = [40.7128, -74.0060]  # New York City\n    DEFAULT_MAP_ZOOM = 10\n\n    # File upload settings\n    MAX_FILE_SIZE_MB = 10\n    ALLOWED_FILE_EXTENSIONS = [\".jpg\", \".jpeg\", \".png\"]\n\n    # Map settings\n    MAP_TILE_URL = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n    MAP_ATTRIBUTION = \"\u00a9 OpenStreetMap contributors\"\n\n    # Performance settings\n    ENABLE_CACHING = True\n    CACHE_TIMEOUT = 300  # 5 minutes\n\n    # Feature flags\n    ENABLE_SPECIES_PREDICTION = True\n    ENABLE_MAP_VISUALIZATION = True\n    ENABLE_SPECIES_GALLERY = True\n    ENABLE_DISEASE_INFO = True\n\n# Create global config instance\nconfig = FrontendConfig()\n</code></pre>"},{"location":"getting-started/configuration/#customizing-frontend-behavior","title":"Customizing Frontend Behavior","text":"<p>You can customize the frontend by modifying <code>frontend/config.py</code> or setting environment variables:</p> <pre><code># Set API base URL\nexport API_BASE_URL=\"https://api.yourdomain.com\"\n\n# Set default map location\nexport DEFAULT_MAP_CENTER=\"[51.5074, -0.1278]\"  # London\nexport DEFAULT_MAP_ZOOM=\"12\"\n</code></pre>"},{"location":"getting-started/configuration/#database-configuration","title":"Database Configuration","text":""},{"location":"getting-started/configuration/#lancedb-settings","title":"LanceDB Settings","text":"<p>Configure the vector database settings:</p> <pre><code># In backend/config.py\nclass DatabaseConfig:\n    # Database path\n    lancedb_path: str = \"./data/lancedb\"\n\n    # Table settings\n    table_prefix: str = \"culicidae_\"\n\n    # Performance settings\n    max_connections: int = 10\n    connection_timeout: int = 30\n\n    # Vector settings\n    vector_dimension: int = 512\n    distance_metric: str = \"cosine\"  # cosine, euclidean, dot\n\n    # Indexing settings\n    index_type: str = \"IVF_FLAT\"\n    nlist: int = 100  # number of clusters for IVF index\n</code></pre>"},{"location":"getting-started/configuration/#sample-data-configuration","title":"Sample Data Configuration","text":"<p>Configure sample data generation:</p> <pre><code># In backend/data/sample_data/config.py\nSAMPLE_DATA_CONFIG = {\n    \"species_count\": 46,\n    \"observations_per_species\": 10,\n    \"diseases_count\": 20,\n    \"geographic_bounds\": {\n        \"min_lat\": -90,\n        \"max_lat\": 90,\n        \"min_lon\": -180,\n        \"max_lon\": 180\n    }\n}\n</code></pre>"},{"location":"getting-started/configuration/#model-configuration","title":"Model Configuration","text":""},{"location":"getting-started/configuration/#ai-model-settings","title":"AI Model Settings","text":"<p>Configure the AI models used for predictions:</p> <pre><code># Model configuration\nMODEL_CONFIG = {\n    \"classification\": {\n        \"model_name\": \"culico-net-cls-v1\",\n        \"model_path\": \"./models/classification/\",\n        \"input_size\": (224, 224),\n        \"batch_size\": 1,\n        \"confidence_threshold\": 0.5\n    },\n    \"detection\": {\n        \"model_name\": \"culico-net-det-v1\",\n        \"model_path\": \"./models/detection/\",\n        \"input_size\": (640, 640),\n        \"batch_size\": 1,\n        \"confidence_threshold\": 0.25,\n        \"iou_threshold\": 0.45\n    },\n    \"segmentation\": {\n        \"model_name\": \"culico-net-segm-v1-nano\",\n        \"model_path\": \"./models/segmentation/\",\n        \"input_size\": (512, 512),\n        \"batch_size\": 1,\n        \"confidence_threshold\": 0.3\n    }\n}\n</code></pre>"},{"location":"getting-started/configuration/#gpu-configuration","title":"GPU Configuration","text":"<p>Configure GPU usage and memory management:</p> <pre><code># GPU settings\nUSE_GPU=true\nGPU_DEVICE_ID=0  # Use specific GPU device\nGPU_MEMORY_FRACTION=0.8  # Use 80% of GPU memory\nENABLE_MIXED_PRECISION=true  # Enable FP16 for faster inference\n</code></pre>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"getting-started/configuration/#development-environment","title":"Development Environment","text":"<pre><code># .env.development\nDEBUG=true\nENVIRONMENT=\"development\"\nRELOAD=true\nLOG_LEVEL=\"DEBUG\"\nALLOWED_ORIGINS=[\"http://localhost:8765\", \"http://127.0.0.1:8765\"]\n</code></pre>"},{"location":"getting-started/configuration/#production-environment","title":"Production Environment","text":"<pre><code># .env.production\nDEBUG=false\nENVIRONMENT=\"production\"\nRELOAD=false\nLOG_LEVEL=\"INFO\"\nSECRET_KEY=\"your-production-secret-key\"\nALLOWED_ORIGINS=[\"https://yourdomain.com\"]\n</code></pre>"},{"location":"getting-started/configuration/#testing-environment","title":"Testing Environment","text":"<pre><code># .env.testing\nDEBUG=true\nENVIRONMENT=\"testing\"\nLANCEDB_PATH=\"./test_data/lancedb\"\nLOG_LEVEL=\"WARNING\"\n</code></pre>"},{"location":"getting-started/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"getting-started/configuration/#api-security","title":"API Security","text":"<pre><code># Security settings\nSECRET_KEY=\"generate-a-secure-random-key\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nALGORITHM=\"HS256\"\n\n# CORS settings\nALLOWED_ORIGINS=[\"https://yourdomain.com\"]\nALLOWED_METHODS=[\"GET\", \"POST\"]\nALLOWED_HEADERS=[\"Content-Type\", \"Authorization\"]\n</code></pre>"},{"location":"getting-started/configuration/#file-upload-security","title":"File Upload Security","text":"<pre><code># File upload security\nMAX_FILE_SIZE=10485760  # 10MB\nALLOWED_FILE_TYPES=[\"image/jpeg\", \"image/png\"]\nSCAN_UPLOADS=true  # Enable virus scanning if available\nQUARANTINE_PATH=\"./quarantine\"\n</code></pre>"},{"location":"getting-started/configuration/#logging-configuration","title":"Logging Configuration","text":""},{"location":"getting-started/configuration/#structured-logging","title":"Structured Logging","text":"<p>Configure logging for monitoring and debugging:</p> <pre><code>LOGGING_CONFIG = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        },\n        \"detailed\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(module)s - %(funcName)s - %(message)s\"\n        }\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"default\",\n            \"level\": \"INFO\"\n        },\n        \"file\": {\n            \"class\": \"logging.handlers.RotatingFileHandler\",\n            \"filename\": \"./logs/culicidaelab.log\",\n            \"maxBytes\": 10485760,  # 10MB\n            \"backupCount\": 5,\n            \"formatter\": \"detailed\",\n            \"level\": \"DEBUG\"\n        }\n    },\n    \"root\": {\n        \"level\": \"INFO\",\n        \"handlers\": [\"console\", \"file\"]\n    }\n}\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":""},{"location":"getting-started/configuration/#environment-validation","title":"Environment Validation","text":"<p>Validate configuration on startup:</p> <pre><code>def validate_config():\n    \"\"\"Validate configuration settings\"\"\"\n    errors = []\n\n    # Check required directories\n    required_dirs = [settings.lancedb_path, settings.model_cache_dir]\n    for dir_path in required_dirs:\n        if not os.path.exists(dir_path):\n            errors.append(f\"Directory not found: {dir_path}\")\n\n    # Check GPU availability\n    if settings.use_gpu:\n        try:\n            import torch\n            if not torch.cuda.is_available():\n                errors.append(\"GPU requested but CUDA not available\")\n        except ImportError:\n            errors.append(\"PyTorch not installed but GPU requested\")\n\n    if errors:\n        raise ValueError(f\"Configuration errors: {', '.join(errors)}\")\n</code></pre>"},{"location":"getting-started/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"getting-started/configuration/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Never commit <code>.env</code> files to version control</li> <li>Use strong secret keys for production</li> <li>Limit CORS origins to trusted domains</li> <li>Enable HTTPS in production</li> <li>Regularly rotate secrets and API keys</li> </ol>"},{"location":"getting-started/configuration/#performance-best-practices","title":"Performance Best Practices","text":"<ol> <li>Tune batch sizes based on available memory</li> <li>Configure appropriate worker counts for your CPU</li> <li>Use GPU acceleration when available</li> <li>Set reasonable timeouts for API calls</li> <li>Enable caching for frequently accessed data</li> </ol>"},{"location":"getting-started/configuration/#monitoring-best-practices","title":"Monitoring Best Practices","text":"<ol> <li>Configure structured logging for better analysis</li> <li>Set appropriate log levels for each environment</li> <li>Monitor resource usage and adjust limits</li> <li>Set up health checks for critical components</li> <li>Configure alerting for error conditions</li> </ol>"},{"location":"getting-started/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"getting-started/configuration/#common-configuration-issues","title":"Common Configuration Issues","text":"<ol> <li>Environment variables not loaded:</li> <li>Check <code>.env</code> file location and syntax</li> <li> <p>Verify environment variable names match code</p> </li> <li> <p>Database connection issues:</p> </li> <li>Check database path permissions</li> <li> <p>Verify LanceDB installation</p> </li> <li> <p>Model loading failures:</p> </li> <li>Check model cache directory permissions</li> <li> <p>Verify model files are downloaded</p> </li> <li> <p>GPU not detected:</p> </li> <li>Check CUDA installation</li> <li>Verify GPU drivers</li> </ol> <p>For more troubleshooting help, see the troubleshooting guide.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install and set up CulicidaeLab Server on your local machine or server environment.</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Processor (CPU): Any modern x86-64 CPU</li> <li>Memory (RAM): Minimum 2 GB, 8 GB or more recommended for large datasets</li> <li>Graphics Card (GPU): NVIDIA GPU with CUDA support recommended for AI model operations (minimum 2 GB VRAM, 4 GB+ recommended)</li> <li>Storage: At least 10 GB of free space for installation, dependencies, and data</li> </ul>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#software-requirements","title":"Software Requirements","text":"<p>Operating Systems (tested): - Windows 10/11 - Linux 22.04+</p> <p>Required Software: - Git - Python 3.11 - uv 0.8.13 (recommended) or pip - For Linux: <code>libgl1</code> package</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":"","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#method-1-using-uv-recommended","title":"Method 1: Using uv (Recommended)","text":"<p>uv is a fast Python package manager that provides better dependency resolution and faster installations.</p> <ol> <li> <p>Install uv (if not already installed):    <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre></p> </li> <li> <p>Clone the repository: <pre><code>git clone https://github.com/iloncka-ds/culicidaelab-server.git\ncd culicidaelab-server\n</code></pre></p> </li> <li> <p>Create virtual environment and install dependencies: <pre><code>uv venv -p 3.11\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv sync -p 3.11\nuv pip install -e .\nuv cache clean\n</code></pre></p> </li> </ol>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#method-2-using-pip","title":"Method 2: Using pip","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/iloncka-ds/culicidaelab-server.git\ncd culicidaelab-server\n</code></pre></p> </li> <li> <p>Create virtual environment and install dependencies: <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npython -m pip install -e .\npython -m pip cache purge\n</code></pre></p> </li> </ol>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#post-installation-setup","title":"Post-Installation Setup","text":"","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#1-generate-sample-data","title":"1. Generate Sample Data","text":"<p>Create the JSON/GeoJSON files for initial database population:</p> <pre><code>python -m backend.data.sample_data.generate_sample_data\n</code></pre> <p>This creates sample files in the <code>sample_data/</code> directory including: - <code>sample_species.json</code> - <code>sample_observations.geojson</code> - <code>sample_diseases.json</code></p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#2-initialize-database","title":"2. Initialize Database","text":"<p>Set up LanceDB tables and populate them with sample data:</p> <pre><code>python -m backend.scripts.populate_lancedb\n</code></pre>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#3-verify-installation","title":"3. Verify Installation","text":"<p>Check if the database was populated successfully:</p> <pre><code>python -m backend.scripts.query_lancedb observations --limit 5\n</code></pre>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#environment-configuration","title":"Environment Configuration","text":"","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#backend-configuration","title":"Backend Configuration","text":"<p>Create a <code>.env</code> file in the <code>backend/</code> directory with your configuration:</p> <pre><code># Copy the example configuration\ncp backend/.env.example backend/.env\n</code></pre> <p>Edit the <code>.env</code> file to match your environment settings.</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#frontend-configuration","title":"Frontend Configuration","text":"<p>The frontend configuration is handled in <code>frontend/config.py</code>. Review and modify as needed for your deployment.</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>GPU/CUDA Issues: - Ensure NVIDIA drivers are installed and up to date - Verify CUDA compatibility with your GPU - For CPU-only operation, the system will automatically fall back</p> <p>Permission Issues on Linux: - Ensure you have proper permissions for the installation directory - Install <code>libgl1</code> package: <code>sudo apt-get install libgl1-mesa-glx</code></p> <p>Python Version Issues: - Ensure Python 3.11 is installed and active - Use <code>python --version</code> to verify</p> <p>Memory Issues: - Increase system RAM or use smaller batch sizes - Consider using CPU-only mode for lower memory usage</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during installation:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Review the troubleshooting guide</li> <li>Join the discussion on GitHub Discussions</li> </ol>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation, proceed to the Quick Start Guide to learn how to run and use CulicidaeLab Server.</p>","tags":["setup","installation","requirements","getting-started"]},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get CulicidaeLab Server up and running in minutes with this quick start guide.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have completed the installation process.</p>"},{"location":"getting-started/quick-start/#starting-the-application","title":"Starting the Application","text":"<p>CulicidaeLab Server consists of two main components that need to be running:</p>"},{"location":"getting-started/quick-start/#1-start-the-backend-api-server","title":"1. Start the Backend API Server","text":"<p>Open a terminal and navigate to your project directory:</p> <pre><code>cd culicidaelab-server\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuvicorn backend.main:app --port 8000 --host 127.0.0.1\n</code></pre> <p>The backend API will be available at: - API Base: <code>http://localhost:8000</code> - Interactive API Documentation (Swagger): <code>http://localhost:8000/docs</code> - Alternative API Documentation (ReDoc): <code>http://localhost:8000/redoc</code></p>"},{"location":"getting-started/quick-start/#2-start-the-frontend-application","title":"2. Start the Frontend Application","text":"<p>Open a new terminal and navigate to your project directory:</p> <pre><code>cd culicidaelab-server\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nsolara run frontend.main\n</code></pre> <p>The frontend application will be available at <code>http://localhost:8765</code> (or the port shown in your terminal).</p>"},{"location":"getting-started/quick-start/#first-steps","title":"First Steps","text":""},{"location":"getting-started/quick-start/#1-explore-the-web-interface","title":"1. Explore the Web Interface","text":"<ol> <li>Open your browser and go to <code>http://localhost:8765</code></li> <li>You'll see the CulicidaeLab Server homepage with navigation to different features</li> <li>Explore the main sections:</li> <li>Species Prediction: Upload mosquito images for AI-powered identification</li> <li>Interactive Map: View mosquito observations and distribution data</li> <li>Species Gallery: Browse information about different mosquito species</li> <li>Disease Information: Learn about mosquito-borne diseases</li> </ol>"},{"location":"getting-started/quick-start/#2-test-species-prediction","title":"2. Test Species Prediction","text":"<ol> <li>Navigate to the Species Prediction page</li> <li>Upload a mosquito image (JPEG, PNG formats supported)</li> <li>Wait for the AI model to process the image</li> <li>Review the prediction results with confidence scores</li> </ol>"},{"location":"getting-started/quick-start/#3-explore-the-interactive-map","title":"3. Explore the Interactive Map","text":"<ol> <li>Go to the Map Visualization page</li> <li>View sample observation data plotted on the interactive map</li> <li>Click on markers to see detailed observation information</li> <li>Use map controls to zoom and pan around different regions</li> </ol>"},{"location":"getting-started/quick-start/#4-browse-the-api-documentation","title":"4. Browse the API Documentation","text":"<ol> <li>Visit <code>http://localhost:8000/docs</code> for interactive API documentation</li> <li>Explore available endpoints:</li> <li><code>/predict/species</code> - Species prediction from images</li> <li><code>/observations</code> - Mosquito observation data</li> <li><code>/species</code> - Species information</li> <li><code>/diseases</code> - Disease information</li> <li>Try out API endpoints directly from the documentation interface</li> </ol>"},{"location":"getting-started/quick-start/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"getting-started/quick-start/#making-api-calls","title":"Making API Calls","text":"<p>You can interact with the API using curl, Python requests, or any HTTP client:</p> <pre><code># Get all species\ncurl http://localhost:8000/species\n\n# Get observations with limit\ncurl http://localhost:8000/observations?limit=10\n\n# Get disease information\ncurl http://localhost:8000/diseases\n</code></pre>"},{"location":"getting-started/quick-start/#python-api-usage","title":"Python API Usage","text":"<pre><code>import requests\n\n# Get species data\nresponse = requests.get(\"http://localhost:8000/species\")\nspecies_data = response.json()\n\n# Upload image for prediction (example)\nwith open(\"mosquito_image.jpg\", \"rb\") as f:\n    files = {\"file\": f}\n    response = requests.post(\"http://localhost:8000/predict/species\", files=files)\n    prediction = response.json()\n</code></pre>"},{"location":"getting-started/quick-start/#configuration","title":"Configuration","text":""},{"location":"getting-started/quick-start/#basic-configuration","title":"Basic Configuration","text":"<p>The application uses default settings that work for most development scenarios. For custom configuration:</p> <ol> <li>Backend Configuration: Edit <code>backend/.env</code> file</li> <li>Frontend Configuration: Modify <code>frontend/config.py</code></li> </ol>"},{"location":"getting-started/quick-start/#common-configuration-options","title":"Common Configuration Options","text":"<ul> <li>API Port: Change the backend port by modifying the <code>uvicorn</code> command</li> <li>Frontend Port: Solara will automatically select an available port</li> <li>Database Path: Configure LanceDB path in backend configuration</li> <li>Model Settings: Adjust AI model parameters in the backend configuration</li> </ul>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#application-wont-start","title":"Application Won't Start","text":"<ol> <li> <p>Check Python Environment: <pre><code>python --version  # Should show Python 3.11.x\nwhich python      # Should point to your virtual environment\n</code></pre></p> </li> <li> <p>Verify Dependencies: <pre><code>pip list | grep fastapi\npip list | grep solara\n</code></pre></p> </li> <li> <p>Check Port Availability:</p> </li> <li>Ensure ports 8000 and 8765 are not in use by other applications</li> <li>Use different ports if needed: <code>uvicorn backend.main:app --port 8001</code></li> </ol>"},{"location":"getting-started/quick-start/#performance-issues","title":"Performance Issues","text":"<ol> <li>GPU Not Detected:</li> <li>Check NVIDIA drivers and CUDA installation</li> <li> <p>The application will fall back to CPU processing automatically</p> </li> <li> <p>Slow Predictions:</p> </li> <li>Ensure GPU is properly configured for faster inference</li> <li> <p>Consider using smaller image sizes for faster processing</p> </li> <li> <p>Memory Issues:</p> </li> <li>Reduce batch sizes in model configuration</li> <li>Close other memory-intensive applications</li> </ol>"},{"location":"getting-started/quick-start/#common-error-messages","title":"Common Error Messages","text":"<ul> <li>\"Module not found\": Ensure virtual environment is activated and dependencies are installed</li> <li>\"Port already in use\": Change the port number or stop the conflicting process</li> <li>\"Database not found\": Run the database initialization script again</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have CulicidaeLab Server running:</p> <ol> <li>Learn More: Read the User Guide for detailed feature documentation</li> <li>Develop: Check the Developer Guide for development information</li> <li>Deploy: See the Deployment Guide for production deployment</li> <li>Contribute: Review the Contributing Guidelines to contribute to the project</li> </ol>"},{"location":"getting-started/quick-start/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ul> <li>Check the troubleshooting guide</li> <li>Search GitHub Issues</li> <li>Ask questions in GitHub Discussions</li> <li>Contact the team at culicidaelab@gmail.com</li> </ul>"},{"location":"reference/changelog/","title":"Changelog","text":"<p>Version history and changes for CulicidaeLab Server.</p> <p>This page will be populated in subsequent tasks.</p>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>This document provides a comprehensive reference for all configuration options available in CulicidaeLab Server, including environment variables, application settings, and deployment configurations.</p>"},{"location":"reference/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"reference/configuration/#backend-configuration","title":"Backend Configuration","text":""},{"location":"reference/configuration/#core-application-settings","title":"Core Application Settings","text":"Variable Type Default Description <code>CULICIDAELAB_APP_NAME</code> string <code>\"CulicidaeLab API\"</code> Application name displayed in API documentation <code>CULICIDAELAB_API_V1_STR</code> string <code>\"/api\"</code> Base path prefix for API version 1 endpoints <code>ENVIRONMENT</code> string <code>\"development\"</code> Application environment (development, staging, production)"},{"location":"reference/configuration/#database-configuration","title":"Database Configuration","text":"Variable Type Default Description <code>CULICIDAELAB_DATABASE_PATH</code> string <code>\".lancedb\"</code> File system path to the LanceDB database directory <code>CULICIDAELAB_DATABASE_TIMEOUT</code> integer <code>30</code> Database connection timeout in seconds <code>CULICIDAELAB_DATABASE_MAX_CONNECTIONS</code> integer <code>10</code> Maximum number of database connections"},{"location":"reference/configuration/#model-configuration","title":"Model Configuration","text":"Variable Type Default Description <code>CULICIDAELAB_MODEL_PATH</code> string <code>\"models/\"</code> Directory path containing model files <code>CULICIDAELAB_SAVE_PREDICTED_IMAGES</code> boolean <code>false</code> Whether to save predicted images to disk <code>CULICIDAELAB_PREDICTION_TIMEOUT</code> integer <code>300</code> Timeout for model predictions in seconds <code>CULICIDAELAB_MAX_IMAGE_SIZE</code> integer <code>10485760</code> Maximum image upload size in bytes (10MB)"},{"location":"reference/configuration/#security-configuration","title":"Security Configuration","text":"Variable Type Default Description <code>CULICIDAELAB_SECRET_KEY</code> string <code>\"\"</code> Secret key for session management and encryption <code>CULICIDAELAB_BACKEND_CORS_ORIGINS</code> list <code>[\"http://localhost:8765\"]</code> Allowed CORS origins for frontend access <code>CULICIDAELAB_ALLOWED_HOSTS</code> list <code>[\"localhost\", \"127.0.0.1\"]</code> Allowed host headers <code>CULICIDAELAB_RATE_LIMIT_REQUESTS</code> integer <code>100</code> Number of requests per minute per IP"},{"location":"reference/configuration/#logging-configuration","title":"Logging Configuration","text":"Variable Type Default Description <code>CULICIDAELAB_LOG_LEVEL</code> string <code>\"INFO\"</code> Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL) <code>CULICIDAELAB_LOG_FILE</code> string <code>\"\"</code> Path to log file (empty for console logging) <code>CULICIDAELAB_LOG_FORMAT</code> string <code>\"json\"</code> Log format (json, text) <code>CULICIDAELAB_LOG_ROTATION</code> boolean <code>true</code> Enable log file rotation"},{"location":"reference/configuration/#frontend-configuration","title":"Frontend Configuration","text":""},{"location":"reference/configuration/#application-settings","title":"Application Settings","text":"Variable Type Default Description <code>FRONTEND_HOST</code> string <code>\"localhost\"</code> Host address for frontend server <code>FRONTEND_PORT</code> integer <code>8765</code> Port number for frontend server <code>BACKEND_URL</code> string <code>\"http://localhost:8000\"</code> Backend API base URL <code>FRONTEND_DEBUG</code> boolean <code>false</code> Enable debug mode for frontend"},{"location":"reference/configuration/#ui-configuration","title":"UI Configuration","text":"Variable Type Default Description <code>FRONTEND_THEME</code> string <code>\"light\"</code> Default UI theme (light, dark, auto) <code>FRONTEND_LANGUAGE</code> string <code>\"en\"</code> Default language (en, ru) <code>FRONTEND_MAP_PROVIDER</code> string <code>\"openstreetmap\"</code> Map tile provider <code>FRONTEND_MAX_UPLOAD_SIZE</code> integer <code>52428800</code> Maximum file upload size in bytes (50MB)"},{"location":"reference/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"reference/configuration/#backend-configuration-backendconfigpy","title":"Backend Configuration (<code>backend/config.py</code>)","text":"<p>The main configuration class <code>AppSettings</code> provides centralized access to all application settings:</p> <pre><code>from backend.config import settings\n\n# Access configuration values\napp_name = settings.APP_NAME\ndatabase_path = settings.DATABASE_PATH\ncors_origins = settings.BACKEND_CORS_ORIGINS\n\n# Access model configuration\nmodel_path = settings.classifier_model_path\npredictor_settings = settings.classifier_settings\n</code></pre>"},{"location":"reference/configuration/#configuration-properties","title":"Configuration Properties","text":"<pre><code>class AppSettings(BaseSettings):\n    # Core settings\n    APP_NAME: str = \"CulicidaeLab API\"\n    API_V1_STR: str = \"/api\"\n    DATABASE_PATH: str = \".lancedb\"\n    SAVE_PREDICTED_IMAGES: str | bool = False\n    BACKEND_CORS_ORIGINS: list[str] = [\"http://localhost:8765\"]\n\n    # Dynamic properties\n    @property\n    def classifier_settings(self):\n        \"\"\"Returns culicidaelab library settings\"\"\"\n\n    @property\n    def classifier_model_path(self) -&gt; str:\n        \"\"\"Returns path to classifier model weights\"\"\"\n</code></pre>"},{"location":"reference/configuration/#environment-file-env","title":"Environment File (<code>.env</code>)","text":"<p>Create a <code>.env</code> file in the backend directory for local development:</p> <pre><code># Database configuration\nCULICIDAELAB_DATABASE_PATH=\"backend/data/.lancedb\"\n\n# Model configuration\nCULICIDAELAB_SAVE_PREDICTED_IMAGES=1\nCULICIDAELAB_MODEL_PATH=\"models/\"\n\n# Security\nCULICIDAELAB_SECRET_KEY=\"your-secret-key-here\"\n\n# CORS origins (comma-separated)\nCULICIDAELAB_BACKEND_CORS_ORIGINS=\"http://localhost:8765,http://127.0.0.1:8765\"\n\n# Logging\nCULICIDAELAB_LOG_LEVEL=\"DEBUG\"\nCULICIDAELAB_LOG_FILE=\"logs/culicidaelab.log\"\n\n# Environment\nENVIRONMENT=\"development\"\n</code></pre>"},{"location":"reference/configuration/#production-environment-file","title":"Production Environment File","text":"<p>For production deployments, use more secure settings:</p> <pre><code># Production database path\nCULICIDAELAB_DATABASE_PATH=\"/var/lib/culicidaelab/data/.lancedb\"\n\n# Production model path\nCULICIDAELAB_MODEL_PATH=\"/var/lib/culicidaelab/models/\"\n\n# Security settings\nCULICIDAELAB_SECRET_KEY=\"your-very-secure-secret-key-here\"\nCULICIDAELAB_BACKEND_CORS_ORIGINS=\"https://your-domain.com,https://www.your-domain.com\"\nCULICIDAELAB_ALLOWED_HOSTS=\"your-domain.com,www.your-domain.com\"\n\n# Performance settings\nCULICIDAELAB_DATABASE_MAX_CONNECTIONS=20\nCULICIDAELAB_RATE_LIMIT_REQUESTS=1000\n\n# Logging\nCULICIDAELAB_LOG_LEVEL=\"INFO\"\nCULICIDAELAB_LOG_FILE=\"/var/log/culicidaelab/app.log\"\nCULICIDAELAB_LOG_FORMAT=\"json\"\n\n# Environment\nENVIRONMENT=\"production\"\n</code></pre>"},{"location":"reference/configuration/#model-configuration_1","title":"Model Configuration","text":""},{"location":"reference/configuration/#culicidaelab-library-settings","title":"CulicidaeLab Library Settings","text":"<p>The application integrates with the <code>culicidaelab</code> library for species prediction. Model configuration is managed through the library's settings system:</p> <pre><code>from backend.config import get_predictor_settings\n\n# Get model settings\nsettings = get_predictor_settings()\n\n# Access model parameters\nconfidence_threshold = settings.get_confidence_threshold()\nmodel_weights_path = settings.get_model_weights_path(\"segmenter\")\n</code></pre>"},{"location":"reference/configuration/#model-file-structure","title":"Model File Structure","text":"<pre><code>models/\n\u251c\u2500\u2500 segmenter/\n\u2502   \u251c\u2500\u2500 weights.pt              # Model weights\n\u2502   \u251c\u2500\u2500 config.json            # Model configuration\n\u2502   \u2514\u2500\u2500 metadata.json          # Model metadata\n\u251c\u2500\u2500 classifier/\n\u2502   \u251c\u2500\u2500 weights.pt\n\u2502   \u251c\u2500\u2500 config.json\n\u2502   \u2514\u2500\u2500 metadata.json\n\u2514\u2500\u2500 preprocessing/\n    \u251c\u2500\u2500 transforms.json        # Image preprocessing config\n    \u2514\u2500\u2500 normalization.json     # Normalization parameters\n</code></pre>"},{"location":"reference/configuration/#model-configuration-options","title":"Model Configuration Options","text":"Setting Type Default Description <code>confidence_threshold</code> float <code>0.5</code> Minimum confidence for predictions <code>max_image_size</code> tuple <code>(1024, 1024)</code> Maximum image dimensions <code>batch_size</code> integer <code>1</code> Batch size for model inference <code>device</code> string <code>\"auto\"</code> Device for model inference (cpu, cuda, auto) <code>preprocessing</code> dict <code>{}</code> Image preprocessing parameters"},{"location":"reference/configuration/#database-configuration_1","title":"Database Configuration","text":""},{"location":"reference/configuration/#lancedb-settings","title":"LanceDB Settings","text":"<p>CulicidaeLab uses LanceDB for vector storage and similarity search:</p> <pre><code># Database connection settings\nDATABASE_CONFIG = {\n    \"path\": settings.DATABASE_PATH,\n    \"timeout\": 30,\n    \"max_connections\": 10,\n    \"vector_dimension\": 512,\n    \"index_type\": \"IVF_FLAT\",\n    \"metric_type\": \"L2\"\n}\n</code></pre>"},{"location":"reference/configuration/#database-schema","title":"Database Schema","text":"<p>The database contains several tables for different data types:</p>"},{"location":"reference/configuration/#species-table","title":"Species Table","text":"<pre><code>species_schema = {\n    \"id\": \"string\",\n    \"name\": \"string\",\n    \"scientific_name\": \"string\",\n    \"vector\": \"vector(512)\",\n    \"metadata\": \"json\",\n    \"created_at\": \"timestamp\"\n}\n</code></pre>"},{"location":"reference/configuration/#observations-table","title":"Observations Table","text":"<pre><code>observations_schema = {\n    \"id\": \"string\",\n    \"species_id\": \"string\",\n    \"location\": \"geometry\",\n    \"confidence\": \"float\",\n    \"image_path\": \"string\",\n    \"metadata\": \"json\",\n    \"created_at\": \"timestamp\"\n}\n</code></pre>"},{"location":"reference/configuration/#server-configuration","title":"Server Configuration","text":""},{"location":"reference/configuration/#fastapi-settings","title":"FastAPI Settings","text":"<pre><code># FastAPI application configuration\napp = FastAPI(\n    title=settings.APP_NAME,\n    description=\"CulicidaeLab API for mosquito species identification\",\n    version=\"1.0.0\",\n    openapi_url=f\"{settings.API_V1_STR}/openapi.json\",\n    docs_url=f\"{settings.API_V1_STR}/docs\",\n    redoc_url=f\"{settings.API_V1_STR}/redoc\"\n)\n</code></pre>"},{"location":"reference/configuration/#cors-configuration","title":"CORS Configuration","text":"<pre><code># CORS middleware settings\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.BACKEND_CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"*\"],\n)\n</code></pre>"},{"location":"reference/configuration/#static-files-configuration","title":"Static Files Configuration","text":"<pre><code># Static file serving\napp.mount(\"/static\", StaticFiles(directory=\"backend/static\"), name=\"static\")\n</code></pre>"},{"location":"reference/configuration/#deployment-configuration","title":"Deployment Configuration","text":""},{"location":"reference/configuration/#docker-configuration","title":"Docker Configuration","text":""},{"location":"reference/configuration/#environment-variables-for-docker","title":"Environment Variables for Docker","text":"<pre><code># docker-compose.yml\nenvironment:\n  - CULICIDAELAB_DATABASE_PATH=/app/data/.lancedb\n  - CULICIDAELAB_MODEL_PATH=/app/models\n  - CULICIDAELAB_SAVE_PREDICTED_IMAGES=1\n  - CULICIDAELAB_LOG_LEVEL=INFO\n  - ENVIRONMENT=production\n</code></pre>"},{"location":"reference/configuration/#volume-mounts","title":"Volume Mounts","text":"<pre><code>volumes:\n  - ./data:/app/data              # Database files\n  - ./models:/app/models          # Model files\n  - ./logs:/app/logs              # Log files\n  - ./uploads:/app/uploads        # User uploads\n</code></pre>"},{"location":"reference/configuration/#nginx-configuration","title":"Nginx Configuration","text":""},{"location":"reference/configuration/#reverse-proxy-settings","title":"Reverse Proxy Settings","text":"<pre><code># Backend API proxy\nlocation /api {\n    proxy_pass http://backend:8000;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n\n    # Timeout settings for model predictions\n    proxy_read_timeout 300s;\n    proxy_connect_timeout 75s;\n    proxy_send_timeout 300s;\n}\n\n# Frontend proxy\nlocation / {\n    proxy_pass http://frontend:8765;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n\n    # WebSocket support for Solara\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n}\n</code></pre>"},{"location":"reference/configuration/#file-upload-settings","title":"File Upload Settings","text":"<pre><code># Increase upload size limits\nclient_max_body_size 50M;\nclient_body_timeout 300s;\nclient_header_timeout 300s;\n</code></pre>"},{"location":"reference/configuration/#performance-configuration","title":"Performance Configuration","text":""},{"location":"reference/configuration/#backend-performance","title":"Backend Performance","text":"Setting Development Production Description Workers 1 4-8 Number of Uvicorn workers Timeout 30s 300s Request timeout Keep-alive 2s 5s Connection keep-alive Max connections 10 100 Maximum concurrent connections"},{"location":"reference/configuration/#frontend-performance","title":"Frontend Performance","text":"Setting Development Production Description Debug mode True False Enable debug features Asset compression False True Compress static assets Caching Disabled Enabled Enable browser caching"},{"location":"reference/configuration/#database-performance","title":"Database Performance","text":"Setting Small Medium Large Description Max connections 10 50 100 Database connection pool size Query timeout 30s 60s 120s Query execution timeout Cache size 100MB 500MB 1GB Query result cache size"},{"location":"reference/configuration/#monitoring-configuration","title":"Monitoring Configuration","text":""},{"location":"reference/configuration/#health-check-endpoints","title":"Health Check Endpoints","text":"Endpoint Method Description <code>/health</code> GET Basic health check <code>/api/health</code> GET API health with database check <code>/metrics</code> GET Prometheus metrics (if enabled)"},{"location":"reference/configuration/#logging-configuration_1","title":"Logging Configuration","text":""},{"location":"reference/configuration/#log-levels","title":"Log Levels","text":"<ul> <li>DEBUG: Detailed information for debugging</li> <li>INFO: General information about application flow</li> <li>WARNING: Warning messages for potential issues</li> <li>ERROR: Error messages for handled exceptions</li> <li>CRITICAL: Critical errors that may cause application failure</li> </ul>"},{"location":"reference/configuration/#log-format","title":"Log Format","text":"<pre><code>{\n  \"timestamp\": \"2024-01-01T12:00:00Z\",\n  \"level\": \"INFO\",\n  \"logger\": \"culicidaelab.api\",\n  \"message\": \"Request processed successfully\",\n  \"request_id\": \"req_123456\",\n  \"user_id\": \"user_789\",\n  \"duration_ms\": 150,\n  \"status_code\": 200\n}\n</code></pre>"},{"location":"reference/configuration/#security-configuration_1","title":"Security Configuration","text":""},{"location":"reference/configuration/#authentication-settings","title":"Authentication Settings","text":"Setting Type Default Description <code>SESSION_TIMEOUT</code> integer <code>3600</code> Session timeout in seconds <code>MAX_LOGIN_ATTEMPTS</code> integer <code>5</code> Maximum failed login attempts <code>PASSWORD_MIN_LENGTH</code> integer <code>8</code> Minimum password length <code>REQUIRE_HTTPS</code> boolean <code>true</code> Require HTTPS in production"},{"location":"reference/configuration/#rate-limiting","title":"Rate Limiting","text":"<pre><code># Rate limiting configuration\nRATE_LIMITS = {\n    \"default\": \"100/minute\",\n    \"prediction\": \"10/minute\",\n    \"upload\": \"5/minute\",\n    \"auth\": \"20/minute\"\n}\n</code></pre>"},{"location":"reference/configuration/#file-upload-security","title":"File Upload Security","text":"<pre><code># Allowed file types and sizes\nUPLOAD_CONFIG = {\n    \"allowed_extensions\": [\".jpg\", \".jpeg\", \".png\", \".tiff\"],\n    \"max_file_size\": 50 * 1024 * 1024,  # 50MB\n    \"scan_for_malware\": True,\n    \"validate_image_format\": True\n}\n</code></pre>"},{"location":"reference/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"reference/configuration/#common-configuration-problems","title":"Common Configuration Problems","text":"<ol> <li>Environment Variables Not Loading</li> <li>Check <code>.env</code> file location and syntax</li> <li>Verify environment variable names and prefixes</li> <li> <p>Ensure proper file permissions</p> </li> <li> <p>Database Connection Issues</p> </li> <li>Verify database path exists and is writable</li> <li>Check database timeout settings</li> <li> <p>Ensure sufficient disk space</p> </li> <li> <p>Model Loading Failures</p> </li> <li>Verify model file paths and permissions</li> <li>Check model file integrity</li> <li> <p>Ensure sufficient memory for model loading</p> </li> <li> <p>CORS Issues</p> </li> <li>Verify CORS origins configuration</li> <li>Check protocol (http vs https) matching</li> <li>Ensure proper domain configuration</li> </ol>"},{"location":"reference/configuration/#configuration-validation","title":"Configuration Validation","text":"<pre><code># Validate configuration on startup\ndef validate_config():\n    \"\"\"Validate application configuration\"\"\"\n    errors = []\n\n    # Check required environment variables\n    required_vars = [\"CULICIDAELAB_DATABASE_PATH\", \"CULICIDAELAB_SECRET_KEY\"]\n    for var in required_vars:\n        if not os.getenv(var):\n            errors.append(f\"Missing required environment variable: {var}\")\n\n    # Check file paths\n    if not os.path.exists(settings.DATABASE_PATH):\n        errors.append(f\"Database path does not exist: {settings.DATABASE_PATH}\")\n\n    # Check model files\n    try:\n        model_path = settings.classifier_model_path\n        if not os.path.exists(model_path):\n            errors.append(f\"Model file not found: {model_path}\")\n    except Exception as e:\n        errors.append(f\"Model configuration error: {e}\")\n\n    if errors:\n        raise ValueError(f\"Configuration validation failed: {'; '.join(errors)}\")\n</code></pre>"},{"location":"reference/glossary/","title":"Glossary","text":"<p>Glossary of terms used in CulicidaeLab Server.</p> <p>This page will be populated in subsequent tasks.</p>"},{"location":"reference/tags/","title":"Tags","text":"<p>This page contains all the tags used throughout the documentation to help you find related content.</p> <p>[TAGS]</p>"},{"location":"reference/tags/#tag-usage-guide","title":"Tag Usage Guide","text":"<p>Tags are used to categorize and cross-reference content throughout the documentation. Here's how to use them effectively:</p>"},{"location":"reference/tags/#common-tags","title":"Common Tags","text":"<ul> <li>api: API-related documentation and endpoints</li> <li>setup: Installation and configuration guides</li> <li>development: Developer-focused content</li> <li>deployment: Production deployment information</li> <li>research: Research methodology and data science content</li> <li>troubleshooting: Problem-solving and debugging guides</li> <li>tutorial: Step-by-step instructional content</li> <li>reference: Technical reference material</li> </ul>"},{"location":"reference/tags/#finding-tagged-content","title":"Finding Tagged Content","text":"<p>You can find tagged content by:</p> <ol> <li>Using the search: Search for specific tags to find related content</li> <li>Browsing this page: All tags are listed above with their associated pages</li> <li>Following tag links: Click on any tag to see all related content</li> </ol>"},{"location":"reference/tags/#content-organization","title":"Content Organization","text":"<p>Tags help organize content across different sections:</p> <ul> <li>Cross-sectional topics: Find all content related to a specific technology or concept</li> <li>Skill level: Identify beginner, intermediate, or advanced content</li> <li>Content type: Distinguish between tutorials, references, and guides</li> <li>Feature areas: Group content by platform features and capabilities</li> </ul>"},{"location":"reference/api/","title":"API Reference","text":"<p>Complete API reference documentation for the CulicidaeLab Server.</p>"},{"location":"reference/api/#quick-start","title":"Quick Start","text":"<p>The CulicidaeLab Server API is a RESTful service built with FastAPI that provides endpoints for mosquito research, surveillance, and data analysis.</p>"},{"location":"reference/api/#base-url","title":"Base URL","text":"<pre><code>http://localhost:8000/api/v1\n</code></pre>"},{"location":"reference/api/#content-type","title":"Content Type","text":"<p>All API endpoints accept and return JSON data: <pre><code>Content-Type: application/json\n</code></pre></p>"},{"location":"reference/api/#interactive-documentation","title":"Interactive Documentation","text":"<p>FastAPI automatically generates interactive API documentation:</p> <ul> <li>Swagger UI: http://localhost:8000/docs - Interactive API explorer</li> <li>ReDoc: http://localhost:8000/redoc - Alternative documentation format</li> </ul>"},{"location":"reference/api/#openapi-specification","title":"OpenAPI Specification","text":"<p>The complete OpenAPI specification is available at: <pre><code>http://localhost:8000/api/v1/openapi.json\n</code></pre></p> <p>You can use this specification with any OpenAPI-compatible tool for: - Code generation - API testing - Documentation generation - Mock server creation</p>"},{"location":"reference/api/#api-endpoints-summary","title":"API Endpoints Summary","text":""},{"location":"reference/api/#species-management","title":"Species Management","text":"<ul> <li><code>GET /species</code> - List mosquito species with search and pagination</li> <li><code>GET /species/{species_id}</code> - Get detailed species information</li> <li><code>GET /vector-species</code> - List disease vector species</li> </ul>"},{"location":"reference/api/#disease-information","title":"Disease Information","text":"<ul> <li><code>GET /diseases</code> - List mosquito-borne diseases</li> <li><code>GET /diseases/{disease_id}</code> - Get detailed disease information</li> </ul>"},{"location":"reference/api/#geographic-data","title":"Geographic Data","text":"<ul> <li><code>GET /regions</code> - List geographic regions</li> <li><code>GET /countries</code> - List countries with mosquito data</li> </ul>"},{"location":"reference/api/#prediction-services","title":"Prediction Services","text":"<ul> <li><code>POST /predict</code> - Predict mosquito species from image</li> <li><code>POST /predict/batch</code> - Batch prediction for multiple images</li> </ul>"},{"location":"reference/api/#observation-management","title":"Observation Management","text":"<ul> <li><code>GET /observations</code> - List mosquito observations</li> <li><code>POST /observations</code> - Create new observation</li> <li><code>GET /observations/{observation_id}</code> - Get observation details</li> <li><code>PATCH /observations/{observation_id}</code> - Update observation</li> </ul>"},{"location":"reference/api/#data-filtering","title":"Data Filtering","text":"<ul> <li><code>GET /filters</code> - Get available filter options</li> <li><code>GET /filters/{filter_type}</code> - Get specific filter type options</li> </ul>"},{"location":"reference/api/#authentication","title":"Authentication","text":"<p>Currently, the API does not require authentication. Future versions may implement: - API key authentication - OAuth2 with JWT tokens - Role-based access control</p>"},{"location":"reference/api/#rate-limiting","title":"Rate Limiting","text":"<p>No rate limiting is currently implemented. Production deployments should consider: - Request rate limiting per IP - API key-based quotas - Burst protection</p>"},{"location":"reference/api/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes:</p> Status Code Description 200 Success 201 Created 400 Bad Request 404 Not Found 422 Validation Error 500 Internal Server Error"},{"location":"reference/api/#error-response-format","title":"Error Response Format","text":"<pre><code>{\n  \"detail\": \"Error description\",\n  \"type\": \"error_type\",\n  \"errors\": [\n    {\n      \"loc\": [\"field\", \"name\"],\n      \"msg\": \"Field validation error\",\n      \"type\": \"value_error\"\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/api/#pagination","title":"Pagination","text":"<p>List endpoints support pagination with query parameters:</p> <ul> <li><code>limit</code>: Maximum number of results (default: 50, max: 200)</li> <li><code>offset</code>: Number of results to skip (default: 0)</li> </ul>"},{"location":"reference/api/#pagination-response-format","title":"Pagination Response Format","text":"<pre><code>{\n  \"count\": 150,\n  \"results\": [...],\n  \"next\": \"http://localhost:8000/api/v1/species?limit=50&amp;offset=50\",\n  \"previous\": null\n}\n</code></pre>"},{"location":"reference/api/#internationalization","title":"Internationalization","text":"<p>The API supports multiple languages through the <code>lang</code> query parameter:</p> <ul> <li><code>en</code>: English (default)</li> <li><code>es</code>: Spanish</li> <li><code>ru</code>: Russian</li> <li><code>fr</code>: French</li> </ul> <p>Example: <pre><code>GET /api/v1/species?lang=es\n</code></pre></p>"},{"location":"reference/api/#data-formats","title":"Data Formats","text":""},{"location":"reference/api/#coordinates","title":"Coordinates","text":"<p>Geographic coordinates use decimal degrees: <pre><code>{\n  \"latitude\": 40.7128,\n  \"longitude\": -74.0060\n}\n</code></pre></p>"},{"location":"reference/api/#dates","title":"Dates","text":"<p>Dates and timestamps use ISO 8601 format: <pre><code>{\n  \"observed_at\": \"2024-01-15T14:30:00Z\",\n  \"created_at\": \"2024-01-15T14:30:00.123456Z\"\n}\n</code></pre></p>"},{"location":"reference/api/#images","title":"Images","text":"<p>Image uploads support: - JPEG (.jpg, .jpeg) - PNG (.png) - Maximum size: 10MB - Recommended resolution: 224x224 to 1024x1024 pixels</p>"},{"location":"reference/api/#sdk-and-client-libraries","title":"SDK and Client Libraries","text":""},{"location":"reference/api/#python-client-example","title":"Python Client Example","text":"<pre><code>import httpx\nimport asyncio\n\nasync def get_species_list():\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            \"http://localhost:8000/api/v1/species\",\n            params={\"limit\": 25, \"lang\": \"en\"}\n        )\n        return response.json()\n\n# Run the example\nspecies_data = asyncio.run(get_species_list())\nprint(f\"Found {species_data['count']} species\")\n</code></pre>"},{"location":"reference/api/#javascriptnodejs-client-example","title":"JavaScript/Node.js Client Example","text":"<pre><code>const axios = require('axios');\n\nasync function getSpeciesList() {\n  try {\n    const response = await axios.get('http://localhost:8000/api/v1/species', {\n      params: {\n        limit: 25,\n        lang: 'en'\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching species:', error.response.data);\n  }\n}\n\n// Usage\ngetSpeciesList().then(data =&gt; {\n  console.log(`Found ${data.count} species`);\n});\n</code></pre>"},{"location":"reference/api/#testing-the-api","title":"Testing the API","text":""},{"location":"reference/api/#using-curl","title":"Using curl","text":"<pre><code># Get species list\ncurl -X GET \"http://localhost:8000/api/v1/species?limit=10&amp;lang=en\"\n\n# Get specific species\ncurl -X GET \"http://localhost:8000/api/v1/species/aedes-aegypti?lang=en\"\n\n# Upload image for prediction\ncurl -X POST \"http://localhost:8000/api/v1/predict\" \\\n  -F \"image=@mosquito.jpg\" \\\n  -F \"confidence_threshold=0.7\"\n</code></pre>"},{"location":"reference/api/#using-httpie","title":"Using HTTPie","text":"<pre><code># Get species list\nhttp GET localhost:8000/api/v1/species limit==10 lang==en\n\n# Create observation\nhttp POST localhost:8000/api/v1/observations \\\n  species_id=aedes-aegypti \\\n  location:='{\"latitude\": 40.7128, \"longitude\": -74.0060}' \\\n  observer_name=\"Dr. Smith\"\n</code></pre>"},{"location":"reference/api/#detailed-api-documentation","title":"Detailed API Documentation","text":"<p>For detailed documentation of each API endpoint, including request/response schemas and examples, see:</p> <ul> <li>Species API</li> <li>Diseases API</li> <li>Geographic API</li> <li>Prediction API</li> <li>Observation API</li> <li>Filters API</li> </ul>"},{"location":"research/ai-models/","title":"AI Models","text":"<p>This document provides comprehensive documentation of the AI model architecture and prediction pipeline used in the CulicidaeLab Server for mosquito species identification.</p>"},{"location":"research/ai-models/#overview","title":"Overview","text":"<p>CulicidaeLab employs a sophisticated machine learning pipeline for automated mosquito species identification from images. The system integrates the <code>culicidaelab</code> Python library (version \u22650.2.2) with FastAI (version 2.7.0-2.8.0) to provide accurate, real-time species classification.</p>"},{"location":"research/ai-models/#model-architecture","title":"Model Architecture","text":""},{"location":"research/ai-models/#mosquitoclassifier","title":"MosquitoClassifier","text":"<p>The core AI component is the <code>MosquitoClassifier</code> class from the culicidaelab library, which provides:</p> <ul> <li>Deep Learning Framework: Built on FastAI for robust image classification</li> <li>Pre-trained Models: Leverages transfer learning from established computer vision models</li> <li>Species-Specific Training: Trained on curated mosquito image datasets</li> <li>Confidence Scoring: Provides probability distributions across species classes</li> </ul>"},{"location":"research/ai-models/#model-configuration","title":"Model Configuration","text":"<pre><code>class PredictionService:\n    def __init__(self):\n        self.model = None\n        self.model_loaded = False\n        self.lib_settings = get_settings()\n        self.save_predicted_images_enabled = app_settings.SAVE_PREDICTED_IMAGES\n</code></pre>"},{"location":"research/ai-models/#key-configuration-parameters","title":"Key Configuration Parameters:","text":"<ul> <li>Model Architecture: Configurable via <code>predictors.classifier.model_arch</code> setting</li> <li>Model Weights: Loaded from <code>predictors.classifier.filename</code> path</li> <li>Input Processing: Automatic image preprocessing and normalization</li> <li>Output Format: Structured prediction results with confidence scores</li> </ul>"},{"location":"research/ai-models/#prediction-pipeline","title":"Prediction Pipeline","text":""},{"location":"research/ai-models/#image-processing-workflow","title":"Image Processing Workflow","text":"<pre><code>flowchart TD\n    A[Raw Image Input] --&gt; B[Image Validation]\n    B --&gt; C[Format Conversion]\n    C --&gt; D[Preprocessing]\n    D --&gt; E[Model Inference]\n    E --&gt; F[Post-processing]\n    F --&gt; G[Result Generation]\n    G --&gt; H[Optional Image Storage]</code></pre>"},{"location":"research/ai-models/#1-image-input-and-validation","title":"1. Image Input and Validation","text":"<pre><code>async def predict_species(self, image_data: bytes, filename: str):\n    \"\"\"Process image data for species prediction.\"\"\"\n    image = Image.open(io.BytesIO(image_data)).convert(\"RGB\")\n    image_np = np.array(image)\n</code></pre> <p>Input Requirements: - Supported Formats: JPEG, PNG, and other PIL-compatible formats - Color Space: Automatic conversion to RGB - Size Limits: Configurable maximum image dimensions - Quality: No specific quality requirements (model handles various qualities)</p>"},{"location":"research/ai-models/#2-preprocessing-pipeline","title":"2. Preprocessing Pipeline","text":"<p>The preprocessing pipeline includes:</p> <ul> <li>Color Space Normalization: RGB conversion and channel normalization</li> <li>Resizing: Automatic scaling to model input dimensions</li> <li>Data Augmentation: Runtime augmentation for improved robustness</li> <li>Tensor Conversion: NumPy array to model-compatible format</li> </ul>"},{"location":"research/ai-models/#3-model-inference","title":"3. Model Inference","text":"<pre><code>predictions = self.model.predict(image_np)\ntop_species, top_confidence = predictions[0]\n</code></pre> <p>Inference Process: - Forward Pass: Single inference through the neural network - Probability Distribution: Softmax output across all species classes - Top-K Results: Returns ranked predictions with confidence scores - Performance: Optimized for real-time inference (&lt; 1 second typical)</p>"},{"location":"research/ai-models/#4-result-processing","title":"4. Result Processing","text":"<pre><code>result = PredictionResult(\n    scientific_name=top_species,\n    probabilities={species: float(conf) for species, conf in predictions[:2]},\n    id=species_id,\n    model_id=self.model_id,\n    confidence=float(top_confidence),\n    image_url_species=image_url_species,\n)\n</code></pre>"},{"location":"research/ai-models/#model-performance","title":"Model Performance","text":""},{"location":"research/ai-models/#accuracy-metrics","title":"Accuracy Metrics","text":"<p>The model performance is evaluated using standard classification metrics:</p> <ul> <li>Top-1 Accuracy: Percentage of correct top predictions</li> <li>Top-5 Accuracy: Percentage where correct species is in top 5 predictions</li> <li>Confidence Calibration: Alignment between predicted confidence and actual accuracy</li> <li>Species-Specific Performance: Per-species precision and recall metrics</li> </ul>"},{"location":"research/ai-models/#confidence-scoring","title":"Confidence Scoring","text":"<p>The system provides calibrated confidence scores:</p> <ul> <li>Range: 0.0 to 1.0 (0% to 100% confidence)</li> <li>Interpretation: Higher scores indicate greater model certainty</li> <li>Threshold Recommendations: </li> <li>High confidence: &gt; 0.8</li> <li>Medium confidence: 0.5 - 0.8</li> <li>Low confidence: &lt; 0.5</li> </ul>"},{"location":"research/ai-models/#supported-species","title":"Supported Species","text":"<p>The model currently supports identification of major mosquito species including:</p>"},{"location":"research/ai-models/#aedes-species","title":"Aedes Species","text":"<ul> <li>Aedes aegypti (Yellow Fever Mosquito)</li> <li>Aedes albopictus (Asian Tiger Mosquito)</li> <li>Aedes canadensis (Canada Mosquito)</li> <li>Aedes dorsalis (Coastal Rock Pool Mosquito)</li> <li>Aedes geniculatus (Treehole Mosquito)</li> <li>Aedes koreicus (Korean Bush Mosquito)</li> <li>Aedes triseriatus (Eastern Treehole Mosquito)</li> <li>Aedes vexans (Inland Floodwater Mosquito)</li> </ul>"},{"location":"research/ai-models/#anopheles-species","title":"Anopheles Species","text":"<ul> <li>Anopheles arabiensis (Arabian Malaria Mosquito)</li> <li>Anopheles freeborni (Western Malaria Mosquito)</li> <li>Anopheles sinensis (Chinese Malaria Mosquito)</li> </ul>"},{"location":"research/ai-models/#culex-species","title":"Culex Species","text":"<ul> <li>Culex inatomii</li> <li>Culex pipiens (Common House Mosquito)</li> <li>Culex quinquefasciatus (Southern House Mosquito)</li> <li>Culex tritaeniorhynchus (Japanese Encephalitis Mosquito)</li> </ul>"},{"location":"research/ai-models/#culiseta-species","title":"Culiseta Species","text":"<ul> <li>Culiseta annulata (Ringed Mosquito)</li> <li>Culiseta longiareolata (Striped Mosquito)</li> </ul>"},{"location":"research/ai-models/#integration-architecture","title":"Integration Architecture","text":""},{"location":"research/ai-models/#service-layer-integration","title":"Service Layer Integration","text":"<pre><code>class PredictionService:\n    async def load_model(self):\n        \"\"\"Load the mosquito classifier model.\"\"\"\n        self.model = MosquitoClassifier(self.lib_settings, load_model=True)\n        self.model_loaded = True\n        self.model_arch = self.lib_settings.get_config(\"predictors.classifier\").model_arch\n        self.model_id = self.lib_settings.get_config(\"predictors.classifier\").filename.split(\".\")[0]\n</code></pre>"},{"location":"research/ai-models/#api-integration","title":"API Integration","text":"<p>The prediction service integrates with the FastAPI backend through:</p> <ul> <li>Async Operations: Non-blocking model inference</li> <li>Error Handling: Comprehensive error catching and reporting</li> <li>Resource Management: Efficient model loading and memory management</li> <li>Caching: Model instance caching to avoid reload overhead</li> </ul>"},{"location":"research/ai-models/#image-storage-pipeline","title":"Image Storage Pipeline","text":"<pre><code>async def save_predicted_image(self, image_data: bytes, filename: str):\n    \"\"\"Save predicted images in multiple resolutions.\"\"\"\n    # Original resolution\n    # 224x224 thumbnail (model input size)\n    # 100x100 thumbnail (UI display)\n</code></pre> <p>Storage Features: - Multi-Resolution: Automatic generation of multiple image sizes - Async Processing: Non-blocking image saving operations - Configurable: Enable/disable via <code>SAVE_PREDICTED_IMAGES</code> setting - Organized Structure: Hierarchical directory organization by size</p>"},{"location":"research/ai-models/#model-deployment","title":"Model Deployment","text":""},{"location":"research/ai-models/#production-considerations","title":"Production Considerations","text":""},{"location":"research/ai-models/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Model Caching: Single model instance per service</li> <li>Batch Processing: Support for batch predictions (future enhancement)</li> <li>GPU Acceleration: CUDA support when available</li> <li>Memory Management: Efficient tensor memory handling</li> </ul>"},{"location":"research/ai-models/#scalability","title":"Scalability","text":"<ul> <li>Horizontal Scaling: Stateless service design enables multiple instances</li> <li>Load Balancing: Compatible with standard load balancing strategies</li> <li>Resource Monitoring: Memory and CPU usage tracking</li> <li>Auto-scaling: Container-based deployment with resource limits</li> </ul>"},{"location":"research/ai-models/#reliability","title":"Reliability","text":"<ul> <li>Error Recovery: Graceful handling of model loading failures</li> <li>Fallback Mechanisms: Degraded service modes for system resilience</li> <li>Health Checks: Model availability monitoring endpoints</li> <li>Logging: Comprehensive prediction logging for debugging</li> </ul>"},{"location":"research/ai-models/#model-updates","title":"Model Updates","text":""},{"location":"research/ai-models/#version-management","title":"Version Management","text":"<ul> <li>Model Versioning: Semantic versioning for model releases</li> <li>Backward Compatibility: API stability across model updates</li> <li>A/B Testing: Support for comparing model versions</li> <li>Rollback Capability: Quick reversion to previous model versions</li> </ul>"},{"location":"research/ai-models/#continuous-improvement","title":"Continuous Improvement","text":"<ul> <li>Performance Monitoring: Tracking prediction accuracy over time</li> <li>Data Collection: Gathering user feedback for model improvement</li> <li>Retraining Pipeline: Automated model retraining with new data</li> <li>Quality Assurance: Validation testing before model deployment</li> </ul>"},{"location":"research/ai-models/#future-enhancements","title":"Future Enhancements","text":""},{"location":"research/ai-models/#planned-improvements","title":"Planned Improvements","text":""},{"location":"research/ai-models/#model-capabilities","title":"Model Capabilities","text":"<ul> <li>Multi-Stage Classification: Genus \u2192 Species hierarchical classification</li> <li>Morphological Features: Integration of anatomical feature detection</li> <li>Life Stage Recognition: Egg, larva, pupa, adult stage identification</li> <li>Sex Determination: Male/female classification capabilities</li> </ul>"},{"location":"research/ai-models/#technical-enhancements","title":"Technical Enhancements","text":"<ul> <li>Vector Embeddings: Species similarity and clustering analysis</li> <li>Uncertainty Quantification: Bayesian approaches for better confidence estimation</li> <li>Active Learning: Intelligent sample selection for model improvement</li> <li>Federated Learning: Distributed training across research institutions</li> </ul>"},{"location":"research/ai-models/#integration-features","title":"Integration Features","text":"<ul> <li>Real-time Processing: Streaming video analysis capabilities</li> <li>Mobile Optimization: Edge deployment for field applications</li> <li>API Versioning: Multiple model versions accessible via API</li> <li>Custom Training: User-specific model fine-tuning capabilities</li> </ul>"},{"location":"research/data-models/","title":"Data Models","text":"<p>This document provides comprehensive documentation of the database schema and data structures used in the CulicidaeLab Server platform.</p>"},{"location":"research/data-models/#overview","title":"Overview","text":"<p>CulicidaeLab uses LanceDB as its primary database for storing mosquito research data. The system employs PyArrow schemas to define structured data models that support both vector operations and traditional relational queries.</p>"},{"location":"research/data-models/#database-architecture","title":"Database Architecture","text":""},{"location":"research/data-models/#lancedb-configuration","title":"LanceDB Configuration","text":"<p>The system uses LanceDB, a vector database optimized for AI applications, with the following configuration:</p> <ul> <li>Database Path: Configurable via <code>CULICIDAELAB_DATABASE_PATH</code> environment variable (default: <code>.lancedb</code>)</li> <li>Schema Definition: PyArrow schemas for type safety and performance</li> <li>Connection Management: Async connection pooling with automatic reconnection</li> </ul>"},{"location":"research/data-models/#core-data-models","title":"Core Data Models","text":""},{"location":"research/data-models/#species-data-model","title":"Species Data Model","text":"<p>The species table stores comprehensive information about mosquito species, including multilingual support and vector status.</p> <pre><code>SPECIES_SCHEMA = pa.schema([\n    pa.field(\"id\", pa.string(), nullable=False),\n    pa.field(\"scientific_name\", pa.string()),\n    pa.field(\"image_url\", pa.string()),\n    pa.field(\"vector_status\", pa.string()),\n    # Localized fields (English/Russian)\n    pa.field(\"common_name_en\", pa.string()),\n    pa.field(\"common_name_ru\", pa.string()),\n    pa.field(\"description_en\", pa.string()),\n    pa.field(\"description_ru\", pa.string()),\n    pa.field(\"key_characteristics_en\", pa.list_(pa.string())),\n    pa.field(\"key_characteristics_ru\", pa.list_(pa.string())),\n    pa.field(\"habitat_preferences_en\", pa.list_(pa.string())),\n    pa.field(\"habitat_preferences_ru\", pa.list_(pa.string())),\n    # Relational fields\n    pa.field(\"geographic_regions\", pa.list_(pa.string())),\n    pa.field(\"related_diseases\", pa.list_(pa.string())),\n    pa.field(\"related_diseases_info\", pa.list_(pa.string())),\n])\n</code></pre>"},{"location":"research/data-models/#key-features","title":"Key Features:","text":"<ul> <li>Multilingual Support: English and Russian localization for all descriptive fields</li> <li>Vector Status: Classification of disease transmission risk (High, Moderate, Low)</li> <li>Geographic Distribution: List of regions where species is found</li> <li>Disease Relationships: Links to diseases transmitted by the species</li> </ul>"},{"location":"research/data-models/#example-species-record","title":"Example Species Record:","text":"<pre><code>{\n  \"id\": \"aedes_aegypti\",\n  \"scientific_name\": \"Aedes aegypti\",\n  \"vector_status\": \"High\",\n  \"common_name_en\": \"Yellow Fever Mosquito\",\n  \"common_name_ru\": \"\u041a\u043e\u043c\u0430\u0440 \u0436\u0435\u043b\u0442\u043e\u0439 \u043b\u0438\u0445\u043e\u0440\u0430\u0434\u043a\u0438\",\n  \"geographic_regions\": [\"asia\", \"americas\", \"africa\", \"oceania\"],\n  \"related_diseases\": [\"dengue_fever\", \"yellow_fever\", \"chikungunya\", \"zika_virus\"]\n}\n</code></pre>"},{"location":"research/data-models/#disease-data-model","title":"Disease Data Model","text":"<p>The diseases table contains information about mosquito-borne diseases with multilingual descriptions and vector relationships.</p> <pre><code>DISEASES_SCHEMA = pa.schema([\n    pa.field(\"id\", pa.string(), nullable=False),\n    pa.field(\"image_url\", pa.string()),\n    # Localized fields\n    pa.field(\"name_en\", pa.string()),\n    pa.field(\"name_ru\", pa.string()),\n    pa.field(\"description_en\", pa.string()),\n    pa.field(\"description_ru\", pa.string()),\n    pa.field(\"symptoms_en\", pa.string()),\n    pa.field(\"symptoms_ru\", pa.string()),\n    pa.field(\"treatment_en\", pa.string()),\n    pa.field(\"treatment_ru\", pa.string()),\n    pa.field(\"prevention_en\", pa.string()),\n    pa.field(\"prevention_ru\", pa.string()),\n    pa.field(\"prevalence_en\", pa.string()),\n    pa.field(\"prevalence_ru\", pa.string()),\n    # Vector relationships\n    pa.field(\"vectors\", pa.list_(pa.string())),\n])\n</code></pre>"},{"location":"research/data-models/#key-features_1","title":"Key Features:","text":"<ul> <li>Comprehensive Medical Information: Symptoms, treatment, and prevention in multiple languages</li> <li>Epidemiological Data: Prevalence and geographic distribution information</li> <li>Vector Mapping: Links to mosquito species that transmit the disease</li> </ul>"},{"location":"research/data-models/#observation-data-model","title":"Observation Data Model","text":"<p>The observations table stores field observation data with geospatial information and prediction metadata.</p> <pre><code>OBSERVATIONS_SCHEMA = pa.schema([\n    pa.field(\"type\", pa.string()),\n    pa.field(\"id\", pa.string(), nullable=False),\n    pa.field(\"species_scientific_name\", pa.string()),\n    pa.field(\"observed_at\", pa.string()),\n    pa.field(\"count\", pa.int32()),\n    pa.field(\"observer_id\", pa.string()),\n    pa.field(\"location_accuracy_m\", pa.float32()),\n    pa.field(\"notes\", pa.string()),\n    pa.field(\"data_source\", pa.string()),\n    pa.field(\"image_filename\", pa.string()),\n    pa.field(\"model_id\", pa.string()),\n    pa.field(\"confidence\", pa.float32()),\n    pa.field(\"geometry_type\", pa.string()),\n    pa.field(\"coordinates\", pa.list_(pa.float32())),\n    pa.field(\"metadata\", pa.string()),\n])\n</code></pre>"},{"location":"research/data-models/#key-features_2","title":"Key Features:","text":"<ul> <li>Geospatial Data: GeoJSON-compatible coordinate storage</li> <li>AI Integration: Model predictions with confidence scores</li> <li>Data Provenance: Source tracking and observer information</li> <li>Flexible Metadata: JSON storage for additional observation details</li> </ul>"},{"location":"research/data-models/#api-schema-models","title":"API Schema Models","text":"<p>The system uses Pydantic models for API request/response validation and documentation.</p>"},{"location":"research/data-models/#observation-models","title":"Observation Models","text":"<pre><code>class Location(BaseModel):\n    \"\"\"Geographic location model.\"\"\"\n    lat: float\n    lng: float\n\nclass ObservationBase(BaseModel):\n    \"\"\"Base observation data.\"\"\"\n    type: str = \"Feature\"\n    species_scientific_name: str\n    count: int = Field(..., gt=0)\n    location: Location\n    observed_at: str\n    notes: str | None = None\n    user_id: str | None = None\n    location_accuracy_m: int | None = None\n    data_source: str | None = None\n\nclass Observation(ObservationBase):\n    \"\"\"Complete observation with system fields.\"\"\"\n    id: UUID = Field(default_factory=uuid4)\n    image_filename: str | None = None\n    model_id: str | None = None\n    confidence: float | None = None\n    metadata: dict[str, Any] | None = {}\n</code></pre>"},{"location":"research/data-models/#prediction-models","title":"Prediction Models","text":"<pre><code>class PredictionResult(BaseModel):\n    \"\"\"AI model prediction result.\"\"\"\n    id: str\n    scientific_name: str\n    probabilities: dict[str, float]\n    model_id: str\n    confidence: float\n    image_url_species: str | None = None\n</code></pre>"},{"location":"research/data-models/#species-models","title":"Species Models","text":"<pre><code>class SpeciesBase(BaseModel):\n    \"\"\"Base species information.\"\"\"\n    id: str\n    scientific_name: str\n    common_name: str | None = None\n    vector_status: str | None = None\n    image_url: str | None = None\n\nclass SpeciesDetail(SpeciesBase):\n    \"\"\"Extended species information.\"\"\"\n    description: str | None = None\n    key_characteristics: list[str] | None = None\n    geographic_regions: list[str] | None = None\n    related_diseases: list[str] | None = None\n    habitat_preferences: list[str] | None = None\n</code></pre>"},{"location":"research/data-models/#data-relationships","title":"Data Relationships","text":""},{"location":"research/data-models/#species-disease-relationships","title":"Species-Disease Relationships","text":"<ul> <li>Many-to-Many: Species can transmit multiple diseases, diseases can be transmitted by multiple species</li> <li>Implementation: Array fields in both species and disease records</li> <li>Bidirectional: Relationships maintained in both directions for query efficiency</li> </ul>"},{"location":"research/data-models/#observation-species-relationships","title":"Observation-Species Relationships","text":"<ul> <li>Many-to-One: Multiple observations can reference the same species</li> <li>Foreign Key: <code>species_scientific_name</code> field links to species table</li> <li>Validation: API layer ensures species exists before creating observations</li> </ul>"},{"location":"research/data-models/#geographic-relationships","title":"Geographic Relationships","text":"<ul> <li>Hierarchical: Regions can contain sub-regions</li> <li>Flexible: String-based region identifiers allow for various geographic scales</li> <li>Extensible: New regions can be added without schema changes</li> </ul>"},{"location":"research/data-models/#data-validation-and-constraints","title":"Data Validation and Constraints","text":""},{"location":"research/data-models/#field-validation","title":"Field Validation","text":"<ul> <li>Required Fields: Non-nullable fields enforced at schema level</li> <li>Type Safety: PyArrow schemas ensure type consistency</li> <li>Range Validation: Pydantic models provide additional validation (e.g., count &gt; 0)</li> </ul>"},{"location":"research/data-models/#data-integrity","title":"Data Integrity","text":"<ul> <li>UUID Generation: Automatic unique identifier generation for observations</li> <li>Timestamp Validation: ISO format datetime strings</li> <li>Coordinate Validation: Geographic coordinate bounds checking</li> </ul>"},{"location":"research/data-models/#multilingual-consistency","title":"Multilingual Consistency","text":"<ul> <li>Field Pairing: English and Russian fields maintained together</li> <li>Fallback Logic: API layer provides fallback to English if localized content missing</li> <li>Validation: Ensures at least one language version exists for required fields</li> </ul>"},{"location":"research/data-models/#performance-considerations","title":"Performance Considerations","text":""},{"location":"research/data-models/#indexing-strategy","title":"Indexing Strategy","text":"<ul> <li>Primary Keys: Automatic indexing on ID fields</li> <li>Geographic Queries: Spatial indexing for coordinate-based searches</li> <li>Text Search: Full-text indexing on species names and descriptions</li> </ul>"},{"location":"research/data-models/#query-optimization","title":"Query Optimization","text":"<ul> <li>Batch Operations: Bulk insert/update operations for large datasets</li> <li>Lazy Loading: Pagination support for large result sets</li> <li>Caching: Application-level caching for frequently accessed data</li> </ul>"},{"location":"research/data-models/#storage-efficiency","title":"Storage Efficiency","text":"<ul> <li>Columnar Storage: LanceDB's columnar format optimizes for analytical queries</li> <li>Compression: Automatic compression for text and array fields</li> <li>Vector Storage: Optimized storage for AI model embeddings (future enhancement)</li> </ul>"},{"location":"research/datasets/","title":"Datasets","text":"<p>This document provides comprehensive information about the datasets used in the CulicidaeLab Server platform, including sample data, training datasets, and data collection methodologies.</p>"},{"location":"research/datasets/#overview","title":"Overview","text":"<p>CulicidaeLab utilizes multiple datasets to support mosquito species identification, disease mapping, and ecological research. The platform combines curated sample data with real-world observations to provide comprehensive mosquito surveillance capabilities.</p>"},{"location":"research/datasets/#sample-datasets","title":"Sample Datasets","text":""},{"location":"research/datasets/#species-dataset","title":"Species Dataset","text":"<p>The species dataset contains comprehensive information about mosquito species worldwide, with multilingual support and detailed taxonomic information.</p> <p>Dataset Structure: - Records: 17 mosquito species across 4 genera - Languages: English and Russian localization - Fields: 16 attributes per species including taxonomy, ecology, and disease relationships</p> <p>Key Species Included:</p>"},{"location":"research/datasets/#aedes-genus-8-species","title":"Aedes Genus (8 species)","text":"<ul> <li>Aedes aegypti - Yellow Fever Mosquito</li> <li>Aedes albopictus - Asian Tiger Mosquito  </li> <li>Aedes canadensis - Canada Mosquito</li> <li>Aedes dorsalis - Coastal Rock Pool Mosquito</li> <li>Aedes geniculatus - Treehole Mosquito</li> <li>Aedes koreicus - Korean Bush Mosquito</li> <li>Aedes triseriatus - Eastern Treehole Mosquito</li> <li>Aedes vexans - Inland Floodwater Mosquito</li> </ul>"},{"location":"research/datasets/#anopheles-genus-3-species","title":"Anopheles Genus (3 species)","text":"<ul> <li>Anopheles arabiensis - Arabian Malaria Mosquito</li> <li>Anopheles freeborni - Western Malaria Mosquito</li> <li>Anopheles sinensis - Chinese Malaria Mosquito</li> </ul>"},{"location":"research/datasets/#culex-genus-4-species","title":"Culex Genus (4 species)","text":"<ul> <li>Culex inatomii</li> <li>Culex pipiens - Common House Mosquito</li> <li>Culex quinquefasciatus - Southern House Mosquito</li> <li>Culex tritaeniorhynchus - Japanese Encephalitis Mosquito</li> </ul>"},{"location":"research/datasets/#culiseta-genus-2-species","title":"Culiseta Genus (2 species)","text":"<ul> <li>Culiseta annulata - Ringed Mosquito</li> <li>Culiseta longiareolata - Striped Mosquito</li> </ul> <p>Data Attributes:</p> <pre><code>{\n  \"id\": \"species_identifier\",\n  \"scientific_name\": \"Genus species\",\n  \"vector_status\": \"High|Moderate|Low\",\n  \"image_url\": \"path/to/species/image\",\n  \"common_name_en\": \"English common name\",\n  \"common_name_ru\": \"Russian common name\",\n  \"description_en\": \"English description\",\n  \"description_ru\": \"Russian description\",\n  \"key_characteristics_en\": [\"characteristic1\", \"characteristic2\"],\n  \"key_characteristics_ru\": [\"\u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u04301\", \"\u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u04302\"],\n  \"habitat_preferences_en\": [\"habitat1\", \"habitat2\"],\n  \"habitat_preferences_ru\": [\"\u0441\u0440\u0435\u0434\u04301\", \"\u0441\u0440\u0435\u0434\u04302\"],\n  \"geographic_regions\": [\"region1\", \"region2\"],\n  \"related_diseases\": [\"disease_id1\", \"disease_id2\"]\n}\n</code></pre>"},{"location":"research/datasets/#disease-dataset","title":"Disease Dataset","text":"<p>The disease dataset contains information about mosquito-borne diseases with comprehensive medical and epidemiological data.</p> <p>Dataset Structure: - Records: 13 major mosquito-borne diseases - Languages: English and Russian medical terminology - Coverage: Global disease distribution and vector relationships</p> <p>Diseases Included:</p>"},{"location":"research/datasets/#viral-diseases","title":"Viral Diseases","text":"<ul> <li>Dengue Fever - Transmitted by Aedes aegypti, Aedes albopictus</li> <li>Zika Virus - Transmitted by Aedes aegypti, Aedes albopictus</li> <li>Chikungunya - Transmitted by Aedes aegypti, Aedes albopictus</li> <li>Yellow Fever - Transmitted by Aedes aegypti</li> <li>West Nile Virus - Transmitted by Culex pipiens, Culex quinquefasciatus</li> <li>Japanese Encephalitis - Transmitted by Culex tritaeniorhynchus</li> <li>Eastern Equine Encephalitis - Transmitted by Aedes canadensis</li> <li>St. Louis Encephalitis - Transmitted by Culex pipiens, Culex quinquefasciatus</li> <li>La Crosse Encephalitis - Transmitted by Aedes triseriatus</li> <li>Rift Valley Fever - Transmitted by multiple Culex and Aedes species</li> </ul>"},{"location":"research/datasets/#parasitic-diseases","title":"Parasitic Diseases","text":"<ul> <li>Malaria - Transmitted by Anopheles species</li> <li>Filariasis - Transmitted by Culex quinquefasciatus, Aedes aegypti</li> <li>Avian Malaria - Transmitted by Culex species</li> </ul> <p>Medical Information Fields: - Symptoms and clinical presentation - Treatment protocols and medications - Prevention strategies - Epidemiological data and prevalence - Geographic distribution - Vector species relationships</p>"},{"location":"research/datasets/#observation-dataset","title":"Observation Dataset","text":"<p>The observation dataset contains field observation records with geospatial information and metadata.</p> <p>Dataset Format: GeoJSON Feature Collection Coordinate System: WGS84 (EPSG:4326) Temporal Coverage: Configurable date ranges</p> <p>GeoJSON Structure: <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"id\": \"unique_observation_id\",\n        \"species_scientific_name\": \"Genus species\",\n        \"observed_at\": \"ISO_datetime_string\",\n        \"count\": \"number_of_specimens\",\n        \"observer_id\": \"observer_identifier\",\n        \"data_source\": \"source_information\",\n        \"location_accuracy_m\": \"accuracy_in_meters\",\n        \"notes\": \"observation_notes\",\n        \"image_filename\": \"associated_image_file\",\n        \"model_id\": \"ai_model_identifier\",\n        \"confidence\": \"prediction_confidence_score\",\n        \"metadata\": \"additional_json_metadata\"\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [longitude, latitude]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"research/datasets/#geographic-datasets","title":"Geographic Datasets","text":""},{"location":"research/datasets/#regions-dataset","title":"Regions Dataset","text":"<ul> <li>Administrative Boundaries: Country, state/province, and local regions</li> <li>Ecological Zones: Biomes, climate zones, and habitat classifications</li> <li>Multilingual Names: English and Russian region names</li> <li>Hierarchical Structure: Nested geographic relationships</li> </ul>"},{"location":"research/datasets/#data-sources-dataset","title":"Data Sources Dataset","text":"<ul> <li>Research Institutions: Universities and research organizations</li> <li>Government Agencies: Health departments and environmental agencies</li> <li>Citizen Science: Community-contributed observation platforms</li> <li>Literature Sources: Published research and survey data</li> </ul>"},{"location":"research/datasets/#training-datasets","title":"Training Datasets","text":""},{"location":"research/datasets/#image-classification-dataset","title":"Image Classification Dataset","text":"<p>The AI model training utilizes curated image datasets from the culicidaelab library:</p> <p>Dataset Characteristics: - Species Coverage: 17+ mosquito species - Image Quality: High-resolution microscopy and field photography - Standardization: Consistent lighting, background, and orientation - Augmentation: Synthetic variations for improved model robustness</p> <p>Training/Validation Split: - Training Set: 70% of images for model learning - Validation Set: 15% for hyperparameter tuning - Test Set: 15% for final performance evaluation</p> <p>Data Augmentation Techniques: - Rotation and flipping transformations - Color space adjustments - Noise injection and blur effects - Scale and crop variations</p>"},{"location":"research/datasets/#model-performance-datasets","title":"Model Performance Datasets","text":"<p>Benchmark Datasets: - Accuracy Testing: Curated test sets with expert annotations - Confidence Calibration: Datasets for confidence score validation - Cross-Validation: Multiple dataset splits for robust evaluation - Real-World Testing: Field images for practical performance assessment</p>"},{"location":"research/datasets/#data-collection-methodology","title":"Data Collection Methodology","text":""},{"location":"research/datasets/#field-observation-protocols","title":"Field Observation Protocols","text":""},{"location":"research/datasets/#standardized-collection","title":"Standardized Collection","text":"<ul> <li>GPS Coordinates: Precise location recording (\u00b15m accuracy)</li> <li>Temporal Data: Date, time, and environmental conditions</li> <li>Specimen Counts: Quantitative abundance measurements</li> <li>Photography: Standardized imaging protocols</li> <li>Metadata: Observer information and collection methods</li> </ul>"},{"location":"research/datasets/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Expert Validation: Taxonomic verification by specialists</li> <li>Data Verification: Cross-checking of observation records</li> <li>Outlier Detection: Statistical analysis for anomalous data</li> <li>Completeness Checks: Validation of required fields</li> </ul>"},{"location":"research/datasets/#image-dataset-curation","title":"Image Dataset Curation","text":""},{"location":"research/datasets/#collection-standards","title":"Collection Standards","text":"<ul> <li>Resolution Requirements: Minimum pixel dimensions for analysis</li> <li>Focus Quality: Sharpness and clarity standards</li> <li>Lighting Conditions: Consistent illumination protocols</li> <li>Background Standards: Neutral backgrounds for feature extraction</li> </ul>"},{"location":"research/datasets/#annotation-process","title":"Annotation Process","text":"<ul> <li>Expert Labeling: Species identification by taxonomists</li> <li>Multi-Reviewer Validation: Independent verification process</li> <li>Confidence Scoring: Annotation certainty levels</li> <li>Morphological Features: Detailed anatomical annotations</li> </ul>"},{"location":"research/datasets/#data-quality-and-validation","title":"Data Quality and Validation","text":""},{"location":"research/datasets/#quality-metrics","title":"Quality Metrics","text":""},{"location":"research/datasets/#completeness","title":"Completeness","text":"<ul> <li>Field Coverage: Percentage of required fields populated</li> <li>Geographic Coverage: Spatial distribution of observations</li> <li>Temporal Coverage: Time series completeness</li> <li>Species Representation: Balanced coverage across taxa</li> </ul>"},{"location":"research/datasets/#accuracy","title":"Accuracy","text":"<ul> <li>Taxonomic Validation: Expert verification of species identifications</li> <li>Coordinate Accuracy: GPS precision and validation</li> <li>Temporal Accuracy: Date/time verification protocols</li> <li>Image Quality: Technical quality assessments</li> </ul>"},{"location":"research/datasets/#consistency","title":"Consistency","text":"<ul> <li>Naming Conventions: Standardized taxonomic nomenclature</li> <li>Unit Standardization: Consistent measurement units</li> <li>Format Compliance: Schema adherence validation</li> <li>Cross-Reference Integrity: Relationship consistency checks</li> </ul>"},{"location":"research/datasets/#validation-procedures","title":"Validation Procedures","text":""},{"location":"research/datasets/#automated-validation","title":"Automated Validation","text":"<ul> <li>Schema Validation: PyArrow schema compliance checking</li> <li>Range Validation: Acceptable value range verification</li> <li>Format Validation: Data type and structure verification</li> <li>Relationship Validation: Foreign key integrity checks</li> </ul>"},{"location":"research/datasets/#manual-review","title":"Manual Review","text":"<ul> <li>Expert Review: Specialist validation of complex records</li> <li>Statistical Analysis: Outlier detection and trend analysis</li> <li>Cross-Validation: Independent verification processes</li> <li>Feedback Integration: User-reported corrections and updates</li> </ul>"},{"location":"research/datasets/#data-usage-and-licensing","title":"Data Usage and Licensing","text":""},{"location":"research/datasets/#usage-guidelines","title":"Usage Guidelines","text":""},{"location":"research/datasets/#research-applications","title":"Research Applications","text":"<ul> <li>Academic Research: Open access for educational institutions</li> <li>Commercial Use: Licensing terms for commercial applications</li> <li>Attribution Requirements: Proper citation and acknowledgment</li> <li>Modification Rights: Permissions for data enhancement</li> </ul>"},{"location":"research/datasets/#privacy-and-ethics","title":"Privacy and Ethics","text":"<ul> <li>Personal Data: Protection of observer personal information</li> <li>Location Privacy: Coordinate precision limitations for sensitive areas</li> <li>Consent Management: Observer consent for data sharing</li> <li>Ethical Guidelines: Compliance with research ethics standards</li> </ul>"},{"location":"research/datasets/#data-sharing-protocols","title":"Data Sharing Protocols","text":""},{"location":"research/datasets/#api-access","title":"API Access","text":"<ul> <li>Rate Limiting: Request throttling for fair usage</li> <li>Authentication: Secure access control mechanisms</li> <li>Format Options: Multiple export formats (JSON, CSV, GeoJSON)</li> <li>Filtering Capabilities: Query-based data subset access</li> </ul>"},{"location":"research/datasets/#bulk-downloads","title":"Bulk Downloads","text":"<ul> <li>Dataset Packages: Complete dataset downloads</li> <li>Version Control: Timestamped dataset releases</li> <li>Change Logs: Documentation of dataset updates</li> <li>Integrity Verification: Checksums and validation tools</li> </ul>"},{"location":"research/datasets/#future-dataset-enhancements","title":"Future Dataset Enhancements","text":""},{"location":"research/datasets/#planned-expansions","title":"Planned Expansions","text":""},{"location":"research/datasets/#species-coverage","title":"Species Coverage","text":"<ul> <li>Additional Genera: Expansion to other mosquito genera</li> <li>Regional Variants: Subspecies and geographic variants</li> <li>Life Stages: Egg, larva, pupa, and adult stage data</li> <li>Morphological Variants: Sexual dimorphism and seasonal variations</li> </ul>"},{"location":"research/datasets/#geographic-expansion","title":"Geographic Expansion","text":"<ul> <li>Global Coverage: Worldwide species distribution data</li> <li>Climate Data Integration: Environmental parameter correlation</li> <li>Habitat Modeling: Ecological niche modeling datasets</li> <li>Temporal Dynamics: Seasonal and annual variation data</li> </ul>"},{"location":"research/datasets/#technology-integration","title":"Technology Integration","text":"<ul> <li>Molecular Data: Genetic sequences and phylogenetic information</li> <li>Acoustic Data: Wing beat frequency and sound signatures</li> <li>Behavioral Data: Flight patterns and feeding behavior</li> <li>Environmental Sensors: Real-time environmental monitoring data</li> </ul>"},{"location":"research/datasets/#data-infrastructure-improvements","title":"Data Infrastructure Improvements","text":""},{"location":"research/datasets/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Indexing Strategies: Advanced database indexing for faster queries</li> <li>Caching Systems: Intelligent data caching for improved response times</li> <li>Compression Techniques: Efficient storage of large datasets</li> <li>Distributed Storage: Scalable storage architecture</li> </ul>"},{"location":"research/datasets/#integration-capabilities","title":"Integration Capabilities","text":"<ul> <li>External APIs: Integration with global biodiversity databases</li> <li>Real-time Feeds: Live data streaming from monitoring networks</li> <li>Collaborative Platforms: Integration with citizen science platforms</li> <li>Research Networks: Connection to international research consortiums</li> </ul>"},{"location":"research/ecosystem/","title":"CulicidaeLab Ecosystem","text":"<p>This document provides a comprehensive overview of the CulicidaeLab research ecosystem, including its components, integrations, and role in the broader mosquito research community.</p>"},{"location":"research/ecosystem/#ecosystem-overview","title":"Ecosystem Overview","text":"<p>CulicidaeLab represents a comprehensive platform for mosquito research, surveillance, and public health applications. The ecosystem combines cutting-edge AI technology, extensive biological databases, and collaborative research tools to advance our understanding of mosquito-borne diseases and vector ecology.</p>"},{"location":"research/ecosystem/#core-components","title":"Core Components","text":""},{"location":"research/ecosystem/#culicidaelab-server-platform","title":"CulicidaeLab Server Platform","text":"<p>The central hub of the ecosystem, providing:</p>"},{"location":"research/ecosystem/#backend-services","title":"Backend Services","text":"<ul> <li>FastAPI Framework: High-performance API server with automatic documentation</li> <li>LanceDB Integration: Vector database for efficient data storage and retrieval</li> <li>AI Model Services: Real-time species identification and prediction capabilities</li> <li>Geospatial Processing: Advanced geographic data analysis and visualization</li> <li>Multi-language Support: English and Russian localization</li> </ul>"},{"location":"research/ecosystem/#frontend-applications","title":"Frontend Applications","text":"<ul> <li>Solara Framework: Interactive web interface for data exploration</li> <li>Real-time Visualization: Dynamic maps and charts for data analysis</li> <li>User Management: Authentication and authorization systems</li> <li>Mobile Responsiveness: Cross-platform compatibility</li> </ul>"},{"location":"research/ecosystem/#data-management","title":"Data Management","text":"<ul> <li>Observation Tracking: Field observation recording and management</li> <li>Species Database: Comprehensive mosquito taxonomy and characteristics</li> <li>Disease Mapping: Epidemiological data and vector-disease relationships</li> <li>Image Repository: Curated image collections for AI training and reference</li> </ul>"},{"location":"research/ecosystem/#culicidaelab-python-library","title":"CulicidaeLab Python Library","text":"<p>The foundational AI library providing:</p>"},{"location":"research/ecosystem/#machine-learning-models","title":"Machine Learning Models","text":"<ul> <li>MosquitoClassifier: Deep learning model for species identification</li> <li>Transfer Learning: Pre-trained models adapted for mosquito classification</li> <li>Confidence Scoring: Calibrated probability estimates for predictions</li> <li>Model Versioning: Systematic model updates and version management</li> </ul>"},{"location":"research/ecosystem/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<ul> <li>Image Preprocessing: Standardized image preparation for analysis</li> <li>Feature Extraction: Morphological and visual feature detection</li> <li>Data Validation: Quality assurance and error detection</li> <li>Format Conversion: Multi-format data import/export capabilities</li> </ul>"},{"location":"research/ecosystem/#configuration-management","title":"Configuration Management","text":"<ul> <li>Settings Framework: Centralized configuration for all components</li> <li>Environment Adaptation: Flexible deployment across different environments</li> <li>Performance Tuning: Optimizable parameters for various use cases</li> <li>Integration APIs: Standardized interfaces for external systems</li> </ul>"},{"location":"research/ecosystem/#research-applications","title":"Research Applications","text":""},{"location":"research/ecosystem/#vector-surveillance","title":"Vector Surveillance","text":""},{"location":"research/ecosystem/#real-time-monitoring","title":"Real-time Monitoring","text":"<ul> <li>Field Data Collection: Mobile-friendly observation recording</li> <li>Automated Identification: AI-powered species classification from field images</li> <li>Geographic Tracking: Spatial distribution mapping and analysis</li> <li>Temporal Analysis: Seasonal and long-term population trend monitoring</li> </ul>"},{"location":"research/ecosystem/#early-warning-systems","title":"Early Warning Systems","text":"<ul> <li>Disease Risk Assessment: Predictive modeling for disease outbreak potential</li> <li>Population Dynamics: Monitoring of vector abundance and distribution</li> <li>Environmental Correlation: Climate and habitat factor analysis</li> <li>Alert Generation: Automated notifications for high-risk conditions</li> </ul>"},{"location":"research/ecosystem/#epidemiological-research","title":"Epidemiological Research","text":""},{"location":"research/ecosystem/#disease-mapping","title":"Disease Mapping","text":"<ul> <li>Vector-Disease Relationships: Comprehensive mapping of transmission pathways</li> <li>Geographic Distribution: Spatial analysis of disease prevalence</li> <li>Risk Modeling: Predictive models for disease transmission risk</li> <li>Intervention Planning: Data-driven public health intervention strategies</li> </ul>"},{"location":"research/ecosystem/#outbreak-investigation","title":"Outbreak Investigation","text":"<ul> <li>Rapid Response: Quick species identification during disease outbreaks</li> <li>Source Tracking: Identification of vector breeding sites and sources</li> <li>Transmission Analysis: Understanding of disease transmission patterns</li> <li>Control Effectiveness: Evaluation of intervention success rates</li> </ul>"},{"location":"research/ecosystem/#taxonomic-research","title":"Taxonomic Research","text":""},{"location":"research/ecosystem/#species-documentation","title":"Species Documentation","text":"<ul> <li>Morphological Analysis: Detailed anatomical feature documentation</li> <li>Geographic Distribution: Range mapping and habitat characterization</li> <li>Ecological Relationships: Predator-prey and competitive interactions</li> <li>Phylogenetic Analysis: Evolutionary relationships and classification</li> </ul>"},{"location":"research/ecosystem/#biodiversity-assessment","title":"Biodiversity Assessment","text":"<ul> <li>Species Inventory: Comprehensive cataloging of mosquito fauna</li> <li>Conservation Status: Assessment of rare and endangered species</li> <li>Habitat Requirements: Ecological niche characterization</li> <li>Climate Change Impact: Assessment of distribution shifts and adaptations</li> </ul>"},{"location":"research/ecosystem/#technology-integration","title":"Technology Integration","text":""},{"location":"research/ecosystem/#ai-and-machine-learning","title":"AI and Machine Learning","text":""},{"location":"research/ecosystem/#computer-vision","title":"Computer Vision","text":"<ul> <li>Deep Learning Models: Convolutional neural networks for image classification</li> <li>Feature Detection: Automated identification of taxonomic features</li> <li>Quality Assessment: Image quality evaluation and enhancement</li> <li>Batch Processing: High-throughput analysis of large image collections</li> </ul>"},{"location":"research/ecosystem/#predictive-analytics","title":"Predictive Analytics","text":"<ul> <li>Population Modeling: Forecasting of vector population dynamics</li> <li>Disease Risk Prediction: Machine learning models for outbreak prediction</li> <li>Environmental Modeling: Climate and habitat suitability analysis</li> <li>Intervention Optimization: AI-driven optimization of control strategies</li> </ul>"},{"location":"research/ecosystem/#geospatial-technology","title":"Geospatial Technology","text":""},{"location":"research/ecosystem/#gis-integration","title":"GIS Integration","text":"<ul> <li>Spatial Analysis: Advanced geographic information system capabilities</li> <li>Remote Sensing: Satellite and aerial imagery integration</li> <li>Habitat Modeling: Environmental suitability mapping</li> <li>Movement Tracking: Vector dispersal and migration analysis</li> </ul>"},{"location":"research/ecosystem/#real-time-mapping","title":"Real-time Mapping","text":"<ul> <li>Dynamic Visualization: Live updating of observation data</li> <li>Interactive Maps: User-friendly geographic data exploration</li> <li>Multi-layer Analysis: Overlay of environmental and biological data</li> <li>Mobile Mapping: Field-compatible mapping applications</li> </ul>"},{"location":"research/ecosystem/#database-technology","title":"Database Technology","text":""},{"location":"research/ecosystem/#vector-databases","title":"Vector Databases","text":"<ul> <li>LanceDB: High-performance vector storage for AI applications</li> <li>Similarity Search: Efficient nearest-neighbor queries for species matching</li> <li>Scalable Architecture: Horizontal scaling for large datasets</li> <li>Real-time Updates: Live data synchronization and updates</li> </ul>"},{"location":"research/ecosystem/#data-integration","title":"Data Integration","text":"<ul> <li>Multi-source Ingestion: Integration of diverse data sources</li> <li>Format Standardization: Consistent data formats across platforms</li> <li>Quality Assurance: Automated data validation and cleaning</li> <li>Version Control: Systematic tracking of data changes and updates</li> </ul>"},{"location":"research/ecosystem/#collaborative-network","title":"Collaborative Network","text":""},{"location":"research/ecosystem/#research-institutions","title":"Research Institutions","text":""},{"location":"research/ecosystem/#academic-partnerships","title":"Academic Partnerships","text":"<ul> <li>Universities: Collaboration with entomology and public health departments</li> <li>Research Centers: Integration with vector control and disease research facilities</li> <li>International Organizations: Partnerships with WHO, CDC, and other health agencies</li> <li>Field Stations: Connection to remote research and monitoring sites</li> </ul>"},{"location":"research/ecosystem/#data-sharing","title":"Data Sharing","text":"<ul> <li>Open Science: Commitment to open data and reproducible research</li> <li>Standardized Protocols: Common data collection and sharing standards</li> <li>Collaborative Platforms: Shared access to tools and resources</li> <li>Publication Support: Integration with scientific publishing workflows</li> </ul>"},{"location":"research/ecosystem/#public-health-agencies","title":"Public Health Agencies","text":""},{"location":"research/ecosystem/#government-integration","title":"Government Integration","text":"<ul> <li>Health Departments: Direct integration with public health surveillance systems</li> <li>Environmental Agencies: Collaboration with environmental monitoring programs</li> <li>Border Control: Support for invasive species detection and monitoring</li> <li>Emergency Response: Integration with disaster and outbreak response systems</li> </ul>"},{"location":"research/ecosystem/#policy-support","title":"Policy Support","text":"<ul> <li>Evidence-Based Policy: Data-driven support for public health policies</li> <li>Resource Allocation: Optimization of vector control resource distribution</li> <li>Intervention Planning: Strategic planning for disease prevention programs</li> <li>Performance Monitoring: Evaluation of public health intervention effectiveness</li> </ul>"},{"location":"research/ecosystem/#citizen-science","title":"Citizen Science","text":""},{"location":"research/ecosystem/#community-engagement","title":"Community Engagement","text":"<ul> <li>Volunteer Networks: Training and coordination of citizen scientists</li> <li>Mobile Applications: User-friendly tools for community data collection</li> <li>Educational Programs: Public education about mosquito ecology and disease prevention</li> <li>Feedback Systems: Community reporting and validation mechanisms</li> </ul>"},{"location":"research/ecosystem/#data-contribution","title":"Data Contribution","text":"<ul> <li>Crowdsourced Observations: Large-scale data collection through public participation</li> <li>Quality Control: Validation and verification of citizen-contributed data</li> <li>Training Materials: Educational resources for accurate data collection</li> <li>Recognition Systems: Acknowledgment and incentives for contributors</li> </ul>"},{"location":"research/ecosystem/#global-impact","title":"Global Impact","text":""},{"location":"research/ecosystem/#disease-prevention","title":"Disease Prevention","text":""},{"location":"research/ecosystem/#malaria-control","title":"Malaria Control","text":"<ul> <li>Vector Identification: Accurate identification of malaria vectors</li> <li>Resistance Monitoring: Tracking of insecticide resistance patterns</li> <li>Intervention Targeting: Precision targeting of control interventions</li> <li>Impact Assessment: Evaluation of control program effectiveness</li> </ul>"},{"location":"research/ecosystem/#arbovirus-surveillance","title":"Arbovirus Surveillance","text":"<ul> <li>Dengue Prevention: Early detection and monitoring of dengue vectors</li> <li>Zika Response: Rapid response capabilities for Zika virus outbreaks</li> <li>Chikungunya Control: Surveillance and control of chikungunya vectors</li> <li>Emerging Threats: Monitoring for new and emerging arboviral diseases</li> </ul>"},{"location":"research/ecosystem/#climate-change-adaptation","title":"Climate Change Adaptation","text":""},{"location":"research/ecosystem/#range-shift-monitoring","title":"Range Shift Monitoring","text":"<ul> <li>Distribution Changes: Tracking of species range expansions and contractions</li> <li>Climate Correlation: Analysis of climate-driven distribution changes</li> <li>Prediction Modeling: Forecasting of future distribution patterns</li> <li>Adaptation Strategies: Development of climate-adaptive control strategies</li> </ul>"},{"location":"research/ecosystem/#ecosystem-resilience","title":"Ecosystem Resilience","text":"<ul> <li>Biodiversity Conservation: Protection of mosquito biodiversity and ecosystem functions</li> <li>Habitat Restoration: Support for ecosystem restoration and conservation efforts</li> <li>Sustainable Management: Development of sustainable vector management practices</li> <li>Ecosystem Services: Recognition and protection of beneficial mosquito species</li> </ul>"},{"location":"research/ecosystem/#future-developments","title":"Future Developments","text":""},{"location":"research/ecosystem/#technology-advancement","title":"Technology Advancement","text":""},{"location":"research/ecosystem/#next-generation-ai","title":"Next-Generation AI","text":"<ul> <li>Multi-modal Learning: Integration of visual, acoustic, and molecular data</li> <li>Federated Learning: Distributed model training across research networks</li> <li>Explainable AI: Interpretable models for scientific understanding</li> <li>Real-time Processing: Edge computing for field-based analysis</li> </ul>"},{"location":"research/ecosystem/#enhanced-integration","title":"Enhanced Integration","text":"<ul> <li>IoT Sensors: Integration with environmental monitoring sensor networks</li> <li>Satellite Data: Real-time satellite imagery for habitat monitoring</li> <li>Genomic Data: Integration of molecular and genetic information</li> <li>Behavioral Analysis: Automated analysis of mosquito behavior patterns</li> </ul>"},{"location":"research/ecosystem/#ecosystem-expansion","title":"Ecosystem Expansion","text":""},{"location":"research/ecosystem/#geographic-coverage","title":"Geographic Coverage","text":"<ul> <li>Global Deployment: Worldwide expansion of monitoring networks</li> <li>Regional Adaptation: Customization for local species and conditions</li> <li>Cross-Border Collaboration: International cooperation and data sharing</li> <li>Capacity Building: Training and technology transfer to developing regions</li> </ul>"},{"location":"research/ecosystem/#interdisciplinary-integration","title":"Interdisciplinary Integration","text":"<ul> <li>One Health Approach: Integration with human, animal, and environmental health</li> <li>Social Sciences: Incorporation of social and behavioral factors</li> <li>Economics: Cost-benefit analysis and economic impact assessment</li> <li>Policy Sciences: Integration with policy development and implementation</li> </ul>"},{"location":"research/ecosystem/#sustainability-and-impact","title":"Sustainability and Impact","text":""},{"location":"research/ecosystem/#long-term-viability","title":"Long-term Viability","text":"<ul> <li>Funding Sustainability: Diversified funding sources and revenue models</li> <li>Community Ownership: Local ownership and management of monitoring systems</li> <li>Capacity Development: Training and education for sustainable operations</li> <li>Technology Transfer: Knowledge and technology sharing for global benefit</li> </ul>"},{"location":"research/ecosystem/#measurable-impact","title":"Measurable Impact","text":"<ul> <li>Health Outcomes: Quantifiable improvements in disease prevention and control</li> <li>Scientific Advancement: Contributions to mosquito ecology and disease research</li> <li>Policy Influence: Impact on public health policies and practices</li> <li>Global Cooperation: Enhancement of international collaboration and coordination</li> </ul> <p>The CulicidaeLab ecosystem represents a transformative approach to mosquito research and vector-borne disease prevention, combining advanced technology with collaborative science to address one of the world's most pressing public health challenges.</p>"},{"location":"snippets/cross-references/","title":"Cross references","text":"<p>{% set getting_started_refs = [     (\"Quick Start Guide\", \"getting-started/quick-start.md\"),     (\"Configuration\", \"getting-started/configuration.md\"),     (\"API Reference\", \"developer-guide/api-reference/index.md\") ] %}</p> <p>{% set developer_refs = [     (\"Architecture Overview\", \"developer-guide/architecture.md\"),     (\"API Reference\", \"developer-guide/api-reference/index.md\"),     (\"Testing Guidelines\", \"developer-guide/testing.md\"),     (\"Contributing\", \"developer-guide/contributing.md\") ] %}</p> <p>{% set user_guide_refs = [     (\"Platform Overview\", \"user-guide/overview.md\"),     (\"Species Prediction\", \"user-guide/species-prediction.md\"),     (\"Map Visualization\", \"user-guide/map-visualization.md\"),     (\"Troubleshooting\", \"user-guide/troubleshooting.md\") ] %}</p> <p>{% set deployment_refs = [     (\"Production Deployment\", \"deployment/production.md\"),     (\"Docker Setup\", \"deployment/docker.md\"),     (\"Monitoring\", \"deployment/monitoring.md\"),     (\"Configuration Reference\", \"reference/configuration.md\") ] %}</p> <p>{% set research_refs = [     (\"Data Models\", \"research/data-models.md\"),     (\"AI Models\", \"research/ai-models.md\"),     (\"Datasets\", \"research/datasets.md\"),     (\"API Integration\", \"developer-guide/api-reference/index.md\") ] %}</p> <p>{% macro render_cross_refs(refs, title=\"Related Pages\") %}</p> {{ title }} <ul>     {% for ref_title, ref_url in refs %}         <li> {{ ref_title }} </li>     {% endfor %}     </ul> <p>{% endmacro %}</p>"},{"location":"user-guide/data-management/","title":"Data Management Guide","text":"<p>Learn how to effectively organize, import, export, and manage mosquito surveillance and research data within the CulicidaeLab platform.</p>"},{"location":"user-guide/data-management/#overview","title":"Overview","text":"<p>The Data Management system in CulicidaeLab provides comprehensive tools for handling mosquito observation data, research datasets, and surveillance records. Whether you're managing field collection data, laboratory results, or literature records, this guide will help you organize and maintain high-quality datasets.</p>"},{"location":"user-guide/data-management/#data-types-and-structures","title":"Data Types and Structures","text":""},{"location":"user-guide/data-management/#observation-records","title":"Observation Records","text":"<p>Core Data Fields: - Species Information: Scientific name, common name, taxonomic details - Geographic Data: Latitude, longitude, location description, administrative regions - Temporal Data: Collection date, time, season - Collection Details: Method, collector, institution, project - Specimen Data: Life stage, sex, abundance, condition - Environmental Context: Habitat type, weather conditions, associated species</p> <p>Optional Fields: - Morphometric Data: Size measurements, wing length, body proportions - Genetic Information: DNA barcodes, molecular markers - Disease Status: Pathogen testing results, infection rates - Images: Specimen photographs, habitat photos - Notes: Additional observations, behavioral notes</p>"},{"location":"user-guide/data-management/#data-quality-standards","title":"Data Quality Standards","text":"<p>Required Fields: - Species identification (minimum to genus level) - Geographic coordinates or location description - Collection date - Data source and collector information</p> <p>Quality Indicators: - Coordinate Precision: GPS accuracy, coordinate uncertainty - Identification Confidence: Expert verified, probable, uncertain - Data Completeness: Percentage of fields populated - Temporal Accuracy: Date precision and reliability</p>"},{"location":"user-guide/data-management/#importing-data","title":"Importing Data","text":""},{"location":"user-guide/data-management/#supported-file-formats","title":"Supported File Formats","text":"<p>Tabular Data: - CSV (Comma-Separated Values): Most common format for spreadsheet data - Excel (.xlsx, .xls): Microsoft Excel workbooks - TSV (Tab-Separated Values): Tab-delimited text files - JSON: Structured data format for web applications</p> <p>Geographic Data: - GeoJSON: Geographic data with embedded attributes - KML/KMZ: Google Earth format files - Shapefile: Professional GIS format (requires all component files) - GPX: GPS track and waypoint data</p>"},{"location":"user-guide/data-management/#step-by-step-import-process","title":"Step-by-Step Import Process","text":""},{"location":"user-guide/data-management/#preparing-your-data","title":"Preparing Your Data","text":"<ol> <li> <p>Organize Your Spreadsheet: <pre><code>species_name | latitude | longitude | date_collected | collector | abundance\nAedes aegypti | 25.7617 | -80.1918 | 2024-03-15 | J. Smith | 12\nCulex quinquefasciatus | 25.7890 | -80.2264 | 2024-03-15 | J. Smith | 8\n</code></pre></p> </li> <li> <p>Check Data Quality:</p> </li> <li>Verify species names against accepted taxonomy</li> <li>Validate coordinate formats (decimal degrees preferred)</li> <li>Ensure date formats are consistent (YYYY-MM-DD recommended)</li> <li> <p>Remove duplicate records</p> </li> <li> <p>Standardize Field Names:</p> </li> <li>Use consistent column headers</li> <li>Follow Darwin Core standards when possible</li> <li>Avoid special characters and spaces in column names</li> </ol>"},{"location":"user-guide/data-management/#import-workflow","title":"Import Workflow","text":"<ol> <li>Access Import Tool:</li> <li>Navigate to Data Management section</li> <li>Click \"Import Data\" button</li> <li> <p>Select file type and upload method</p> </li> <li> <p>Upload File:</p> </li> <li>Drag and drop file onto upload area</li> <li>Or click \"Browse\" to select file</li> <li> <p>Wait for file validation and preview</p> </li> <li> <p>Map Fields:</p> </li> <li>Review detected column mappings</li> <li>Adjust field assignments as needed</li> <li>Set data types for each column</li> <li> <p>Configure coordinate system if needed</p> </li> <li> <p>Validate Data:</p> </li> <li>Review data quality report</li> <li>Address any validation errors</li> <li>Preview imported records</li> <li> <p>Confirm import settings</p> </li> <li> <p>Complete Import:</p> </li> <li>Click \"Import Data\" to finalize</li> <li>Monitor import progress</li> <li>Review import summary</li> <li>Check for any warnings or errors</li> </ol>"},{"location":"user-guide/data-management/#data-validation-rules","title":"Data Validation Rules","text":"<p>Automatic Checks: - Geographic Validation: Coordinates within valid ranges (-90 to 90 latitude, -180 to 180 longitude) - Date Validation: Dates in reasonable ranges (not future dates for historical data) - Species Validation: Names checked against taxonomic databases - Format Validation: Data types match expected formats</p> <p>Quality Warnings: - Coordinate Precision: Very precise coordinates may indicate GPS errors - Unusual Locations: Species found outside known ranges - Temporal Outliers: Very old or recent dates that seem unusual - Missing Data: Important fields left blank</p>"},{"location":"user-guide/data-management/#exporting-data","title":"Exporting Data","text":""},{"location":"user-guide/data-management/#export-options","title":"Export Options","text":"<p>Data Subsets: - Filtered Data: Export only records matching current filters - Selected Records: Export manually selected observations - Complete Dataset: Export all available data - Custom Queries: Export based on complex criteria</p> <p>Format Selection: - CSV: Universal format for spreadsheet applications - Excel: Formatted workbook with multiple sheets - GeoJSON: Geographic data with spatial information - Darwin Core Archive: Standardized biodiversity data format</p>"},{"location":"user-guide/data-management/#step-by-step-export-process","title":"Step-by-Step Export Process","text":"<ol> <li>Set Up Filters:</li> <li>Apply species, geographic, and temporal filters</li> <li>Select data quality thresholds</li> <li> <p>Choose specific data sources if needed</p> </li> <li> <p>Configure Export:</p> </li> <li>Select desired file format</li> <li>Choose fields to include</li> <li>Set coordinate system for geographic data</li> <li> <p>Configure date formats</p> </li> <li> <p>Generate Export:</p> </li> <li>Click \"Export Data\" button</li> <li>Wait for file generation</li> <li>Download completed file</li> <li>Verify export contents</li> </ol>"},{"location":"user-guide/data-management/#custom-export-templates","title":"Custom Export Templates","text":"<p>Research Templates: - Ecological Survey: Fields relevant for ecological studies - Medical Entomology: Vector-focused data fields - Taxonomic Study: Morphological and identification data - Surveillance Report: Public health monitoring format</p> <p>Creating Custom Templates: 1. Define required fields for your use case 2. Set default filters and quality criteria 3. Configure output format and styling 4. Save template for future use 5. Share templates with collaborators</p>"},{"location":"user-guide/data-management/#data-organization","title":"Data Organization","text":""},{"location":"user-guide/data-management/#project-management","title":"Project Management","text":"<p>Creating Projects: 1. Define Project Scope: Geographic area, time period, objectives 2. Set Data Standards: Required fields, quality criteria, naming conventions 3. Assign Permissions: Control who can view, edit, or export data 4. Configure Workflows: Data entry, validation, and approval processes</p> <p>Project Structure: <pre><code>Project: Urban Aedes Survey 2024\n\u251c\u2500\u2500 Field Collections/\n\u2502   \u251c\u2500\u2500 Site A - Downtown\n\u2502   \u251c\u2500\u2500 Site B - Residential\n\u2502   \u2514\u2500\u2500 Site C - Industrial\n\u251c\u2500\u2500 Laboratory Results/\n\u2502   \u251c\u2500\u2500 Species Confirmations\n\u2502   \u251c\u2500\u2500 Pathogen Testing\n\u2502   \u2514\u2500\u2500 Morphometric Data\n\u2514\u2500\u2500 Analysis Results/\n    \u251c\u2500\u2500 Species Distribution Maps\n    \u251c\u2500\u2500 Abundance Trends\n    \u2514\u2500\u2500 Risk Assessment\n</code></pre></p>"},{"location":"user-guide/data-management/#data-categories","title":"Data Categories","text":"<p>By Collection Method: - Active Surveillance: Targeted collection efforts - Passive Surveillance: Opportunistic observations - Citizen Science: Community-contributed data - Literature Records: Published observation data - Museum Specimens: Historical collection records</p> <p>By Data Source: - Field Collections: Direct specimen collection - Trap Monitoring: Systematic trap networks - Visual Observations: Sight records without collection - Photographic Records: Image-based identifications - Molecular Data: DNA-based identifications</p>"},{"location":"user-guide/data-management/#metadata-management","title":"Metadata Management","text":"<p>Dataset Metadata: - Title and Description: Clear, descriptive names - Temporal Coverage: Start and end dates - Geographic Coverage: Bounding box or region names - Taxonomic Coverage: Species or groups included - Collection Methods: Sampling protocols used - Data Quality: Completeness and accuracy metrics</p> <p>Record-Level Metadata: - Data Provenance: Source and collection history - Quality Assessments: Confidence scores and validation status - Processing History: Modifications and corrections made - Usage Rights: Licensing and attribution requirements</p>"},{"location":"user-guide/data-management/#data-quality-control","title":"Data Quality Control","text":""},{"location":"user-guide/data-management/#quality-assessment","title":"Quality Assessment","text":"<p>Automated Quality Checks: - Completeness: Percentage of required fields populated - Consistency: Internal data consistency checks - Validity: Values within acceptable ranges - Accuracy: Comparison with reference datasets</p> <p>Manual Review Process: 1. Initial Screening: Check for obvious errors 2. Expert Review: Taxonomic and geographic validation 3. Cross-Validation: Compare with other datasets 4. Community Review: Peer verification process</p>"},{"location":"user-guide/data-management/#error-detection-and-correction","title":"Error Detection and Correction","text":"<p>Common Data Errors: - Coordinate Errors: Swapped latitude/longitude, wrong decimal places - Date Errors: Incorrect formats, impossible dates - Species Misidentification: Incorrect taxonomic assignments - Duplicate Records: Same observation entered multiple times</p> <p>Correction Workflow: 1. Identify Errors: Use validation tools and expert review 2. Document Issues: Record error types and sources 3. Implement Corrections: Make necessary data changes 4. Track Changes: Maintain audit trail of modifications 5. Verify Fixes: Confirm corrections resolve issues</p>"},{"location":"user-guide/data-management/#data-standardization","title":"Data Standardization","text":"<p>Taxonomic Standardization: - Authority Files: Use accepted taxonomic databases - Synonym Resolution: Map alternative names to accepted names - Hierarchical Validation: Ensure taxonomic consistency - Regular Updates: Keep taxonomy current with revisions</p> <p>Geographic Standardization: - Coordinate Systems: Standardize to WGS84 decimal degrees - Administrative Boundaries: Use standard geographic codes - Place Names: Standardize location descriptions - Precision Indicators: Record coordinate uncertainty</p>"},{"location":"user-guide/data-management/#collaboration-and-sharing","title":"Collaboration and Sharing","text":""},{"location":"user-guide/data-management/#data-sharing-protocols","title":"Data Sharing Protocols","text":"<p>Access Levels: - Public: Open access for all users - Registered Users: Access for platform members - Project Members: Restricted to project participants - Private: Access only for data owners</p> <p>Sharing Agreements: - Data Use Agreements: Terms and conditions for data use - Attribution Requirements: How to cite data sources - Embargo Periods: Temporary restrictions on data access - Commercial Use: Policies for commercial applications</p>"},{"location":"user-guide/data-management/#collaborative-workflows","title":"Collaborative Workflows","text":"<p>Multi-User Projects: 1. Role Assignment: Define user roles and permissions 2. Data Entry Standards: Establish consistent protocols 3. Review Processes: Implement quality control workflows 4. Communication Tools: Coordinate team activities 5. Version Control: Track changes and updates</p> <p>Data Integration: - Cross-Project Sharing: Share data between related projects - External Databases: Connect with other data sources - API Integration: Programmatic data exchange - Federated Search: Query multiple databases simultaneously</p>"},{"location":"user-guide/data-management/#advanced-data-management","title":"Advanced Data Management","text":""},{"location":"user-guide/data-management/#database-administration","title":"Database Administration","text":"<p>Performance Optimization: - Indexing: Optimize database queries - Archiving: Move old data to long-term storage - Backup Procedures: Regular data backup and recovery - Monitoring: Track database performance and usage</p> <p>Data Lifecycle Management: - Ingestion: Automated data import processes - Processing: Data cleaning and standardization - Storage: Efficient data organization and retrieval - Archival: Long-term preservation strategies - Disposal: Secure deletion of obsolete data</p>"},{"location":"user-guide/data-management/#api-and-programmatic-access","title":"API and Programmatic Access","text":"<p>REST API Endpoints: <pre><code># Get observations by species\nGET /api/v1/observations?species=Aedes aegypti\n\n# Upload new observations\nPOST /api/v1/observations\n{\n  \"species\": \"Aedes aegypti\",\n  \"latitude\": 25.7617,\n  \"longitude\": -80.1918,\n  \"date\": \"2024-03-15\",\n  \"abundance\": 12\n}\n\n# Export filtered data\nGET /api/v1/export?format=csv&amp;species=Aedes&amp;start_date=2024-01-01\n</code></pre></p> <p>Bulk Operations: - Batch Import: Upload large datasets efficiently - Bulk Updates: Modify multiple records simultaneously - Mass Export: Download large datasets - Automated Processing: Schedule regular data operations</p>"},{"location":"user-guide/data-management/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/data-management/#import-problems","title":"Import Problems","text":"<p>File Format Issues: - Encoding Problems: Use UTF-8 encoding for international characters - Delimiter Confusion: Ensure correct separator (comma, tab, semicolon) - Quote Characters: Handle embedded quotes and special characters - Line Endings: Address Windows/Mac/Linux line ending differences</p> <p>Data Format Problems: - Date Formats: Standardize date representations - Coordinate Formats: Convert to decimal degrees - Species Names: Check spelling and taxonomic authority - Missing Values: Handle empty cells appropriately</p>"},{"location":"user-guide/data-management/#performance-issues","title":"Performance Issues","text":"<p>Large Dataset Handling: - Chunked Processing: Process data in smaller batches - Streaming Import: Handle files too large for memory - Progress Monitoring: Track import/export progress - Error Recovery: Resume interrupted operations</p> <p>Query Optimization: - Efficient Filters: Use indexed fields for filtering - Limit Results: Paginate large result sets - Cache Results: Store frequently accessed data - Parallel Processing: Use multiple threads for operations</p>"},{"location":"user-guide/data-management/#data-quality-issues","title":"Data Quality Issues","text":"<p>Validation Failures: - Coordinate Validation: Check for reasonable geographic locations - Date Validation: Ensure dates are within expected ranges - Species Validation: Verify against taxonomic databases - Completeness Checks: Identify missing required fields</p> <p>Consistency Problems: - Duplicate Detection: Identify and merge duplicate records - Conflicting Information: Resolve contradictory data - Standardization Issues: Ensure consistent data formats - Reference Mismatches: Align with external databases</p>"},{"location":"user-guide/data-management/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/data-management/#data-entry","title":"Data Entry","text":"<p>Standardization: - Controlled Vocabularies: Use standardized terms and codes - Data Templates: Provide consistent data entry forms - Validation Rules: Implement real-time data validation - Training Materials: Educate users on data standards</p> <p>Quality Control: - Double Entry: Verify critical data through re-entry - Expert Review: Have specialists validate identifications - Cross-Validation: Compare with independent sources - Regular Audits: Periodic data quality assessments</p>"},{"location":"user-guide/data-management/#data-preservation","title":"Data Preservation","text":"<p>Backup Strategies: - Multiple Copies: Maintain redundant backups - Geographic Distribution: Store backups in different locations - Regular Testing: Verify backup integrity and restoration - Version Control: Track data changes over time</p> <p>Long-term Preservation: - Standard Formats: Use widely supported file formats - Metadata Documentation: Maintain comprehensive documentation - Migration Planning: Prepare for technology changes - Access Preservation: Ensure continued data accessibility</p>"},{"location":"user-guide/data-management/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/data-management/#general-questions","title":"General Questions","text":"<p>Q: What data formats are supported for import? A: The platform supports CSV, Excel, JSON, GeoJSON, KML, and Shapefile formats. CSV is recommended for most tabular data imports.</p> <p>Q: How do I ensure my data meets quality standards? A: Use the built-in validation tools, follow the data entry guidelines, and consider expert review for critical identifications. The platform provides quality scores and validation reports.</p> <p>Q: Can I edit data after importing it? A: Yes, you can edit individual records or perform bulk updates. All changes are tracked in an audit trail for transparency and quality control.</p>"},{"location":"user-guide/data-management/#technical-questions","title":"Technical Questions","text":"<p>Q: What's the maximum file size for imports? A: File size limits depend on your account type and server configuration. Large datasets can be imported in chunks or through the API for better performance.</p> <p>Q: How do I handle coordinate system conversions? A: The platform automatically converts common coordinate systems to WGS84. For specialized projections, convert your data before import or contact support.</p> <p>Q: Can I automate data imports? A: Yes, use the REST API for automated imports. You can set up scheduled imports or integrate with existing data collection systems.</p>"},{"location":"user-guide/data-management/#data-policy-questions","title":"Data Policy Questions","text":"<p>Q: Who owns the data I upload? A: You retain ownership of your data. The platform provides tools for sharing and collaboration while respecting your data rights and privacy preferences.</p> <p>Q: How is sensitive location data protected? A: The platform offers options to obscure precise coordinates for sensitive species or locations. You can set privacy levels for different types of data.</p> <p>Q: Can I delete my data? A: Yes, you can delete your own data at any time. However, consider the impact on collaborative projects and published research before removing shared data.</p>"},{"location":"user-guide/data-management/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/data-management/#support-resources","title":"Support Resources","text":"<ul> <li>Documentation: Comprehensive guides and tutorials</li> <li>Video Tutorials: Step-by-step visual instructions</li> <li>Template Downloads: Standard data formats and examples</li> <li>Community Forum: User discussions and shared solutions</li> </ul>"},{"location":"user-guide/data-management/#technical-support","title":"Technical Support","text":"<ul> <li>Help Desk: Direct support for technical issues</li> <li>Training Sessions: Scheduled group training</li> <li>Consultation Services: Expert assistance for complex projects</li> <li>Custom Development: Specialized features for institutional users</li> </ul>"},{"location":"user-guide/data-management/#data-services","title":"Data Services","text":"<ul> <li>Data Cleaning: Professional data quality improvement</li> <li>Migration Services: Help moving from other systems</li> <li>Integration Support: Connecting with existing workflows</li> <li>Training Programs: Comprehensive user education</li> </ul>"},{"location":"user-guide/data-management/#next-steps","title":"Next Steps","text":"<p>After mastering data management:</p> <ol> <li>Advanced Analysis: Learn statistical analysis and modeling techniques</li> <li>API Development: Build custom applications and integrations</li> <li>Data Contribution: Share your datasets with the research community</li> <li>Quality Assurance: Become a data validator and reviewer</li> </ol> <p>For institutional users: - Enterprise Features: Advanced permissions and workflow management - Custom Integrations: Connect with institutional databases - Bulk Processing: Handle large-scale data operations - Professional Services: Dedicated support and consulting</p>"},{"location":"user-guide/diseases-database/","title":"Diseases Database Guide","text":"<p>Learn how to effectively browse, search, and explore comprehensive information about mosquito-borne diseases in the CulicidaeLab platform.</p>"},{"location":"user-guide/diseases-database/#overview","title":"Overview","text":"<p>The Diseases Database provides detailed information about vector-borne diseases transmitted by mosquitoes, including comprehensive disease profiles, transmission data, prevention strategies, and epidemiological information. This resource serves researchers, public health professionals, educators, and anyone interested in understanding mosquito-borne disease risks and prevention.</p>"},{"location":"user-guide/diseases-database/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/diseases-database/#accessing-the-diseases-database","title":"Accessing the Diseases Database","text":"<ol> <li>Click the Diseases tab in the main navigation bar</li> <li>The Disease Gallery will load, displaying all available diseases</li> <li>Use the search functionality to find specific diseases</li> <li>Click on any disease card to view detailed information</li> </ol>"},{"location":"user-guide/diseases-database/#interface-overview","title":"Interface Overview","text":"<p>Gallery View Components: - Search Bar: Text-based search across disease names and characteristics - Disease Grid: Responsive grid layout of disease cards - Loading Indicators: Visual feedback during data retrieval - Language Support: Multi-language disease information</p> <p>Disease Card Information: - Disease Name: Common and scientific names - Pathogen Type: Virus, bacteria, parasite classification - Primary Vectors: Main mosquito species involved in transmission - Geographic Distribution: Global occurrence patterns - Severity Rating: Public health importance indicator</p>"},{"location":"user-guide/diseases-database/#search-functionality","title":"Search Functionality","text":""},{"location":"user-guide/diseases-database/#basic-text-search","title":"Basic Text Search","text":"<p>How to Search: 1. Enter Search Terms: Type in the search box at the top of the gallery 2. Search Coverage: The system searches across:    - Disease names (common and scientific)    - Pathogen names and types    - Vector species names    - Geographic regions and countries    - Symptoms and clinical manifestations    - Alternative names and synonyms</p> <ol> <li>Execute Search: Click the \"Search\" button or press Enter</li> <li>View Results: Filtered diseases appear in the grid below</li> </ol>"},{"location":"user-guide/diseases-database/#search-examples","title":"Search Examples","text":"<p>Disease Name Search: - <code>dengue</code> - Find dengue fever information - <code>malaria</code> - Find malaria-related diseases - <code>Zika</code> - Find Zika virus disease - <code>chikungunya</code> - Find chikungunya fever - <code>yellow fever</code> - Find yellow fever information</p> <p>Pathogen Type Search: - <code>virus</code> - Find all viral diseases - <code>parasite</code> - Find parasitic diseases (e.g., malaria) - <code>bacteria</code> - Find bacterial infections - <code>arbovirus</code> - Find arthropod-borne viruses</p> <p>Vector Search: - <code>Aedes aegypti</code> - Find diseases transmitted by this species - <code>Anopheles</code> - Find diseases transmitted by Anopheles mosquitoes - <code>Culex</code> - Find Culex-transmitted diseases</p> <p>Geographic Search: - <code>tropical</code> - Find diseases in tropical regions - <code>Africa</code> - Find diseases endemic to Africa - <code>Americas</code> - Find diseases in the Americas - <code>Asia</code> - Find Asian diseases</p> <p>Symptom Search: - <code>fever</code> - Find diseases causing fever - <code>hemorrhagic</code> - Find hemorrhagic fevers - <code>encephalitis</code> - Find diseases causing brain inflammation - <code>rash</code> - Find diseases with skin manifestations</p>"},{"location":"user-guide/diseases-database/#advanced-search-tips","title":"Advanced Search Tips","text":"<p>Partial Matching: - Search terms can be partial words - <code>deng</code> finds dengue-related diseases - <code>enceph</code> finds encephalitis diseases</p> <p>Multiple Terms: - Use spaces for multiple search terms - <code>viral fever</code> finds viral diseases causing fever - <code>Aedes virus</code> finds viral diseases transmitted by Aedes mosquitoes</p> <p>Case Insensitive: - Search is not case-sensitive - <code>MALARIA</code>, <code>malaria</code>, and <code>Malaria</code> all work identically</p>"},{"location":"user-guide/diseases-database/#disease-information","title":"Disease Information","text":""},{"location":"user-guide/diseases-database/#disease-card-details","title":"Disease Card Details","text":"<p>Each disease card in the gallery provides:</p> <p>Basic Information: - Disease Name: Primary common name and alternatives - Pathogen: Causative agent (virus, bacteria, parasite) - Disease Family: Taxonomic classification of pathogen - ICD Code: International Classification of Diseases code</p> <p>Transmission Information: - Primary Vectors: Main mosquito species responsible for transmission - Secondary Vectors: Additional species capable of transmission - Transmission Cycle: Enzootic, epidemic, or endemic patterns - Vector Competence: Efficiency of different vector species</p> <p>Geographic Distribution: - Endemic Areas: Regions where disease is regularly present - Epidemic Zones: Areas with periodic outbreaks - Risk Maps: Visual representation of transmission risk - Seasonal Patterns: Temporal variation in transmission</p>"},{"location":"user-guide/diseases-database/#detailed-disease-profiles","title":"Detailed Disease Profiles","text":"<p>Click on any disease card to access comprehensive information:</p> <p>Pathogen Information: - Scientific Classification: Complete taxonomic hierarchy - Genome Type: DNA/RNA structure and characteristics - Serotypes/Strains: Different variants and their properties - Evolution: Phylogenetic relationships and origins - Laboratory Diagnosis: Detection and identification methods</p> <p>Clinical Manifestations: - Incubation Period: Time from infection to symptom onset - Acute Phase: Initial symptoms and clinical presentation - Severe Forms: Complications and severe manifestations - Chronic Effects: Long-term health consequences - Case Fatality Rate: Mortality statistics and risk factors</p> <p>Transmission Dynamics: - Vector Biology: Mosquito species and their characteristics - Transmission Cycle: Sylvatic, urban, and intermediate cycles - Amplification Hosts: Animal reservoirs and their role - Environmental Factors: Climate and habitat influences - Human Factors: Behavior and demographic influences</p> <p>Epidemiology: - Global Distribution: Worldwide occurrence patterns - Historical Outbreaks: Major epidemics and their impact - Current Status: Recent trends and surveillance data - Risk Factors: Individual and population-level risks - Burden of Disease: Morbidity and mortality statistics</p> <p>Prevention and Control: - Vector Control: Mosquito management strategies - Personal Protection: Individual prevention measures - Vaccination: Available vaccines and their effectiveness - Surveillance: Monitoring and early warning systems - Public Health Response: Outbreak investigation and control</p>"},{"location":"user-guide/diseases-database/#step-by-step-tutorial-exploring-dengue-fever","title":"Step-by-Step Tutorial: Exploring Dengue Fever","text":"<p>Let's walk through a comprehensive exploration of one of the most important mosquito-borne diseases:</p>"},{"location":"user-guide/diseases-database/#step-1-search-for-dengue","title":"Step 1: Search for Dengue","text":"<ol> <li>Navigate to Diseases Database: Click the \"Diseases\" tab</li> <li>Enter Search Term: Type \"dengue\" in the search box</li> <li>Execute Search: Click the search button or press Enter</li> <li>Locate Disease Card: Find the dengue fever card in the results</li> </ol> <p>Expected Results: - Dengue fever card prominently displayed - Viral pathogen classification - Aedes aegypti listed as primary vector - Global tropical distribution indicated</p>"},{"location":"user-guide/diseases-database/#step-2-review-gallery-information","title":"Step 2: Review Gallery Information","text":"<p>Quick Assessment from Card: - Pathogen Type: Dengue virus (DENV), Flavivirus family - Primary Vector: Aedes aegypti (yellow fever mosquito) - Secondary Vector: Aedes albopictus (Asian tiger mosquito) - Distribution: Tropical and subtropical regions worldwide - Severity: Major public health concern</p>"},{"location":"user-guide/diseases-database/#step-3-access-detailed-profile","title":"Step 3: Access Detailed Profile","text":"<ol> <li>Click Disease Card: Click anywhere on the dengue fever card</li> <li>Navigate to Detail View: Comprehensive disease profile loads</li> <li>Explore Sections: Browse through different information categories</li> </ol> <p>Detailed Information Available: - Four Serotypes: DENV-1, DENV-2, DENV-3, DENV-4 - Clinical Spectrum: From mild fever to severe dengue hemorrhagic fever - Transmission: Urban cycle involving humans and Aedes mosquitoes - Global Impact: 390 million infections annually, 96 million symptomatic</p>"},{"location":"user-guide/diseases-database/#step-4-understand-transmission-dynamics","title":"Step 4: Understand Transmission Dynamics","text":"<ol> <li>Vector Information: Learn about Aedes aegypti biology</li> <li>Transmission Cycle: Understand human-mosquito-human cycle</li> <li>Environmental Factors: Climate and urbanization influences</li> <li>Risk Factors: Population density, water storage, travel</li> </ol> <p>Key Transmission Concepts: - Urban Adaptation: Aedes aegypti thrives in urban environments - Container Breeding: Artificial water containers as breeding sites - Day-biting Behavior: Peak activity during morning and evening - Multiple Blood Meals: Enables virus transmission between hosts</p>"},{"location":"user-guide/diseases-database/#step-5-explore-prevention-strategies","title":"Step 5: Explore Prevention Strategies","text":"<ol> <li>Vector Control: Integrated mosquito management approaches</li> <li>Personal Protection: Individual prevention measures</li> <li>Community Action: Neighborhood-level interventions</li> <li>Surveillance: Early detection and response systems</li> </ol> <p>Prevention Approaches: - Source Reduction: Eliminate mosquito breeding sites - Biological Control: Use of natural predators and pathogens - Chemical Control: Targeted insecticide applications - Personal Protection: Repellents, protective clothing, bed nets</p>"},{"location":"user-guide/diseases-database/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/diseases-database/#disease-comparison-tools","title":"Disease Comparison Tools","text":"<p>Comparative Analysis: - Side-by-Side Viewing: Compare multiple diseases simultaneously - Vector Overlap: Identify diseases sharing common vectors - Geographic Overlap: Diseases co-occurring in same regions - Clinical Similarities: Diseases with similar symptoms</p> <p>Differential Diagnosis: - Symptom Comparison: Distinguish between similar diseases - Laboratory Tests: Diagnostic approaches for each disease - Epidemiological Clues: Geographic and temporal factors - Clinical Decision Trees: Systematic diagnostic approaches</p>"},{"location":"user-guide/diseases-database/#risk-assessment-tools","title":"Risk Assessment Tools","text":"<p>Geographic Risk Analysis: - Distribution Maps: Current and projected disease ranges - Climate Suitability: Environmental factors affecting transmission - Vector Distribution: Mosquito species occurrence patterns - Population at Risk: Demographic vulnerability assessments</p> <p>Temporal Risk Patterns: - Seasonal Transmission: Monthly and seasonal variation - Epidemic Cycles: Multi-year outbreak patterns - Climate Influences: Weather and climate change impacts - Surveillance Trends: Recent changes in disease patterns</p>"},{"location":"user-guide/diseases-database/#prevention-planning","title":"Prevention Planning","text":"<p>Integrated Vector Management: - Multi-disease Approaches: Strategies targeting multiple diseases - Cost-effectiveness: Economic evaluation of interventions - Community Engagement: Participatory prevention programs - Sustainability: Long-term program maintenance</p> <p>Emergency Response: - Outbreak Investigation: Systematic epidemic response - Rapid Assessment: Quick evaluation of outbreak scope - Control Measures: Emergency intervention strategies - Communication: Public health messaging and media relations</p>"},{"location":"user-guide/diseases-database/#mobile-and-field-applications","title":"Mobile and Field Applications","text":""},{"location":"user-guide/diseases-database/#field-reference","title":"Field Reference","text":"<p>Mobile Optimization: - Offline Access: Cached disease information for field use - Quick Reference: Rapid access to key disease facts - Symptom Guides: Clinical recognition aids - Vector Identification: Links to mosquito identification tools</p> <p>Outbreak Investigation: - Case Definitions: Standardized disease definitions - Investigation Protocols: Systematic outbreak response procedures - Sample Collection: Specimen collection and handling guidelines - Reporting Forms: Standardized surveillance reporting</p>"},{"location":"user-guide/diseases-database/#public-health-applications","title":"Public Health Applications","text":"<p>Surveillance Support: - Case Reporting: Standardized surveillance case definitions - Laboratory Confirmation: Diagnostic testing guidelines - Contact Tracing: Exposure investigation procedures - Risk Communication: Public messaging templates</p> <p>Prevention Programs: - Community Education: Health promotion materials - Vector Control: Integrated management strategies - Vaccination Programs: Immunization guidelines and schedules - Travel Health: Pre-travel consultation resources</p>"},{"location":"user-guide/diseases-database/#data-quality-and-sources","title":"Data Quality and Sources","text":""},{"location":"user-guide/diseases-database/#information-standards","title":"Information Standards","text":"<p>Scientific Accuracy: - Peer Review: All information based on published research - Expert Validation: Content reviewed by disease specialists - Regular Updates: Information updated as new research emerges - Source Documentation: References provided for all claims</p> <p>Global Standards: - WHO Guidelines: Aligned with World Health Organization recommendations - CDC Standards: Consistent with Centers for Disease Control guidelines - International Codes: Uses standard disease classification systems - Surveillance Definitions: Follows international case definitions</p>"},{"location":"user-guide/diseases-database/#data-sources","title":"Data Sources","text":"<p>Primary Sources: - Scientific Literature: Peer-reviewed research publications - Surveillance Reports: National and international surveillance data - WHO Publications: World Health Organization technical reports - CDC Resources: Centers for Disease Control prevention guidelines</p> <p>Expert Networks: - Academic Institutions: University research centers - Public Health Agencies: National and international health organizations - Professional Societies: Medical and entomological associations - Field Experts: Practitioners with direct experience</p>"},{"location":"user-guide/diseases-database/#integration-with-other-platform-features","title":"Integration with Other Platform Features","text":""},{"location":"user-guide/diseases-database/#vector-disease-connections","title":"Vector-Disease Connections","text":"<p>Species Database Links: 1. Vector Information: Direct links to mosquito species profiles 2. Competence Data: Vector efficiency for disease transmission 3. Distribution Overlap: Geographic co-occurrence of vectors and diseases 4. Control Implications: Integrated vector-disease management</p>"},{"location":"user-guide/diseases-database/#map-visualization-integration","title":"Map Visualization Integration","text":"<p>Geographic Analysis: 1. Disease Distribution: View occurrence maps and risk areas 2. Vector Mapping: Overlay vector and disease distributions 3. Outbreak Tracking: Temporal and spatial outbreak analysis 4. Risk Modeling: Environmental suitability mapping</p>"},{"location":"user-guide/diseases-database/#prediction-tool-integration","title":"Prediction Tool Integration","text":"<p>Surveillance Applications: 1. Vector Identification: Link mosquito identification to disease risk 2. Risk Assessment: Evaluate transmission potential based on vector presence 3. Early Warning: Combine vector surveillance with disease monitoring 4. Targeted Control: Focus interventions based on vector-disease relationships</p>"},{"location":"user-guide/diseases-database/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/diseases-database/#search-problems","title":"Search Problems","text":"<p>No Results Found: - Check Spelling: Verify disease name spelling - Try Synonyms: Use alternative disease names - Use Broader Terms: Search for disease categories (e.g., \"viral\") - Clear Filters: Remove any active search filters</p> <p>Too Many Results: - Be More Specific: Use complete disease names - Add Geographic Terms: Include location information - Specify Pathogen Type: Add \"virus,\" \"bacteria,\" or \"parasite\" - Use Vector Names: Include mosquito species names</p>"},{"location":"user-guide/diseases-database/#display-issues","title":"Display Issues","text":"<p>Slow Loading: - Check Internet Connection: Ensure stable connectivity - Clear Browser Cache: Remove stored temporary files - Close Other Applications: Free up system resources - Try Different Browser: Test with alternative browser</p> <p>Missing Information: - Refresh Page: Reload the disease profile - Check Data Availability: Some diseases may have limited information - Report Issues: Contact support for missing or incorrect data - Try Alternative Sources: Cross-reference with other databases</p>"},{"location":"user-guide/diseases-database/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/diseases-database/#research-applications","title":"Research Applications","text":"<p>Literature Research: - Use Standard Names: Always use accepted disease nomenclature - Check Multiple Sources: Cross-reference information - Note Data Currency: Check when information was last updated - Document Sources: Keep track of information sources</p> <p>Risk Assessment: - Consider Local Context: Adapt global information to local conditions - Evaluate Multiple Factors: Consider vectors, climate, and population - Use Current Data: Ensure information reflects recent conditions - Consult Experts: Seek local expertise for specific situations</p>"},{"location":"user-guide/diseases-database/#public-health-practice","title":"Public Health Practice","text":"<p>Surveillance Planning: - Define Objectives: Clear goals for surveillance activities - Select Indicators: Appropriate measures for monitoring - Establish Protocols: Standardized procedures for data collection - Plan Response: Predetermined actions based on surveillance findings</p> <p>Prevention Programs: - Evidence-Based Interventions: Use proven prevention strategies - Community Engagement: Involve local populations in prevention efforts - Integrated Approaches: Combine multiple prevention methods - Monitor Effectiveness: Evaluate program impact and adjust as needed</p>"},{"location":"user-guide/diseases-database/#educational-use","title":"Educational Use","text":"<p>Teaching Applications: - Case Studies: Use real disease examples for learning - Interactive Exploration: Encourage hands-on database exploration - Comparative Analysis: Compare different diseases and their characteristics - Current Events: Connect database information to recent outbreaks</p> <p>Student Projects: - Research Assignments: Use database for disease research projects - Risk Assessments: Evaluate disease risks in different regions - Prevention Planning: Design hypothetical prevention programs - Outbreak Investigation: Simulate epidemic response scenarios</p>"},{"location":"user-guide/diseases-database/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/diseases-database/#general-questions","title":"General Questions","text":"<p>Q: How many diseases are included in the database? A: The database includes comprehensive information on major mosquito-borne diseases of global public health importance, including viral, bacterial, and parasitic diseases transmitted by different mosquito species.</p> <p>Q: How current is the disease information? A: Disease information is regularly updated based on the latest scientific literature, surveillance reports, and public health guidelines. Update frequency varies by disease based on new research availability.</p> <p>Q: Can I use this information for clinical diagnosis? A: The database provides educational and reference information but should not be used as the sole basis for clinical diagnosis. Always consult qualified healthcare professionals for medical decisions.</p>"},{"location":"user-guide/diseases-database/#search-and-navigation","title":"Search and Navigation","text":"<p>Q: Why can't I find a specific disease? A: The disease may not be mosquito-borne, may be known by a different name, or may not be included in the current database. Try alternative names or contact support for assistance.</p> <p>Q: How do I find diseases in my region? A: Use geographic terms in your search or browse disease profiles to check distribution information. The map visualization feature can also help identify regional diseases.</p> <p>Q: Can I search by symptoms? A: Yes, you can search using symptom terms like \"fever,\" \"rash,\" or \"hemorrhagic.\" However, remember that many diseases share similar symptoms.</p>"},{"location":"user-guide/diseases-database/#data-accuracy-and-use","title":"Data Accuracy and Use","text":"<p>Q: How reliable is the disease information? A: All information is based on peer-reviewed scientific literature and authoritative public health sources. However, disease knowledge evolves, so always check for the most current information.</p> <p>Q: Can I cite information from the database? A: Yes, use the provided citation format and include the specific disease and access date. Individual disease profiles may have additional citation requirements.</p> <p>Q: What should I do if I find incorrect information? A: Please report any errors through our feedback system. Include specific details about the error and supporting references if available.</p>"},{"location":"user-guide/diseases-database/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/diseases-database/#support-resources","title":"Support Resources","text":"<ul> <li>User Documentation: Comprehensive guides and tutorials</li> <li>Search Strategies: Advanced search techniques and tips</li> <li>Video Tutorials: Visual guides for common tasks</li> <li>Community Forum: User discussions and shared experiences</li> </ul>"},{"location":"user-guide/diseases-database/#expert-consultation","title":"Expert Consultation","text":"<ul> <li>Epidemiologists: Disease surveillance and outbreak investigation expertise</li> <li>Medical Entomologists: Vector-disease relationship specialists</li> <li>Public Health Professionals: Prevention and control program guidance</li> <li>Clinical Experts: Diagnostic and treatment consultation</li> </ul>"},{"location":"user-guide/diseases-database/#technical-support","title":"Technical Support","text":"<ul> <li>Bug Reports: Report technical issues and problems</li> <li>Feature Requests: Suggest improvements and new capabilities</li> <li>Training Sessions: Scheduled group training and workshops</li> <li>Custom Applications: Specialized features for institutional users</li> </ul>"},{"location":"user-guide/diseases-database/#next-steps","title":"Next Steps","text":"<p>After mastering the diseases database:</p> <ol> <li>Explore Species Information: Learn about disease vectors</li> <li>Use Map Visualization: Analyze geographic disease patterns</li> <li>Practice Risk Assessment: Evaluate transmission potential in different areas</li> <li>Develop Prevention Plans: Design evidence-based intervention strategies</li> </ol> <p>For advanced users: - API Access: Programmatic access to disease data - Data Integration: Connect with surveillance and research systems - Collaborative Projects: Participate in public health initiatives - Expert Networks: Connect with disease specialists and researchers</p>"},{"location":"user-guide/faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>Comprehensive answers to the most common questions about using the CulicidaeLab platform.</p>"},{"location":"user-guide/faq/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/faq/#what-is-culicidaelab","title":"What is CulicidaeLab?","text":"<p>Q: What is CulicidaeLab and what can I do with it?</p> <p>A: CulicidaeLab is a comprehensive web platform for mosquito research, surveillance, and education. You can:</p> <ul> <li>Identify mosquito species using AI-powered image recognition</li> <li>Explore interactive maps showing mosquito distributions and surveillance data</li> <li>Access comprehensive species information including morphology, ecology, and medical importance</li> <li>Learn about mosquito-borne diseases and prevention strategies</li> <li>Contribute observations to community surveillance efforts</li> <li>Manage research data with import/export tools</li> <li>Collaborate with other researchers and public health professionals</li> </ul>"},{"location":"user-guide/faq/#system-requirements","title":"System Requirements","text":"<p>Q: What do I need to use CulicidaeLab?</p> <p>A: Minimum Requirements: - Modern web browser (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+) - Internet connection (broadband recommended for image uploads) - JavaScript enabled - Cookies enabled</p> <p>Recommended Setup: - Desktop or laptop computer for full functionality - High-resolution display for detailed image analysis - Fast internet connection for large data operations - Camera or scanner for specimen photography</p> <p>Q: Does CulicidaeLab work on mobile devices?</p> <p>A: Yes! The platform is mobile-responsive and works on smartphones and tablets. However, some features like detailed data analysis work better on larger screens. Mobile devices are excellent for field data collection and species identification.</p>"},{"location":"user-guide/faq/#account-and-access","title":"Account and Access","text":"<p>Q: Do I need to create an account to use CulicidaeLab?</p> <p>A: Basic features like species identification and map browsing are available without an account. However, creating a free account allows you to: - Save your prediction results - Contribute observations to the database - Access advanced filtering and export features - Participate in collaborative projects - Receive updates about new features</p> <p>Q: Is CulicidaeLab free to use?</p> <p>A: Yes, CulicidaeLab is completely free for research, education, and public health applications. The platform is open source and supported by the research community.</p>"},{"location":"user-guide/faq/#species-identification","title":"Species Identification","text":""},{"location":"user-guide/faq/#ai-prediction-system","title":"AI Prediction System","text":"<p>Q: How accurate is the AI species identification?</p> <p>A: Our AI models achieve over 90% accuracy on test datasets with high-quality images. However, real-world accuracy depends on several factors: - Image quality (lighting, focus, resolution) - Specimen condition (complete, undamaged specimens work best) - Species complexity (some species are harder to distinguish than others) - Geographic context (consider if species occurs in your region)</p> <p>Always check confidence scores and consider alternative predictions for verification.</p> <p>Q: What species can the AI identify?</p> <p>A: The current system can identify 46 mosquito species commonly encountered in research and surveillance, including: - Major disease vectors (Aedes aegypti, Aedes albopictus, Anopheles species) - Common pest species (Culex species) - Regionally important species from various geographic areas</p> <p>The species database is continuously expanding based on research needs and data availability.</p> <p>Q: Why do I get different results for the same mosquito?</p> <p>A: Prediction variations can occur due to: - Different image angles showing different diagnostic features - Lighting conditions affecting feature visibility - Image quality differences between uploads - Model uncertainty for specimens with ambiguous features</p> <p>For best results, upload multiple high-quality images from different angles and compare results.</p>"},{"location":"user-guide/faq/#image-requirements","title":"Image Requirements","text":"<p>Q: What makes a good mosquito photo for identification?</p> <p>A: Essential Elements: - Clear focus on the mosquito specimen - Good lighting (natural light preferred, avoid harsh shadows) - Appropriate size (mosquito fills significant portion of frame) - Clean background (minimal clutter or distractions) - Dorsal view (top-down view showing wing patterns and body markings)</p> <p>Technical Specifications: - Resolution: Minimum 224x224 pixels (higher preferred) - Format: JPEG, PNG, or WebP - File size: Under 10MB - Color: Full color images (avoid black and white)</p> <p>Q: Can I identify mosquito larvae or pupae?</p> <p>A: Currently, the AI system is optimized for adult mosquitoes. Larval and pupal identification requires different diagnostic features and specialized models that are not yet available. We recommend rearing specimens to adults for accurate identification.</p> <p>Q: What should I do if I get low confidence scores?</p> <p>A: Improve Image Quality: - Use better lighting (natural daylight works best) - Ensure sharp focus on diagnostic features - Try different angles (dorsal, lateral, ventral views) - Remove background clutter - Use higher resolution images</p> <p>Verify Results: - Check alternative predictions - Compare with reference images in species profiles - Consider geographic probability (is species found in your area?) - Seek expert verification for important identifications</p>"},{"location":"user-guide/faq/#map-and-data-features","title":"Map and Data Features","text":""},{"location":"user-guide/faq/#using-the-interactive-map","title":"Using the Interactive Map","text":"<p>Q: What data is shown on the map?</p> <p>A: The interactive map displays: - Observation records from research and surveillance programs - Species distribution data showing where different species have been found - Surveillance network locations indicating monitoring sites - Environmental context through various base map layers</p> <p>Data comes from multiple sources including research institutions, public health agencies, and community contributors.</p> <p>Q: Why don't I see data for my region?</p> <p>A: Data availability varies by geographic region based on: - Research activity in the area - Surveillance programs operated by public health agencies - Community contributions from local users - Historical data collection efforts</p> <p>You can help fill gaps by contributing your own observations to the database.</p> <p>Q: How current is the map data?</p> <p>A: Data currency varies by source: - Recent observations may be added within days or weeks - Research data is typically added after study completion and publication - Surveillance data depends on reporting schedules of contributing agencies - Historical data includes records going back several decades</p> <p>Check individual observation records for specific collection dates.</p>"},{"location":"user-guide/faq/#data-quality-and-reliability","title":"Data Quality and Reliability","text":"<p>Q: How reliable is the observation data?</p> <p>A: Data quality varies and is indicated by quality scores: - High quality: Expert-verified identifications with precise coordinates - Medium quality: Probable identifications with good location data - Low quality: Uncertain identifications or approximate locations</p> <p>Always consider quality indicators when using data for research or decision-making.</p> <p>Q: Can I trust species identifications in the database?</p> <p>A: Identification reliability varies by source: - Expert-verified: Confirmed by professional entomologists - AI-predicted: Automated identifications with confidence scores - Community-contributed: Varying levels of expertise</p> <p>Look for verification status and cross-reference with multiple sources for critical applications.</p>"},{"location":"user-guide/faq/#data-management","title":"Data Management","text":""},{"location":"user-guide/faq/#importing-and-exporting-data","title":"Importing and Exporting Data","text":"<p>Q: What file formats can I import?</p> <p>A: Supported Import Formats: - CSV (Comma-Separated Values) - recommended for most data - Excel (.xlsx, .xls) - Microsoft Excel workbooks - JSON - Structured data format - GeoJSON - Geographic data with spatial information - KML/KMZ - Google Earth format files</p> <p>Q: How do I prepare my data for import?</p> <p>A: Essential Steps: 1. Organize columns with clear headers (species, latitude, longitude, date, etc.) 2. Standardize formats (use decimal degrees for coordinates, ISO dates) 3. Validate data (check for errors, missing values, duplicates) 4. Include metadata (collector, method, data source information)</p> <p>See the Data Management guide for detailed preparation instructions.</p> <p>Q: What formats are available for data export?</p> <p>A: Export Options: - CSV - Universal format for spreadsheet applications - Excel - Formatted workbook with multiple sheets - GeoJSON - Geographic data for GIS applications - Darwin Core Archive - Standardized biodiversity data format</p> <p>Choose the format that best matches your intended use and software requirements.</p>"},{"location":"user-guide/faq/#data-sharing-and-collaboration","title":"Data Sharing and Collaboration","text":"<p>Q: Can I share my data with other researchers?</p> <p>A: Yes! The platform supports various sharing options: - Public sharing for open science initiatives - Project-based sharing with specific research teams - Controlled access with permission management - API access for programmatic data sharing</p> <p>You maintain control over your data and can set appropriate sharing permissions.</p> <p>Q: How do I cite data from CulicidaeLab in my research?</p> <p>A: Platform Citation: <pre><code>CulicidaeLab Consortium. (2024). CulicidaeLab: A comprehensive platform for mosquito research and surveillance. Available at: [platform URL]. Accessed: [date].\n</code></pre></p> <p>Individual Dataset Citation: Include specific dataset information, contributors, and access dates. Many datasets have their own preferred citation formats listed in their metadata.</p>"},{"location":"user-guide/faq/#technical-issues","title":"Technical Issues","text":""},{"location":"user-guide/faq/#common-problems","title":"Common Problems","text":"<p>Q: The platform is running slowly. What can I do?</p> <p>A: Performance Optimization: - Close unnecessary browser tabs and applications - Clear browser cache and cookies - Use a wired internet connection when possible - Apply filters to reduce data load on maps and searches - Try during off-peak hours when server load is lower</p> <p>Q: My images won't upload. What's wrong?</p> <p>A: Common Upload Issues: - File size too large (maximum 10MB per image) - Unsupported format (use JPEG, PNG, or WebP) - Poor internet connection (try smaller files or better connection) - Browser issues (clear cache, try different browser)</p> <p>Q: I can't see the interactive map. How do I fix this?</p> <p>A: Map Display Issues: - Enable JavaScript in your browser - Update graphics drivers for WebGL support - Try a different browser (Chrome or Firefox recommended) - Disable browser extensions that might interfere - Check firewall settings that might block map tiles</p>"},{"location":"user-guide/faq/#browser-and-compatibility","title":"Browser and Compatibility","text":"<p>Q: Which browsers work best with CulicidaeLab?</p> <p>A: Recommended Browsers: - Google Chrome (version 90+) - best overall performance - Mozilla Firefox (version 88+) - good alternative - Safari (version 14+) - works well on Mac/iOS - Microsoft Edge (version 90+) - good on Windows</p> <p>Avoid: Internet Explorer (not supported) and very old browser versions.</p> <p>Q: Can I use CulicidaeLab offline?</p> <p>A: The web platform requires internet connectivity for most features. However: - Cached pages may work briefly offline - Downloaded data can be analyzed offline in other software - Local deployment is possible for institutional users - Mobile apps with offline capabilities are under development</p>"},{"location":"user-guide/faq/#research-and-scientific-use","title":"Research and Scientific Use","text":""},{"location":"user-guide/faq/#academic-and-research-applications","title":"Academic and Research Applications","text":"<p>Q: Can I use CulicidaeLab data in my research publication?</p> <p>A: Yes! CulicidaeLab supports open science principles: - Data is freely available for research use - Proper attribution is required (see citation guidelines) - Quality assessment is your responsibility - Collaboration opportunities are available with the development team</p> <p>Q: How do I ensure data quality for scientific research?</p> <p>A: Quality Assurance Steps: - Check data sources and collection methods - Verify species identifications with experts when possible - Cross-validate with other datasets - Document limitations and uncertainties in your analysis - Use appropriate statistical methods for observational data</p> <p>Q: Can I contribute my research data to CulicidaeLab?</p> <p>A: Absolutely! We welcome high-quality research data: - Contact the development team to discuss data contribution - Ensure proper permissions and ethical approvals - Provide complete metadata and documentation - Consider data sharing agreements for collaborative projects</p>"},{"location":"user-guide/faq/#educational-use","title":"Educational Use","text":"<p>Q: Is CulicidaeLab suitable for teaching?</p> <p>A: Yes! The platform is excellent for education: - Interactive learning with real scientific data - Species identification practice with immediate feedback - Geographic analysis of distribution patterns - Research skills development with authentic datasets - Collaborative projects between institutions</p> <p>Q: Are there educational resources available?</p> <p>A: Teaching Materials: - User guides and tutorials for different skill levels - Video demonstrations of key features - Example datasets for classroom exercises - Lesson plan suggestions for different educational levels - Training workshops for educators</p>"},{"location":"user-guide/faq/#public-health-applications","title":"Public Health Applications","text":""},{"location":"user-guide/faq/#vector-surveillance","title":"Vector Surveillance","text":"<p>Q: How can public health agencies use CulicidaeLab?</p> <p>A: Surveillance Applications: - Species identification for vector control programs - Distribution mapping to identify high-risk areas - Data management for surveillance records - Trend analysis to track population changes - Risk assessment for disease transmission</p> <p>Q: Is the platform suitable for operational surveillance?</p> <p>A: CulicidaeLab can support surveillance activities, but: - Verify critical identifications with expert taxonomists - Validate AI predictions against known local fauna - Maintain quality control procedures for data entry - Consider local regulations and reporting requirements - Integrate with existing systems as appropriate</p>"},{"location":"user-guide/faq/#disease-vector-information","title":"Disease Vector Information","text":"<p>Q: Does CulicidaeLab provide information about disease transmission?</p> <p>A: Yes! The platform includes: - Vector competence data for different species - Disease profiles with transmission information - Geographic risk maps showing vector distributions - Prevention strategies and control recommendations - Links to health resources and expert networks</p> <p>Q: How current is the disease information?</p> <p>A: Disease information is regularly updated based on: - Recent scientific literature and research findings - Public health reports from agencies like WHO and CDC - Expert review by medical entomologists - Community feedback and corrections</p>"},{"location":"user-guide/faq/#privacy-and-data-security","title":"Privacy and Data Security","text":""},{"location":"user-guide/faq/#data-privacy","title":"Data Privacy","text":"<p>Q: What happens to images I upload for identification?</p> <p>A: Image Handling: - Processing only - images are analyzed but not permanently stored by default - Optional contribution - you can choose to contribute images to improve the AI models - No personal information is extracted from images - Secure transmission using encrypted connections</p> <p>Q: Is my personal information protected?</p> <p>A: Privacy Protection: - Minimal data collection - only necessary information is requested - Secure storage with industry-standard encryption - No third-party sharing without explicit consent - User control over data sharing and deletion - Transparent policies clearly explaining data use</p>"},{"location":"user-guide/faq/#data-ownership","title":"Data Ownership","text":"<p>Q: Who owns the data I contribute?</p> <p>A: Data Ownership: - You retain ownership of your contributed data - Usage rights are granted for platform operation and research - Attribution requirements ensure proper credit for contributions - Withdrawal options allow data removal if needed</p> <p>Q: Can I delete my data from the platform?</p> <p>A: Yes, you can: - Delete individual records you've contributed - Remove your account and associated data - Request data export before deletion - Consider impact on collaborative projects before removing shared data</p>"},{"location":"user-guide/faq/#future-development","title":"Future Development","text":""},{"location":"user-guide/faq/#planned-features","title":"Planned Features","text":"<p>Q: What new features are being developed?</p> <p>A: Upcoming Enhancements: - Mobile applications for field data collection - Additional species and geographic coverage - Advanced AI models with improved accuracy - Enhanced collaboration tools for research teams - Integration capabilities with other platforms and databases</p> <p>Q: How can I suggest new features or improvements?</p> <p>A: Feedback Channels: - GitHub issues for technical suggestions and bug reports - Community forum for feature discussions - Direct contact with the development team - User surveys and feedback forms - Collaborative development opportunities for technical users</p>"},{"location":"user-guide/faq/#community-involvement","title":"Community Involvement","text":"<p>Q: How can I get involved in CulicidaeLab development?</p> <p>A: Contribution Opportunities: - Data contribution - share your research datasets - Code development - contribute to open source codebase - Documentation - help improve guides and tutorials - Testing - participate in beta testing of new features - Outreach - help spread awareness in your community</p> <p>Q: Is there a user community I can join?</p> <p>A: Community Resources: - Online forum for discussions and questions - Social media groups for updates and networking - Regional meetups and conferences - Collaborative projects with other users - Training workshops and webinars</p>"},{"location":"user-guide/faq/#getting-more-help","title":"Getting More Help","text":""},{"location":"user-guide/faq/#support-options","title":"Support Options","text":"<p>Q: What should I do if I can't find the answer to my question?</p> <p>A: Additional Support: 1. Search the documentation - comprehensive guides available 2. Check the community forum - other users may have similar questions 3. Contact support - email or chat support available 4. Report issues - use GitHub for technical problems 5. Request training - workshops and consultation available</p> <p>Q: How do I report a bug or technical problem?</p> <p>A: Bug Reporting: - GitHub issues - preferred for technical problems - Include details - browser, operating system, steps to reproduce - Provide screenshots - visual evidence helps diagnosis - Check existing reports - avoid duplicate submissions</p>"},{"location":"user-guide/faq/#expert-consultation","title":"Expert Consultation","text":"<p>Q: Can I get expert help with species identification?</p> <p>A: Expert Resources: - Academic partnerships - connections with university entomologists - Professional networks - links to medical entomology experts - Consultation services - paid expert review for critical identifications - Training opportunities - workshops to improve identification skills</p> <p>Q: Is training available for institutional users?</p> <p>A: Training Programs: - Online tutorials - self-paced learning materials - Live webinars - interactive training sessions - On-site workshops - customized training for organizations - Certification programs - proficiency validation for professional use</p> <p>This FAQ covers the most common questions about CulicidaeLab. For additional help, please consult the detailed user guides or contact our support team.</p>"},{"location":"user-guide/map-visualization/","title":"Map Visualization Guide","text":"<p>Master the interactive mapping tools to explore mosquito distribution patterns, surveillance data, and geographic trends in the CulicidaeLab platform.</p>"},{"location":"user-guide/map-visualization/#overview","title":"Overview","text":"<p>The Map Visualization feature provides powerful tools for exploring geospatial mosquito data, including species distributions, observation records, and surveillance patterns. The interactive map interface allows you to filter, analyze, and export geographic data for research and public health applications.</p>"},{"location":"user-guide/map-visualization/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/map-visualization/#accessing-the-map","title":"Accessing the Map","text":"<ol> <li>Click the Map tab in the main navigation</li> <li>The interactive map will load showing global mosquito observation data</li> <li>Use the controls to zoom, pan, and explore different regions</li> </ol>"},{"location":"user-guide/map-visualization/#map-interface-components","title":"Map Interface Components","text":"<p>Main Map Area: - Interactive world map with observation markers - Zoom controls (+ / - buttons or mouse wheel) - Pan functionality (click and drag) - Layer toggle controls</p> <p>Control Panel: - Species filters - Date range selectors - Data source filters - Display options</p> <p>Information Panel: - Selected observation details - Summary statistics - Export options</p>"},{"location":"user-guide/map-visualization/#basic-navigation","title":"Basic Navigation","text":""},{"location":"user-guide/map-visualization/#zooming-and-panning","title":"Zooming and Panning","text":"<p>Mouse Controls: - Zoom In/Out: Mouse wheel or double-click - Pan: Click and drag to move around - Reset View: Click home button to return to global view</p> <p>Touch Controls (Mobile/Tablet): - Zoom: Pinch to zoom in/out - Pan: Single finger drag to move - Rotate: Two-finger rotation (if enabled)</p>"},{"location":"user-guide/map-visualization/#map-layers","title":"Map Layers","text":"<p>Base Map Options: - Satellite: High-resolution satellite imagery - Street Map: Detailed street and city information - Terrain: Topographic features and elevation - Hybrid: Combination of satellite and street data</p> <p>Data Layers: - Observations: Individual mosquito collection points - Species Distribution: Predicted species ranges - Surveillance Networks: Monitoring station locations - Environmental Data: Climate and habitat information</p>"},{"location":"user-guide/map-visualization/#filtering-and-searching","title":"Filtering and Searching","text":""},{"location":"user-guide/map-visualization/#species-filters","title":"Species Filters","text":"<p>Filter by Species: 1. Open the Species filter panel 2. Select specific species from the dropdown list 3. Use checkboxes to select multiple species 4. Apply filters to update map display</p> <p>Common Filter Combinations: - Disease Vectors: Filter for Aedes aegypti, Aedes albopictus, Anopheles species - Regional Species: Focus on species common to your geographic area - Research Targets: Select species relevant to your study</p>"},{"location":"user-guide/map-visualization/#geographic-filters","title":"Geographic Filters","text":"<p>Region Selection: 1. Use the region dropdown to select continents or countries 2. Draw custom boundaries using the polygon tool 3. Search for specific locations using the search box</p> <p>Coordinate-Based Filtering: - Enter latitude/longitude ranges - Upload geographic boundary files (GeoJSON, KML) - Use administrative boundaries (countries, states, provinces)</p>"},{"location":"user-guide/map-visualization/#temporal-filters","title":"Temporal Filters","text":"<p>Date Range Selection: 1. Use the date picker to set start and end dates 2. Select predefined ranges (last month, year, etc.) 3. Filter by seasons or specific time periods</p> <p>Temporal Analysis Options: - Animation Mode: Watch data changes over time - Seasonal Patterns: Compare different seasons - Trend Analysis: Identify long-term patterns</p>"},{"location":"user-guide/map-visualization/#step-by-step-tutorial-analyzing-aedes-aegypti-distribution","title":"Step-by-Step Tutorial: Analyzing Aedes aegypti Distribution","text":"<p>Let's explore the global distribution of Aedes aegypti, a major disease vector:</p>"},{"location":"user-guide/map-visualization/#step-1-set-up-the-analysis","title":"Step 1: Set Up the Analysis","text":"<ol> <li>Access the Map: Navigate to the Map page</li> <li>Clear Existing Filters: Reset any active filters</li> <li>Select Base Layer: Choose \"Satellite\" for geographic context</li> </ol>"},{"location":"user-guide/map-visualization/#step-2-apply-species-filter","title":"Step 2: Apply Species Filter","text":"<ol> <li>Open Species Filter: Click on the species dropdown</li> <li>Search for Aedes aegypti: Type \"aegypti\" in the search box</li> <li>Select Species: Check the box for Aedes aegypti</li> <li>Apply Filter: Click \"Apply\" to update the map</li> </ol> <p>Expected Results: - Map shows only Aedes aegypti observations - Markers concentrated in tropical and subtropical regions - Clear absence from temperate and polar regions</p>"},{"location":"user-guide/map-visualization/#step-3-analyze-geographic-patterns","title":"Step 3: Analyze Geographic Patterns","text":"<p>Observe Distribution Patterns: - Tropical Belt: High concentration between 35\u00b0N and 35\u00b0S - Urban Areas: Clusters around major cities - Coastal Regions: Strong presence in coastal areas - Island Nations: Widespread in Caribbean and Pacific islands</p> <p>Interactive Exploration: 1. Zoom to Regions: Focus on specific continents or countries 2. Click Markers: View individual observation details 3. Identify Hotspots: Look for areas with high observation density</p>"},{"location":"user-guide/map-visualization/#step-4-temporal-analysis","title":"Step 4: Temporal Analysis","text":"<ol> <li>Set Date Range: Filter to recent years (e.g., 2020-2024)</li> <li>Enable Animation: Use time slider to see changes over time</li> <li>Seasonal Patterns: Compare wet vs. dry seasons</li> </ol> <p>Key Observations: - Seasonal Variation: Higher activity during warm, wet months - Range Expansion: Gradual spread to new geographic areas - Urban Spread: Increasing presence in urban environments</p>"},{"location":"user-guide/map-visualization/#step-5-export-and-save-results","title":"Step 5: Export and Save Results","text":"<ol> <li>Generate Summary: Click \"Generate Report\" for statistics</li> <li>Export Data: Download filtered observations as CSV</li> <li>Save Map View: Bookmark or save current map state</li> <li>Create Screenshots: Capture map images for presentations</li> </ol>"},{"location":"user-guide/map-visualization/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/map-visualization/#data-visualization-options","title":"Data Visualization Options","text":"<p>Marker Styles: - Point Markers: Individual observation locations - Heatmaps: Density visualization for large datasets - Choropleth: Administrative region coloring by data values - Cluster Markers: Grouped observations for better performance</p> <p>Symbology Options: - Size by Abundance: Larger markers for higher specimen counts - Color by Species: Different colors for each species - Shape by Data Source: Different symbols for various data sources - Transparency: Adjust opacity for overlapping data</p>"},{"location":"user-guide/map-visualization/#statistical-analysis","title":"Statistical Analysis","text":"<p>Summary Statistics: - Observation Counts: Total observations by region/species - Density Calculations: Observations per unit area - Temporal Trends: Changes in observation frequency over time - Species Richness: Number of species per geographic area</p> <p>Spatial Analysis: - Hotspot Detection: Identify areas of high activity - Range Estimation: Calculate species distribution boundaries - Habitat Suitability: Overlay environmental data - Connectivity Analysis: Assess landscape connectivity</p>"},{"location":"user-guide/map-visualization/#data-integration","title":"Data Integration","text":"<p>Environmental Layers: - Climate Data: Temperature, precipitation, humidity - Land Use: Urban areas, agriculture, natural habitats - Elevation: Topographic data and altitude zones - Water Bodies: Rivers, lakes, and wetland areas</p> <p>Surveillance Networks: - Monitoring Stations: Active surveillance locations - Trap Networks: Vector control monitoring systems - Research Sites: Academic and institutional study areas - Public Health Facilities: Hospitals and clinics</p>"},{"location":"user-guide/map-visualization/#working-with-observation-data","title":"Working with Observation Data","text":""},{"location":"user-guide/map-visualization/#understanding-observation-records","title":"Understanding Observation Records","text":"<p>Data Fields: - Species: Scientific and common names - Location: GPS coordinates and place names - Date/Time: Collection date and time - Collector: Person or organization responsible - Method: Collection or observation method - Abundance: Number of specimens observed - Life Stage: Adult, larva, pupa, egg - Sex: Male, female, or unknown - Notes: Additional observations or comments</p>"},{"location":"user-guide/map-visualization/#data-quality-indicators","title":"Data Quality Indicators","text":"<p>Quality Scores: - High Quality: GPS coordinates, expert identification, recent date - Medium Quality: Approximate location, probable identification - Low Quality: Uncertain location or identification</p> <p>Verification Status: - Verified: Expert-confirmed identification - Probable: High-confidence automated identification - Unverified: Requires additional confirmation</p>"},{"location":"user-guide/map-visualization/#contributing-observations","title":"Contributing Observations","text":"<p>Adding New Data: 1. Click \"Add Observation\" on the map 2. Select Location: Click on map or enter coordinates 3. Enter Details: Species, date, abundance, etc. 4. Upload Photos: Include specimen images if available 5. Submit: Add to community database</p> <p>Data Standards: - Accurate Coordinates: Use GPS when possible - Proper Identification: Verify species identification - Complete Metadata: Include all relevant information - Quality Photos: Clear images for verification</p>"},{"location":"user-guide/map-visualization/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/map-visualization/#performance-issues","title":"Performance Issues","text":"<p>Problem: Map loads slowly or becomes unresponsive</p> <p>Solutions: 1. Reduce Data Load:    - Apply more restrictive filters    - Zoom to smaller geographic areas    - Limit date ranges</p> <ol> <li>Browser Optimization:</li> <li>Close unnecessary browser tabs</li> <li>Clear browser cache</li> <li>Use modern browser versions</li> <li> <p>Disable browser extensions</p> </li> <li> <p>Network Issues:</p> </li> <li>Check internet connection speed</li> <li>Try different network connection</li> <li>Use wired connection if possible</li> </ol>"},{"location":"user-guide/map-visualization/#display-problems","title":"Display Problems","text":"<p>Problem: Markers not showing or incorrect positioning</p> <p>Troubleshooting: 1. Check Filters: Ensure filters aren't excluding all data 2. Zoom Level: Some data only visible at certain zoom levels 3. Layer Settings: Verify correct layers are enabled 4. Browser Compatibility: Try different browser</p>"},{"location":"user-guide/map-visualization/#data-issues","title":"Data Issues","text":"<p>Problem: Missing or unexpected data patterns</p> <p>Investigation Steps: 1. Verify Filters: Check all active filter settings 2. Data Sources: Confirm expected data sources are included 3. Geographic Scope: Ensure study area is properly defined 4. Temporal Range: Verify date ranges include expected periods</p>"},{"location":"user-guide/map-visualization/#export-and-reporting","title":"Export and Reporting","text":""},{"location":"user-guide/map-visualization/#data-export-options","title":"Data Export Options","text":"<p>Supported Formats: - CSV: Tabular data for spreadsheet analysis - GeoJSON: Geographic data for GIS applications - KML: Google Earth compatible format - Shapefile: Professional GIS format</p> <p>Export Process: 1. Apply Filters: Set up desired data subset 2. Select Export Format: Choose appropriate file type 3. Configure Options: Set coordinate system, field selection 4. Download: Save file to local computer</p>"},{"location":"user-guide/map-visualization/#report-generation","title":"Report Generation","text":"<p>Automated Reports: - Summary Statistics: Observation counts and distributions - Species Lists: Complete species inventories for regions - Temporal Summaries: Seasonal and annual patterns - Quality Reports: Data quality and completeness metrics</p> <p>Custom Reports: - Research Summaries: Tailored for specific studies - Surveillance Reports: Public health monitoring summaries - Educational Materials: Classroom and outreach resources</p>"},{"location":"user-guide/map-visualization/#map-image-export","title":"Map Image Export","text":"<p>Static Maps: 1. Set View: Position and zoom to desired area 2. Configure Display: Set layers and symbology 3. Export Image: High-resolution PNG or PDF 4. Add Annotations: Include scale bars, legends, titles</p> <p>Interactive Maps: - Embed Code: HTML for websites - Shareable Links: URLs for collaboration - Web Services: API endpoints for applications</p>"},{"location":"user-guide/map-visualization/#integration-with-other-features","title":"Integration with Other Features","text":""},{"location":"user-guide/map-visualization/#species-prediction-integration","title":"Species Prediction Integration","text":"<p>Workflow: 1. Identify Species: Use prediction tool for unknown specimens 2. Add to Map: Contribute verified identifications 3. Validate Patterns: Compare predictions with known distributions 4. Update Database: Improve species range information</p>"},{"location":"user-guide/map-visualization/#disease-information-links","title":"Disease Information Links","text":"<p>Vector Mapping: 1. Select Disease Vectors: Filter for species of medical importance 2. Overlay Disease Data: Show disease occurrence patterns 3. Risk Assessment: Identify high-risk areas 4. Prevention Planning: Target control efforts</p>"},{"location":"user-guide/map-visualization/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/map-visualization/#data-analysis","title":"Data Analysis","text":"<p>Statistical Considerations: - Sample Bias: Account for uneven sampling effort - Temporal Bias: Consider seasonal collection patterns - Geographic Bias: Recognize urban vs. rural sampling differences - Detection Probability: Account for species detectability</p> <p>Quality Control: - Verify Identifications: Cross-check uncertain records - Check Coordinates: Validate geographic accuracy - Review Outliers: Investigate unusual observations - Document Methods: Record analysis procedures</p>"},{"location":"user-guide/map-visualization/#visualization-design","title":"Visualization Design","text":"<p>Effective Maps: - Clear Symbology: Use intuitive colors and symbols - Appropriate Scale: Match detail level to purpose - Informative Legends: Include all necessary information - Context Layers: Provide geographic reference</p> <p>Accessibility: - Color-Blind Friendly: Use accessible color schemes - High Contrast: Ensure visibility for all users - Alternative Text: Provide descriptions for images - Keyboard Navigation: Support non-mouse interaction</p>"},{"location":"user-guide/map-visualization/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/map-visualization/#data-questions","title":"Data Questions","text":"<p>Q: How current is the observation data? A: Data is updated regularly from contributing sources. Most recent observations are from ongoing surveillance and research programs. Check individual records for specific collection dates.</p> <p>Q: Can I trust the species identifications? A: Identification quality varies by source. Look for verification status and quality indicators. Expert-verified records are most reliable, while automated identifications should be used with appropriate caution.</p> <p>Q: Why are some regions missing data? A: Data availability reflects sampling effort and research activity. Some regions may have limited surveillance or research programs. Absence of data doesn't necessarily mean absence of species.</p>"},{"location":"user-guide/map-visualization/#technical-questions","title":"Technical Questions","text":"<p>Q: What coordinate systems are supported? A: The map uses WGS84 (EPSG:4326) by default. Data can be exported in various coordinate systems including UTM zones and local projections.</p> <p>Q: Can I upload my own data? A: Yes, you can contribute individual observations through the interface or contact administrators for bulk data uploads. Data must meet quality standards and include proper metadata.</p> <p>Q: Is there an API for programmatic access? A: Yes, the platform provides REST API endpoints for accessing map data. See the API documentation for details on authentication and usage.</p>"},{"location":"user-guide/map-visualization/#usage-questions","title":"Usage Questions","text":"<p>Q: Can I use the maps in publications? A: Yes, maps and data can be used in research publications with proper attribution. Check the data license for specific requirements and cite the CulicidaeLab platform.</p> <p>Q: How do I cite the data in my research? A: Use the provided citation format and include the access date. Individual datasets may have specific citation requirements listed in their metadata.</p> <p>Q: Can I collaborate with other researchers? A: The platform supports data sharing and collaboration. Contact the development team to set up research partnerships or data sharing agreements.</p>"},{"location":"user-guide/map-visualization/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/map-visualization/#support-resources","title":"Support Resources","text":"<ul> <li>User Documentation: Comprehensive guides and tutorials</li> <li>Video Tutorials: Step-by-step visual guides</li> <li>FAQ Database: Common questions and solutions</li> <li>Community Forum: User discussions and tips</li> </ul>"},{"location":"user-guide/map-visualization/#technical-support","title":"Technical Support","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Email Support: Direct contact for specific problems</li> <li>Live Chat: Real-time assistance during business hours</li> <li>Training Sessions: Scheduled group training opportunities</li> </ul>"},{"location":"user-guide/map-visualization/#expert-consultation","title":"Expert Consultation","text":"<ul> <li>GIS Specialists: Spatial analysis and mapping expertise</li> <li>Entomologists: Species identification and ecology</li> <li>Epidemiologists: Disease vector and public health applications</li> <li>Data Scientists: Statistical analysis and modeling</li> </ul>"},{"location":"user-guide/map-visualization/#next-steps","title":"Next Steps","text":"<p>After mastering map visualization:</p> <ol> <li>Advanced Analysis: Learn statistical analysis techniques</li> <li>Data Contribution: Add your observations to the database</li> <li>API Integration: Develop custom applications</li> <li>Research Collaboration: Connect with other researchers</li> </ol> <p>For technical users: - GIS Integration: Connect with professional GIS software - Database Access: Direct database queries and analysis - Custom Visualizations: Develop specialized mapping tools - Automated Workflows: Set up data processing pipelines</p>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>Welcome to the CulicidaeLab Server user guide. This comprehensive guide will help you understand and effectively use all the features of the CulicidaeLab platform for mosquito research, surveillance, and data analysis.</p>"},{"location":"user-guide/overview/#what-is-culicidaelab-server","title":"What is CulicidaeLab Server?","text":"<p>CulicidaeLab Server is a sophisticated web platform that combines artificial intelligence, geospatial visualization, and comprehensive data management to support mosquito research and public health initiatives. The platform provides tools for species identification, surveillance data analysis, and educational resources about mosquito-borne diseases.</p>"},{"location":"user-guide/overview/#key-features","title":"Key Features","text":""},{"location":"user-guide/overview/#ai-powered-species-prediction","title":"\ud83d\udd2c AI-Powered Species Prediction","text":"<p>Upload mosquito images and get instant species identification using state-of-the-art machine learning models:</p> <ul> <li>Classification Models: Identify mosquito species from photographs</li> <li>Detection Models: Locate and identify mosquitoes in complex images</li> <li>Segmentation Models: Precise mosquito outline detection and analysis</li> <li>Confidence Scoring: Reliability indicators for each prediction</li> <li>Multiple Model Support: Access to top-performing models in the CulicidaeLab ecosystem</li> </ul>"},{"location":"user-guide/overview/#interactive-map-visualization","title":"\ud83d\uddfa\ufe0f Interactive Map Visualization","text":"<p>Explore mosquito distribution and surveillance data through dynamic maps:</p> <ul> <li>Observation Mapping: Visualize mosquito sightings and collection data</li> <li>Species Distribution: View geographic ranges of different species</li> <li>Temporal Analysis: Track changes in populations over time</li> <li>Data Filtering: Filter by species, date ranges, and geographic regions</li> <li>Export Capabilities: Download data and maps for further analysis</li> </ul>"},{"location":"user-guide/overview/#species-database","title":"\ud83d\udcda Species Database","text":"<p>Access comprehensive information about mosquito species:</p> <ul> <li>Species Profiles: Detailed information about morphology, behavior, and habitat</li> <li>High-Quality Images: Reference photos for identification</li> <li>Distribution Maps: Geographic range information</li> <li>Ecological Data: Breeding preferences and environmental requirements</li> <li>Medical Importance: Disease vector status and public health relevance</li> </ul>"},{"location":"user-guide/overview/#disease-information-hub","title":"\ud83e\udda0 Disease Information Hub","text":"<p>Learn about mosquito-borne diseases and their prevention:</p> <ul> <li>Disease Profiles: Comprehensive information about vector-borne diseases</li> <li>Vector Relationships: Which mosquito species transmit which diseases</li> <li>Symptoms and Diagnosis: Clinical information for healthcare providers</li> <li>Prevention Strategies: Evidence-based prevention and control measures</li> <li>Epidemiological Data: Disease distribution and outbreak information</li> </ul>"},{"location":"user-guide/overview/#user-roles-and-use-cases","title":"User Roles and Use Cases","text":""},{"location":"user-guide/overview/#researchers-and-scientists","title":"Researchers and Scientists","text":"<p>Primary Use Cases: - Species identification for field studies - Data collection and analysis for research projects - Access to reference materials and taxonomic information - Collaboration through shared datasets and observations</p> <p>Key Features: - High-accuracy AI models for species identification - Comprehensive species database with scientific information - Data export capabilities for statistical analysis - API access for integration with research workflows</p>"},{"location":"user-guide/overview/#public-health-professionals","title":"Public Health Professionals","text":"<p>Primary Use Cases: - Surveillance and monitoring of disease vectors - Risk assessment and outbreak investigation - Educational resource development - Policy and intervention planning</p> <p>Key Features: - Disease vector identification and mapping - Surveillance data visualization and analysis - Disease information and prevention resources - Geographic analysis tools for risk assessment</p>"},{"location":"user-guide/overview/#educators-and-students","title":"Educators and Students","text":"<p>Primary Use Cases: - Teaching mosquito biology and identification - Learning about vector-borne diseases - Hands-on experience with AI and data analysis - Research project support</p> <p>Key Features: - User-friendly interface for learning - Comprehensive educational resources - Interactive tools for exploration - Access to real scientific data and models</p>"},{"location":"user-guide/overview/#citizen-scientists-and-enthusiasts","title":"Citizen Scientists and Enthusiasts","text":"<p>Primary Use Cases: - Contributing to mosquito surveillance efforts - Learning about local mosquito species - Participating in community health initiatives - Personal interest in entomology</p> <p>Key Features: - Easy-to-use species identification tools - Educational content about mosquitoes and diseases - Contribution opportunities for data collection - Community features for sharing observations</p>"},{"location":"user-guide/overview/#platform-architecture","title":"Platform Architecture","text":""},{"location":"user-guide/overview/#frontend-interface","title":"Frontend Interface","text":"<p>The user interface is built with Solara, providing:</p> <ul> <li>Responsive Design: Works on desktop, tablet, and mobile devices</li> <li>Interactive Components: Dynamic maps, image upload, and data visualization</li> <li>Real-time Updates: Live data processing and results display</li> <li>Accessibility: Screen reader compatible and keyboard navigable</li> </ul>"},{"location":"user-guide/overview/#backend-api","title":"Backend API","text":"<p>The backend provides robust data processing and AI inference:</p> <ul> <li>FastAPI Framework: High-performance API with automatic documentation</li> <li>Vector Database: Efficient similarity search and data retrieval</li> <li>AI Model Integration: Seamless access to machine learning models</li> <li>Data Management: Secure storage and retrieval of observations and metadata</li> </ul>"},{"location":"user-guide/overview/#data-storage","title":"Data Storage","text":"<p>Efficient and scalable data management:</p> <ul> <li>LanceDB: Vector database for similarity search and embeddings</li> <li>GeoJSON Support: Standardized geospatial data formats</li> <li>Metadata Management: Comprehensive tracking of data provenance</li> <li>Backup and Recovery: Robust data protection mechanisms</li> </ul>"},{"location":"user-guide/overview/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/overview/#for-new-users","title":"For New Users","text":"<ol> <li>Start with the Quick Start Guide to get the platform running</li> <li>Try Species Prediction: Upload a mosquito image to see AI identification in action</li> <li>Explore the Map: Browse existing observation data and species distributions</li> <li>Browse Species Information: Learn about different mosquito species and their characteristics</li> </ol>"},{"location":"user-guide/overview/#for-advanced-users","title":"For Advanced Users","text":"<ol> <li>Review the API Documentation for programmatic access</li> <li>Explore Configuration Options: Customize the platform for your specific needs</li> <li>Set Up Data Integration: Connect your existing datasets and workflows</li> <li>Contribute Data: Add your observations to the community database</li> </ol>"},{"location":"user-guide/overview/#data-quality-and-accuracy","title":"Data Quality and Accuracy","text":""},{"location":"user-guide/overview/#ai-model-performance","title":"AI Model Performance","text":"<p>The CulicidaeLab AI models are trained on high-quality, curated datasets:</p> <ul> <li>Training Data: 46 species with 3,139 unique images</li> <li>Model Accuracy: &gt;90% accuracy for top-performing classification models</li> <li>Continuous Improvement: Regular model updates and retraining</li> <li>Validation: Rigorous testing on independent datasets</li> </ul>"},{"location":"user-guide/overview/#data-validation","title":"Data Validation","text":"<p>Quality assurance measures ensure reliable data:</p> <ul> <li>Expert Review: Scientific validation of species identifications</li> <li>Community Verification: Peer review of contributed observations</li> <li>Automated Checks: Quality control algorithms for data consistency</li> <li>Feedback Mechanisms: User reporting of errors and corrections</li> </ul>"},{"location":"user-guide/overview/#privacy-and-data-sharing","title":"Privacy and Data Sharing","text":""},{"location":"user-guide/overview/#data-privacy","title":"Data Privacy","text":"<p>Your privacy is protected through:</p> <ul> <li>Local Processing: AI inference can be performed locally</li> <li>Minimal Data Collection: Only necessary information is stored</li> <li>User Control: You control what data is shared</li> <li>Secure Storage: Industry-standard security measures</li> </ul>"},{"location":"user-guide/overview/#open-science","title":"Open Science","text":"<p>CulicidaeLab supports open science principles:</p> <ul> <li>Open Source: All code is publicly available</li> <li>Open Data: Datasets are shared under permissive licenses</li> <li>Open Models: AI models are freely available for research</li> <li>Community Contributions: Collaborative development and improvement</li> </ul>"},{"location":"user-guide/overview/#support-and-community","title":"Support and Community","text":""},{"location":"user-guide/overview/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Comprehensive guides and tutorials</li> <li>GitHub Issues: Report bugs and request features</li> <li>Community Discussions: Ask questions and share experiences</li> <li>Direct Contact: Email support for specific issues</li> </ul>"},{"location":"user-guide/overview/#contributing","title":"Contributing","text":"<p>Join the CulicidaeLab community:</p> <ul> <li>Code Contributions: Improve the platform through development</li> <li>Data Contributions: Share observations and datasets</li> <li>Documentation: Help improve guides and tutorials</li> <li>Testing: Report issues and test new features</li> </ul>"},{"location":"user-guide/overview/#next-steps","title":"Next Steps","text":"<p>Explore specific features in detail:</p> <ul> <li>Species Prediction: Learn how to use AI for mosquito identification</li> <li>Species Database: Browse and search comprehensive species information</li> <li>Diseases Database: Explore mosquito-borne diseases and prevention strategies</li> <li>Map Visualization: Master the interactive mapping tools</li> <li>Data Management: Understand data import, export, and organization</li> <li>Troubleshooting: Solve common issues and optimize performance</li> <li>FAQ: Find answers to frequently asked questions</li> </ul> <p>For technical users, also check out:</p> <ul> <li>Developer Guide: Technical architecture and development information</li> <li>API Reference: Complete API documentation</li> <li>Deployment Guide: Production deployment instructions</li> </ul>"},{"location":"user-guide/species-database/","title":"Species Database Guide","text":"<p>Learn how to effectively browse, search, and explore the comprehensive mosquito species database in CulicidaeLab.</p>"},{"location":"user-guide/species-database/#overview","title":"Overview","text":"<p>The Species Database is a comprehensive repository of mosquito species information, featuring detailed profiles, high-quality images, distribution data, and medical importance ratings. The database includes 46+ species commonly encountered in research and surveillance, with a focus on medically important vectors and pest species.</p>"},{"location":"user-guide/species-database/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/species-database/#accessing-the-species-database","title":"Accessing the Species Database","text":"<ol> <li>Click the Species tab in the main navigation bar</li> <li>The Species Gallery will load, displaying all available species</li> <li>Use the search and filtering tools to find specific species</li> <li>Click on any species card to view detailed information</li> </ol>"},{"location":"user-guide/species-database/#interface-overview","title":"Interface Overview","text":"<p>Gallery View Components: - Search Bar: Text-based search functionality - Species Grid: Responsive grid of species cards - Loading Indicators: Visual feedback during data loading - Filter Options: Advanced filtering capabilities</p> <p>Species Card Information: - Species Image: High-quality reference photograph - Scientific Name: Current accepted taxonomic name - Common Name: Vernacular names in multiple languages - Vector Status: Medical importance rating (High/Medium/Low/Unknown) - Quick Facts: Key identifying characteristics</p>"},{"location":"user-guide/species-database/#search-functionality","title":"Search Functionality","text":""},{"location":"user-guide/species-database/#basic-text-search","title":"Basic Text Search","text":"<p>How to Search: 1. Enter Search Terms: Type in the search box at the top of the gallery 2. Search Criteria: The system searches across:    - Scientific names (genus and species)    - Common names in multiple languages    - Alternative names and synonyms    - Geographic regions</p> <ol> <li>Execute Search: Click the \"Search\" button or press Enter</li> <li>View Results: Filtered species appear in the grid below</li> </ol>"},{"location":"user-guide/species-database/#search-examples","title":"Search Examples","text":"<p>Scientific Name Search: - <code>Aedes aegypti</code> - Find the yellow fever mosquito - <code>Aedes</code> - Find all Aedes species - <code>aegypti</code> - Find species with \"aegypti\" in the name - <code>Anopheles gambiae</code> - Find the African malaria mosquito</p> <p>Common Name Search: - <code>yellow fever</code> - Find species associated with yellow fever - <code>malaria</code> - Find malaria vectors - <code>tiger mosquito</code> - Find Asian tiger mosquito - <code>house mosquito</code> - Find common house mosquitoes</p> <p>Geographic Search: - <code>African</code> - Find species from Africa - <code>Asian</code> - Find Asian species - <code>tropical</code> - Find tropical species - <code>urban</code> - Find urban-adapted species</p>"},{"location":"user-guide/species-database/#advanced-search-tips","title":"Advanced Search Tips","text":"<p>Partial Matching: - Search terms don't need to be complete words - <code>Culex</code> finds all Culex species - <code>albopictus</code> finds Aedes albopictus and related species</p> <p>Multiple Terms: - Use spaces to search for multiple terms - <code>Aedes tropical</code> finds Aedes species in tropical regions - <code>vector malaria</code> finds malaria vectors</p> <p>Case Insensitive: - Search is not case-sensitive - <code>aedes</code>, <code>Aedes</code>, and <code>AEDES</code> all work the same</p>"},{"location":"user-guide/species-database/#species-information","title":"Species Information","text":""},{"location":"user-guide/species-database/#species-card-details","title":"Species Card Details","text":"<p>Each species card in the gallery provides:</p> <p>Visual Information: - Primary Image: High-quality dorsal view photograph - Image Quality: Professional specimens with clear diagnostic features - Scale Reference: Consistent imaging standards for comparison</p> <p>Taxonomic Information: - Scientific Name: Current accepted binomial nomenclature - Authority: Taxonomic authority and year of description - Common Names: Vernacular names in English and other languages - Synonyms: Alternative scientific names (historical or regional)</p> <p>Medical Importance: - Vector Status Indicators:   - \ud83d\udd34 High Risk: Major disease vectors (e.g., Aedes aegypti, Anopheles gambiae)   - \ud83d\udfe1 Medium Risk: Secondary vectors or regional importance   - \ud83d\udfe2 Low Risk: Minor medical importance or pest species   - \u26aa Unknown: Insufficient data on vector competence</p>"},{"location":"user-guide/species-database/#detailed-species-profiles","title":"Detailed Species Profiles","text":"<p>Click on any species card to access comprehensive information:</p> <p>Morphological Description: - Size: Adult body length and wingspan measurements - Coloration: Detailed color patterns and markings - Diagnostic Features: Key identifying characteristics - Sexual Dimorphism: Differences between males and females - Life Stages: Egg, larval, pupal, and adult characteristics</p> <p>Geographic Distribution: - Native Range: Original geographic distribution - Current Distribution: Present-day global occurrence - Habitat Preferences: Preferred breeding and resting sites - Elevation Range: Altitudinal distribution limits - Climate Requirements: Temperature and humidity preferences</p> <p>Medical and Veterinary Importance: - Disease Transmission: Pathogens transmitted by the species - Vector Competence: Efficiency of pathogen transmission - Epidemiological Role: Importance in disease outbreaks - Control Strategies: Recommended management approaches - Resistance Status: Insecticide resistance information</p> <p>Ecological Information: - Breeding Sites: Preferred larval development habitats - Host Preferences: Blood meal sources and feeding behavior - Activity Patterns: Daily and seasonal activity cycles - Population Dynamics: Factors affecting abundance - Environmental Associations: Relationship with habitat variables</p>"},{"location":"user-guide/species-database/#step-by-step-tutorial-exploring-aedes-aegypti","title":"Step-by-Step Tutorial: Exploring Aedes aegypti","text":"<p>Let's walk through a complete exploration of a major disease vector:</p>"},{"location":"user-guide/species-database/#step-1-search-for-the-species","title":"Step 1: Search for the Species","text":"<ol> <li>Navigate to Species Database: Click the \"Species\" tab</li> <li>Enter Search Term: Type \"Aedes aegypti\" in the search box</li> <li>Execute Search: Click the search button or press Enter</li> <li>Locate Species Card: Find the Aedes aegypti card in the results</li> </ol> <p>Expected Results: - Single species card for Aedes aegypti - High-risk vector status indicator (red) - Clear dorsal view photograph - Scientific and common names displayed</p>"},{"location":"user-guide/species-database/#step-2-review-gallery-information","title":"Step 2: Review Gallery Information","text":"<p>Quick Assessment from Card: - Vector Status: High risk (major disease vector) - Common Names: Yellow fever mosquito, dengue mosquito - Visual Features: Dark mosquito with white markings - Geographic Indicator: Tropical and subtropical distribution</p>"},{"location":"user-guide/species-database/#step-3-access-detailed-profile","title":"Step 3: Access Detailed Profile","text":"<ol> <li>Click Species Card: Click anywhere on the Aedes aegypti card</li> <li>Navigate to Detail View: Detailed species profile loads</li> <li>Explore Sections: Browse through different information categories</li> </ol> <p>Detailed Information Available: - Morphology: Lyre-shaped white markings on thorax, banded legs - Distribution: Pantropical distribution, urban-adapted - Medical Importance: Transmits dengue, Zika, chikungunya, yellow fever - Ecology: Container breeder, anthropophilic, day-biting</p>"},{"location":"user-guide/species-database/#step-4-compare-with-related-species","title":"Step 4: Compare with Related Species","text":"<ol> <li>Return to Gallery: Use browser back button or navigation</li> <li>Search Related Species: Search for \"Aedes albopictus\"</li> <li>Compare Characteristics: Note similarities and differences</li> <li>Understand Relationships: Learn about species complexes</li> </ol> <p>Key Comparisons: - Aedes aegypti vs. Aedes albopictus:   - Both are major vectors   - Different geographic origins (Africa vs. Asia)   - Similar disease transmission capabilities   - Different ecological preferences</p>"},{"location":"user-guide/species-database/#step-5-explore-vector-information","title":"Step 5: Explore Vector Information","text":"<ol> <li>Focus on Medical Importance: Review disease transmission data</li> <li>Check Distribution Maps: Understand global presence</li> <li>Review Control Information: Learn about management strategies</li> <li>Access References: Find scientific literature links</li> </ol>"},{"location":"user-guide/species-database/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/species-database/#filtering-and-sorting","title":"Filtering and Sorting","text":"<p>Vector Status Filtering: - High-Risk Vectors: Focus on major disease vectors - Regional Vectors: Species of local importance - Non-Vectors: Species without known medical importance - Unknown Status: Species requiring further research</p> <p>Geographic Filtering: - Continental Regions: Africa, Asia, Europe, Americas, Oceania - Climate Zones: Tropical, subtropical, temperate - Habitat Types: Urban, rural, forest, wetland - Island vs. Continental: Different biogeographic patterns</p> <p>Taxonomic Filtering: - Genus Level: Aedes, Anopheles, Culex, others - Subgenus: Detailed taxonomic subdivisions - Species Groups: Related species complexes - Recent Additions: Newly described or added species</p>"},{"location":"user-guide/species-database/#comparative-analysis","title":"Comparative Analysis","text":"<p>Species Comparison Tools: - Side-by-Side Viewing: Compare multiple species simultaneously - Morphological Comparison: Detailed feature comparisons - Distribution Overlap: Geographic co-occurrence analysis - Vector Competence: Disease transmission comparisons</p> <p>Identification Assistance: - Key Diagnostic Features: Highlighted identifying characteristics - Similar Species: Commonly confused species pairs - Regional Guides: Species likely in specific areas - Seasonal Occurrence: Temporal activity patterns</p>"},{"location":"user-guide/species-database/#data-export-and-integration","title":"Data Export and Integration","text":"<p>Export Options: - Species Lists: Customizable species inventories - Distribution Data: Geographic occurrence records - Morphological Data: Measurement and character data - Reference Lists: Scientific literature citations</p> <p>Integration with Other Features: - Prediction Results: Link AI identifications to species profiles - Map Visualization: View species distributions geographically - Disease Information: Connect vectors to pathogen data - Observation Records: Link field observations to species data</p>"},{"location":"user-guide/species-database/#mobile-and-field-use","title":"Mobile and Field Use","text":""},{"location":"user-guide/species-database/#mobile-optimization","title":"Mobile Optimization","text":"<p>Responsive Design: - Touch-Friendly Interface: Large buttons and touch targets - Optimized Images: Fast loading on mobile connections - Simplified Navigation: Streamlined mobile experience - Offline Capabilities: Cached data for field use</p> <p>Field Applications: - Quick Species Lookup: Rapid access to identification information - Reference Images: High-quality photos for comparison - Distribution Verification: Check if species occurs in area - Vector Status Check: Immediate medical importance assessment</p>"},{"location":"user-guide/species-database/#offline-access","title":"Offline Access","text":"<p>Preparation for Field Work: 1. Pre-load Species Data: Browse species before going offline 2. Cache Images: Ensure reference photos are available 3. Download Key Information: Save critical species profiles 4. Sync When Connected: Update data when internet is available</p>"},{"location":"user-guide/species-database/#quality-assurance-and-updates","title":"Quality Assurance and Updates","text":""},{"location":"user-guide/species-database/#data-quality-standards","title":"Data Quality Standards","text":"<p>Taxonomic Accuracy: - Expert Review: All species information reviewed by taxonomists - Current Nomenclature: Names updated according to latest revisions - Authority Verification: Taxonomic authorities confirmed - Synonym Management: Historical names properly cross-referenced</p> <p>Image Quality: - Professional Photography: High-resolution, well-lit specimens - Standardized Views: Consistent dorsal, lateral, and detail views - Scale References: Appropriate magnification and scale bars - Quality Control: Images reviewed for accuracy and clarity</p> <p>Information Accuracy: - Literature Review: Information based on peer-reviewed sources - Expert Validation: Content reviewed by subject matter experts - Regular Updates: Information updated as new research emerges - Source Documentation: References provided for all claims</p>"},{"location":"user-guide/species-database/#contributing-to-the-database","title":"Contributing to the Database","text":"<p>Data Contributions: - Species Records: Submit new occurrence data - Images: Contribute high-quality specimen photographs - Distribution Updates: Report range extensions or new localities - Behavioral Observations: Share ecological and behavioral data</p> <p>Quality Standards for Contributions: - Accurate Identification: Species must be properly identified - Complete Metadata: Full collection and observation details - Quality Images: Clear, well-focused photographs - Proper Documentation: Detailed collection information</p>"},{"location":"user-guide/species-database/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/species-database/#search-problems","title":"Search Problems","text":"<p>No Results Found: - Check Spelling: Verify scientific name spelling - Try Partial Terms: Use genus name only (e.g., \"Aedes\") - Use Common Names: Try vernacular names - Clear Filters: Remove any active filters that might exclude results</p> <p>Too Many Results: - Be More Specific: Use full scientific names - Add Geographic Terms: Include location information - Use Vector Status: Filter by medical importance - Combine Search Terms: Use multiple keywords</p>"},{"location":"user-guide/species-database/#display-issues","title":"Display Issues","text":"<p>Images Not Loading: - Check Internet Connection: Ensure stable connectivity - Clear Browser Cache: Remove stored temporary files - Try Different Browser: Test with alternative browser - Disable Extensions: Turn off ad blockers temporarily</p> <p>Slow Performance: - Reduce Search Scope: Use more specific search terms - Close Other Tabs: Free up browser memory - Check Network Speed: Ensure adequate bandwidth - Try During Off-Peak Hours: Avoid high-traffic periods</p>"},{"location":"user-guide/species-database/#mobile-issues","title":"Mobile Issues","text":"<p>Touch Interface Problems: - Zoom Adjustment: Adjust browser zoom level - Screen Orientation: Try both portrait and landscape - Touch Sensitivity: Ensure screen is clean and responsive - Browser Choice: Use Chrome or Safari on mobile</p>"},{"location":"user-guide/species-database/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/species-database/#effective-searching","title":"Effective Searching","text":"<p>Search Strategy: 1. Start Broad: Begin with genus or common name 2. Narrow Down: Add specific terms to refine results 3. Use Multiple Approaches: Try different search terms 4. Verify Results: Cross-check with multiple sources</p> <p>Identification Workflow: 1. Morphological Features: Note key diagnostic characters 2. Geographic Context: Consider collection location 3. Habitat Information: Match ecological preferences 4. Vector Status: Consider medical importance 5. Expert Consultation: Seek verification for critical identifications</p>"},{"location":"user-guide/species-database/#research-applications","title":"Research Applications","text":"<p>Literature Research: - Use Scientific Names: Always use current accepted names - Check Synonyms: Be aware of historical name changes - Verify Distribution: Confirm species occurs in study area - Document Sources: Keep track of information sources</p> <p>Data Management: - Standardize Names: Use consistent taxonomic nomenclature - Record Authorities: Include taxonomic authorities - Update Regularly: Keep species lists current - Cross-Reference: Verify against multiple databases</p>"},{"location":"user-guide/species-database/#integration-with-other-platform-features","title":"Integration with Other Platform Features","text":""},{"location":"user-guide/species-database/#species-prediction-integration","title":"Species Prediction Integration","text":"<p>Workflow: 1. Upload Image: Use prediction tool for unknown specimens 2. Review Results: Check AI prediction confidence 3. Verify with Database: Compare with species profile 4. Confirm Identification: Cross-reference morphological features</p>"},{"location":"user-guide/species-database/#map-visualization-connection","title":"Map Visualization Connection","text":"<p>Geographic Analysis: 1. Species Distribution: View occurrence maps 2. Range Verification: Confirm species presence in area 3. Ecological Context: Understand habitat associations 4. Surveillance Planning: Identify target species for monitoring</p>"},{"location":"user-guide/species-database/#disease-information-links","title":"Disease Information Links","text":"<p>Vector-Pathogen Relationships: 1. Medical Importance: Check vector status 2. Disease Profiles: Access pathogen information 3. Risk Assessment: Evaluate transmission potential 4. Control Strategies: Review management recommendations</p>"},{"location":"user-guide/species-database/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/species-database/#general-questions","title":"General Questions","text":"<p>Q: How many species are in the database? A: The database currently includes 46+ mosquito species, focusing on medically important vectors and common pest species. The collection is continuously expanding based on research priorities and user needs.</p> <p>Q: How current is the taxonomic information? A: Taxonomic information is regularly updated based on the latest systematic research. Names and classifications follow current accepted standards from authoritative taxonomic databases.</p> <p>Q: Can I suggest new species for inclusion? A: Yes! We welcome suggestions for additional species, especially those of regional importance or emerging medical significance. Contact the development team with your recommendations.</p>"},{"location":"user-guide/species-database/#search-and-navigation","title":"Search and Navigation","text":"<p>Q: Why can't I find a specific species? A: The species may not be included in the current database, or you might need to try different search terms. Check spelling, try synonyms, or use partial names. Contact support if you believe a species should be included.</p> <p>Q: How do I search for species in my region? A: Use geographic terms in your search (e.g., \"African Anopheles\" or \"Asian Aedes\"). You can also browse all species and check distribution information in detailed profiles.</p> <p>Q: Can I search by disease transmitted? A: While direct disease search isn't available in the species database, you can search for terms like \"malaria vector\" or \"dengue mosquito\" to find relevant species.</p>"},{"location":"user-guide/species-database/#data-quality-and-accuracy","title":"Data Quality and Accuracy","text":"<p>Q: How reliable is the species information? A: All information is based on peer-reviewed scientific literature and reviewed by expert taxonomists and medical entomologists. Sources are documented and regularly updated.</p> <p>Q: What should I do if I find incorrect information? A: Please report any errors or outdated information through our feedback system. Include specific details about the error and supporting references if available.</p> <p>Q: How do I cite species information from the database? A: Use the provided citation format for the database and include the specific species and access date. Individual species profiles may have additional citation requirements.</p>"},{"location":"user-guide/species-database/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/species-database/#support-resources","title":"Support Resources","text":"<ul> <li>User Documentation: Comprehensive guides and tutorials</li> <li>Search Tips: Advanced search techniques and strategies</li> <li>Video Tutorials: Visual guides for common tasks</li> <li>Community Forum: User discussions and shared experiences</li> </ul>"},{"location":"user-guide/species-database/#expert-consultation","title":"Expert Consultation","text":"<ul> <li>Taxonomic Experts: Professional species identification services</li> <li>Regional Specialists: Local expertise for specific geographic areas</li> <li>Medical Entomologists: Vector competence and disease transmission advice</li> <li>Academic Partnerships: Collaboration with research institutions</li> </ul>"},{"location":"user-guide/species-database/#technical-support","title":"Technical Support","text":"<ul> <li>Bug Reports: Report technical issues and problems</li> <li>Feature Requests: Suggest improvements and new capabilities</li> <li>Training Sessions: Scheduled group training and workshops</li> <li>Custom Development: Specialized features for institutional users</li> </ul>"},{"location":"user-guide/species-database/#next-steps","title":"Next Steps","text":"<p>After mastering the species database:</p> <ol> <li>Explore Disease Information: Learn about vector-borne diseases</li> <li>Use Prediction Tools: Practice species identification with AI</li> <li>Analyze Distribution Patterns: Explore geographic data on maps</li> <li>Contribute Data: Add your observations to the community database</li> </ol> <p>For advanced users: - API Access: Programmatic access to species data - Data Integration: Connect with research databases and workflows - Collaborative Projects: Participate in research initiatives - Expert Networks: Connect with professional entomologists</p>"},{"location":"user-guide/species-prediction/","title":"Species Prediction Guide","text":"<p>Learn how to use CulicidaeLab's AI-powered species identification system to accurately identify mosquito species from photographs.</p>"},{"location":"user-guide/species-prediction/#overview","title":"Overview","text":"<p>The Species Prediction feature uses state-of-the-art machine learning models to identify mosquito species from uploaded images. The system provides confidence scores, alternative predictions, and detailed species information to help you make accurate identifications.</p>"},{"location":"user-guide/species-prediction/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/species-prediction/#step-1-access-the-prediction-page","title":"Step 1: Access the Prediction Page","text":"<ol> <li>Navigate to the Predict tab in the main navigation bar</li> <li>You'll see the species prediction interface with an image upload area</li> </ol>"},{"location":"user-guide/species-prediction/#step-2-prepare-your-image","title":"Step 2: Prepare Your Image","text":"<p>For best results, ensure your mosquito image meets these criteria:</p> <p>Image Quality Requirements: - Resolution: Minimum 224x224 pixels (higher resolution preferred) - Format: JPEG, PNG, or WebP - File Size: Maximum 10MB - Lighting: Good, even lighting without harsh shadows - Focus: Sharp focus on the mosquito specimen - Background: Clean, uncluttered background preferred</p> <p>Specimen Positioning: - Dorsal View: Top-down view showing wing patterns and body markings - Lateral View: Side view showing leg patterns and body profile - Full Specimen: Complete mosquito visible in frame - Scale: Mosquito should fill a significant portion of the image</p>"},{"location":"user-guide/species-prediction/#step-3-upload-your-image","title":"Step 3: Upload Your Image","text":"<ol> <li>Drag and Drop: Drag your image file directly onto the upload area</li> <li>File Browser: Click \"Choose File\" to browse and select your image</li> <li>Camera Capture: Use \"Take Photo\" to capture directly from your device camera (mobile/tablet)</li> </ol> <p>The system will automatically process your image once uploaded.</p>"},{"location":"user-guide/species-prediction/#understanding-prediction-results","title":"Understanding Prediction Results","text":""},{"location":"user-guide/species-prediction/#confidence-scores","title":"Confidence Scores","text":"<p>Each prediction includes a confidence percentage:</p> <ul> <li>90-100%: Very high confidence - likely accurate identification</li> <li>70-89%: High confidence - good identification with minor uncertainty</li> <li>50-69%: Moderate confidence - consider alternative predictions</li> <li>Below 50%: Low confidence - manual verification recommended</li> </ul>"},{"location":"user-guide/species-prediction/#result-components","title":"Result Components","text":"<p>Primary Prediction: - Species name (scientific and common names) - Confidence percentage - Thumbnail of reference image</p> <p>Alternative Predictions: - Up to 5 alternative species suggestions - Ranked by confidence score - Useful for verification and comparison</p> <p>Species Information: - Quick facts about the identified species - Geographic distribution - Medical importance - Link to detailed species profile</p>"},{"location":"user-guide/species-prediction/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/species-prediction/#model-selection","title":"Model Selection","text":"<p>Choose from different AI models based on your needs:</p> <p>Classification Models: - EfficientNet-B4: Best overall accuracy for general identification - ResNet-50: Fast processing with good accuracy - Vision Transformer: Excellent for complex specimens</p> <p>Detection Models: - YOLOv8: Locates mosquitoes in complex images - Faster R-CNN: High accuracy detection with bounding boxes</p> <p>Segmentation Models: - Mask R-CNN: Precise outline detection - U-Net: Detailed specimen segmentation</p>"},{"location":"user-guide/species-prediction/#batch-processing","title":"Batch Processing","text":"<p>Process multiple images simultaneously:</p> <ol> <li>Select \"Batch Upload\" mode</li> <li>Upload up to 20 images at once</li> <li>Review results in a grid layout</li> <li>Export results as CSV or JSON</li> </ol>"},{"location":"user-guide/species-prediction/#api-integration","title":"API Integration","text":"<p>For programmatic access, use the prediction API:</p> <pre><code>import requests\n\n# Upload image for prediction\nurl = \"http://localhost:8000/api/v1/predict\"\nfiles = {\"file\": open(\"mosquito.jpg\", \"rb\")}\nresponse = requests.post(url, files=files)\nresult = response.json()\n\nprint(f\"Species: {result['species']}\")\nprint(f\"Confidence: {result['confidence']:.2%}\")\n</code></pre>"},{"location":"user-guide/species-prediction/#step-by-step-tutorial-identifying-an-aedes-aegypti","title":"Step-by-Step Tutorial: Identifying an Aedes aegypti","text":"<p>Let's walk through a complete identification process:</p>"},{"location":"user-guide/species-prediction/#step-1-image-preparation","title":"Step 1: Image Preparation","text":"<p>Scenario: You have a mosquito specimen collected during field work and need to identify the species.</p> <p>Image Setup: - Place specimen on white background - Use macro lens or close-up mode - Ensure dorsal view is clearly visible - Check that wing patterns and leg markings are sharp</p>"},{"location":"user-guide/species-prediction/#step-2-upload-and-initial-prediction","title":"Step 2: Upload and Initial Prediction","text":"<ol> <li>Navigate to the Predict page</li> <li>Upload your prepared image</li> <li>Wait for processing (typically 2-3 seconds)</li> <li>Review the initial prediction results</li> </ol> <p>Expected Results: - Primary prediction: Aedes aegypti (85% confidence) - Alternative: Aedes albopictus (12% confidence) - Other alternatives with lower confidence</p>"},{"location":"user-guide/species-prediction/#step-3-verify-the-identification","title":"Step 3: Verify the Identification","text":"<p>Key Features to Check: - Lyre-shaped markings: White scales forming lyre pattern on thorax - Leg banding: White bands on legs, especially hind legs - Wing scales: Dark scales with white patches - Size: Medium-sized mosquito (4-7mm)</p> <p>Cross-Reference: 1. Click on the species name to view detailed profile 2. Compare your specimen with reference images 3. Check geographic distribution - is Aedes aegypti found in your area? 4. Review morphological characteristics</p>"},{"location":"user-guide/species-prediction/#step-4-confirm-or-adjust","title":"Step 4: Confirm or Adjust","text":"<p>If Confident in Identification: - Record the species identification - Note the confidence score for your records - Save or export the results</p> <p>If Uncertain: - Try uploading additional angles of the same specimen - Compare with alternative predictions - Consult expert resources or seek professional verification - Consider environmental context (habitat, season, location)</p>"},{"location":"user-guide/species-prediction/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/species-prediction/#low-confidence-scores","title":"Low Confidence Scores","text":"<p>Problem: All predictions show confidence below 50%</p> <p>Solutions: 1. Improve Image Quality:    - Use better lighting    - Increase image resolution    - Ensure sharp focus    - Clean specimen if possible</p> <ol> <li>Try Different Angles:</li> <li>Upload dorsal (top) view</li> <li>Include lateral (side) view</li> <li> <p>Capture close-up of diagnostic features</p> </li> <li> <p>Check Specimen Condition:</p> </li> <li>Damaged specimens may be harder to identify</li> <li>Missing parts (legs, antennae) affect accuracy</li> <li>Consider if specimen is within model training data</li> </ol>"},{"location":"user-guide/species-prediction/#unexpected-results","title":"Unexpected Results","text":"<p>Problem: Prediction doesn't match expected species</p> <p>Troubleshooting Steps: 1. Verify Image Quality: Ensure specimen is clearly visible 2. Check Geographic Range: Is predicted species found in your area? 3. Review Alternatives: Look at other high-confidence predictions 4. Consider Morphological Variation: Some species show significant variation 5. Seek Expert Opinion: Consult with entomologists for difficult cases</p>"},{"location":"user-guide/species-prediction/#technical-issues","title":"Technical Issues","text":"<p>Problem: Upload fails or processing errors</p> <p>Solutions: 1. File Format: Ensure image is in supported format (JPEG, PNG, WebP) 2. File Size: Reduce file size if over 10MB 3. Internet Connection: Check network connectivity 4. Browser Compatibility: Try different browser or clear cache 5. Server Status: Check if service is temporarily unavailable</p>"},{"location":"user-guide/species-prediction/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/species-prediction/#field-collection","title":"Field Collection","text":"<p>Documentation: - Record GPS coordinates of collection site - Note date, time, and weather conditions - Document habitat type and breeding sites - Take multiple photos from different angles</p> <p>Specimen Handling: - Preserve specimens properly for photography - Use appropriate mounting techniques - Avoid damage to diagnostic features - Store specimens in suitable conditions</p>"},{"location":"user-guide/species-prediction/#photography-tips","title":"Photography Tips","text":"<p>Equipment: - Use macro lens or close-up filters - Employ ring flash or diffused lighting - Use tripod for stability - Consider focus stacking for depth of field</p> <p>Technique: - Fill frame with specimen - Ensure even lighting - Capture multiple angles - Include scale reference when possible</p>"},{"location":"user-guide/species-prediction/#data-management","title":"Data Management","text":"<p>Record Keeping: - Save prediction results with metadata - Link predictions to collection records - Track confidence scores over time - Note any manual verifications</p> <p>Quality Control: - Cross-reference with field guides - Seek expert verification for important identifications - Maintain database of verified specimens - Regular calibration with known species</p>"},{"location":"user-guide/species-prediction/#integration-with-other-features","title":"Integration with Other Features","text":""},{"location":"user-guide/species-prediction/#map-visualization","title":"Map Visualization","text":"<p>Link your predictions to geographic data:</p> <ol> <li>After species identification, click \"Add to Map\"</li> <li>Enter collection coordinates</li> <li>View your observation on the interactive map</li> <li>Contribute to community surveillance data</li> </ol>"},{"location":"user-guide/species-prediction/#species-database","title":"Species Database","text":"<p>Explore detailed species information:</p> <ol> <li>Click species name in prediction results</li> <li>Access comprehensive species profile</li> <li>View distribution maps and habitat information</li> <li>Learn about medical importance and control measures</li> </ol>"},{"location":"user-guide/species-prediction/#disease-information","title":"Disease Information","text":"<p>Understand vector potential:</p> <ol> <li>Check if identified species is a disease vector</li> <li>Access disease profiles for relevant pathogens</li> <li>Review prevention and control strategies</li> <li>Understand public health implications</li> </ol>"},{"location":"user-guide/species-prediction/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/species-prediction/#general-questions","title":"General Questions","text":"<p>Q: How accurate are the AI predictions? A: Our models achieve &gt;90% accuracy on test datasets, but real-world performance varies based on image quality and specimen condition. Always consider confidence scores and verify important identifications.</p> <p>Q: Can I identify larvae or pupae? A: Currently, the system is optimized for adult mosquitoes. Larval and pupal identification requires different approaches and is not yet supported.</p> <p>Q: What species are included in the database? A: The system can identify 46 mosquito species commonly found in research and surveillance contexts. The database focuses on medically important species and common pest species.</p>"},{"location":"user-guide/species-prediction/#technical-questions","title":"Technical Questions","text":"<p>Q: Can I use the system offline? A: The web interface requires internet connectivity. However, the models can be deployed locally for offline use with appropriate technical setup.</p> <p>Q: Is there a mobile app? A: The web interface is mobile-responsive and works well on smartphones and tablets. A dedicated mobile app is under consideration for future development.</p> <p>Q: Can I contribute training data? A: Yes! We welcome high-quality, verified specimens to improve model performance. Contact the development team for contribution guidelines.</p>"},{"location":"user-guide/species-prediction/#data-and-privacy","title":"Data and Privacy","text":"<p>Q: What happens to my uploaded images? A: Images are processed for identification but not permanently stored unless you explicitly choose to contribute them to the database. See our privacy policy for details.</p> <p>Q: Can I access my prediction history? A: Currently, predictions are not stored long-term. We recommend saving important results locally. User accounts with history tracking are planned for future releases.</p> <p>Q: Is the service free to use? A: Yes, CulicidaeLab is open source and free for research, education, and public health applications.</p>"},{"location":"user-guide/species-prediction/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/species-prediction/#support-resources","title":"Support Resources","text":"<ul> <li>Documentation: Comprehensive guides and API documentation</li> <li>GitHub Issues: Report bugs and request features</li> <li>Community Forum: Ask questions and share experiences</li> <li>Email Support: Direct contact for specific issues</li> </ul>"},{"location":"user-guide/species-prediction/#expert-consultation","title":"Expert Consultation","text":"<p>For challenging identifications or research applications:</p> <ul> <li>Academic Partnerships: Collaborate with entomology departments</li> <li>Professional Networks: Connect with medical entomologists</li> <li>Taxonomic Experts: Consult with mosquito systematists</li> <li>Public Health Agencies: Work with vector control professionals</li> </ul>"},{"location":"user-guide/species-prediction/#training-and-workshops","title":"Training and Workshops","text":"<ul> <li>Online Tutorials: Video guides for common workflows</li> <li>Webinars: Regular training sessions for new users</li> <li>Workshops: In-person training for research groups</li> <li>Certification: Proficiency certification for professional use</li> </ul>"},{"location":"user-guide/species-prediction/#next-steps","title":"Next Steps","text":"<p>After mastering species prediction:</p> <ol> <li>Explore Map Visualization: Learn to visualize and analyze geographic patterns</li> <li>Study Disease Information: Understand vector-pathogen relationships</li> <li>Contribute Data: Add your observations to the community database</li> <li>Advanced Analysis: Use API for custom applications and research workflows</li> </ol> <p>For technical users: - API Documentation: Complete reference for programmatic access - Model Details: Technical specifications and performance metrics - Integration Guides: Connect with existing research workflows - Development: Contribute to open source development</p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Comprehensive solutions for common issues and problems encountered while using the CulicidaeLab platform.</p>"},{"location":"user-guide/troubleshooting/#quick-problem-solver","title":"Quick Problem Solver","text":""},{"location":"user-guide/troubleshooting/#most-common-issues","title":"Most Common Issues","text":"<ol> <li>Image Upload Problems - Files won't upload or process</li> <li>Map Not Loading - Interactive map fails to display</li> <li>Slow Performance - Platform responds slowly</li> <li>Login/Access Issues - Can't access features</li> <li>Data Import Errors - Files won't import properly</li> </ol>"},{"location":"user-guide/troubleshooting/#emergency-checklist","title":"Emergency Checklist","text":"<p>Before diving into detailed troubleshooting:</p> <ul> <li> Refresh the page (Ctrl+F5 or Cmd+Shift+R)</li> <li> Check internet connection - Try loading other websites</li> <li> Clear browser cache - Remove stored temporary files</li> <li> Try different browser - Test with Chrome, Firefox, or Safari</li> <li> Disable browser extensions - Turn off ad blockers and other extensions</li> <li> Check file formats - Ensure files meet platform requirements</li> </ul>"},{"location":"user-guide/troubleshooting/#browser-and-system-issues","title":"Browser and System Issues","text":""},{"location":"user-guide/troubleshooting/#browser-compatibility","title":"Browser Compatibility","text":"<p>Supported Browsers: - Chrome: Version 90+ (Recommended) - Firefox: Version 88+ - Safari: Version 14+ - Edge: Version 90+</p> <p>Unsupported Browsers: - Internet Explorer (all versions) - Chrome versions below 90 - Mobile browsers with limited JavaScript support</p>"},{"location":"user-guide/troubleshooting/#browser-configuration","title":"Browser Configuration","text":"<p>Required Settings: - JavaScript: Must be enabled - Cookies: Allow cookies from the platform domain - Local Storage: Enable local storage for session data - WebGL: Required for map visualization (usually enabled by default)</p> <p>Recommended Settings: - Pop-up Blocker: Allow pop-ups from the platform - Download Settings: Allow automatic downloads for exports - Camera/Microphone: Allow access for image capture features</p>"},{"location":"user-guide/troubleshooting/#clearing-browser-data","title":"Clearing Browser Data","text":"<p>Chrome: 1. Press Ctrl+Shift+Delete (Cmd+Shift+Delete on Mac) 2. Select \"All time\" for time range 3. Check \"Cookies and other site data\" and \"Cached images and files\" 4. Click \"Clear data\"</p> <p>Firefox: 1. Press Ctrl+Shift+Delete (Cmd+Shift+Delete on Mac) 2. Select \"Everything\" for time range 3. Check \"Cookies\" and \"Cache\" 4. Click \"Clear Now\"</p> <p>Safari: 1. Go to Safari &gt; Preferences &gt; Privacy 2. Click \"Manage Website Data\" 3. Find the platform domain and click \"Remove\" 4. Or click \"Remove All\" for complete clearing</p>"},{"location":"user-guide/troubleshooting/#image-upload-issues","title":"Image Upload Issues","text":""},{"location":"user-guide/troubleshooting/#file-format-problems","title":"File Format Problems","text":"<p>Supported Formats: - JPEG (.jpg, .jpeg) - PNG (.png) - WebP (.webp) - TIFF (.tif, .tiff) - Limited support</p> <p>Common Format Issues: - HEIC/HEIF: iPhone photos in HEIC format need conversion - RAW Files: Camera RAW files (.cr2, .nef, .arw) not supported - Animated Images: GIF animations not supported for prediction - Corrupted Files: Damaged image files won't process</p> <p>Solutions: 1. Convert Format: Use image editing software to convert to JPEG or PNG 2. iPhone Users: Change camera settings to \"Most Compatible\" format 3. Check File Integrity: Try opening image in other applications first</p>"},{"location":"user-guide/troubleshooting/#file-size-limitations","title":"File Size Limitations","text":"<p>Size Limits: - Maximum File Size: 10MB per image - Recommended Size: 1-5MB for optimal performance - Minimum Resolution: 224x224 pixels - Maximum Resolution: 4096x4096 pixels (larger images auto-resized)</p> <p>Reducing File Size: 1. Resize Image: Reduce pixel dimensions 2. Compress JPEG: Lower quality setting (70-85% recommended) 3. Crop Image: Remove unnecessary background areas 4. Use Online Tools: TinyPNG, JPEG-Optimizer, or similar services</p>"},{"location":"user-guide/troubleshooting/#upload-process-issues","title":"Upload Process Issues","text":"<p>Problem: Upload starts but fails partway through</p> <p>Solutions: 1. Check Internet Connection: Ensure stable, fast connection 2. Try Smaller Files: Upload one image at a time 3. Disable VPN: VPN connections may cause timeouts 4. Use Wired Connection: More stable than WiFi for large uploads</p> <p>Problem: Upload completes but processing fails</p> <p>Solutions: 1. Check Image Content: Ensure image contains visible mosquito 2. Improve Image Quality: Better lighting and focus 3. Try Different Angle: Upload dorsal (top-down) view 4. Reduce Background Clutter: Crop to focus on specimen</p>"},{"location":"user-guide/troubleshooting/#map-display-problems","title":"Map Display Problems","text":""},{"location":"user-guide/troubleshooting/#map-wont-load","title":"Map Won't Load","text":"<p>Symptoms: - Blank gray area where map should appear - \"Map failed to load\" error message - Infinite loading spinner</p> <p>Solutions: 1. Check WebGL Support:    - Visit webglreport.com to test WebGL    - Update graphics drivers if WebGL fails    - Try different browser if WebGL unavailable</p> <ol> <li>Network Issues:</li> <li>Check firewall settings</li> <li>Disable VPN temporarily</li> <li> <p>Try different network connection</p> </li> <li> <p>Browser Issues:</p> </li> <li>Clear browser cache and cookies</li> <li>Disable browser extensions</li> <li>Try incognito/private browsing mode</li> </ol>"},{"location":"user-guide/troubleshooting/#map-performance-issues","title":"Map Performance Issues","text":"<p>Problem: Map is slow or unresponsive</p> <p>Solutions: 1. Reduce Data Load:    - Apply more restrictive filters    - Zoom to smaller geographic areas    - Limit date ranges to recent periods</p> <ol> <li>Browser Optimization:</li> <li>Close unnecessary browser tabs</li> <li>Restart browser</li> <li> <p>Free up system memory</p> </li> <li> <p>Graphics Settings:</p> </li> <li>Update graphics drivers</li> <li>Reduce browser zoom level</li> <li>Disable hardware acceleration if causing issues</li> </ol>"},{"location":"user-guide/troubleshooting/#missing-map-data","title":"Missing Map Data","text":"<p>Problem: Map loads but shows no observation points</p> <p>Troubleshooting: 1. Check Filters: Verify filters aren't excluding all data 2. Zoom Level: Some data only visible at certain zoom levels 3. Date Range: Ensure date filters include periods with data 4. Geographic Area: Confirm you're looking at areas with observations</p>"},{"location":"user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/troubleshooting/#slow-loading-times","title":"Slow Loading Times","text":"<p>Common Causes: - Large datasets being processed - Slow internet connection - Browser performance issues - Server load during peak times</p> <p>Solutions: 1. Optimize Filters:    - Use more specific species filters    - Limit geographic scope    - Reduce date ranges</p> <ol> <li>Browser Optimization:</li> <li>Close unused tabs and applications</li> <li>Clear browser cache</li> <li> <p>Restart browser periodically</p> </li> <li> <p>Connection Optimization:</p> </li> <li>Use wired internet connection</li> <li>Close bandwidth-heavy applications</li> <li>Try during off-peak hours</li> </ol>"},{"location":"user-guide/troubleshooting/#memory-issues","title":"Memory Issues","text":"<p>Symptoms: - Browser becomes unresponsive - \"Out of memory\" error messages - Frequent browser crashes</p> <p>Solutions: 1. Reduce Memory Usage:    - Close unnecessary browser tabs    - Restart browser regularly    - Use 64-bit browser version</p> <ol> <li>System Optimization:</li> <li>Close other applications</li> <li>Increase virtual memory</li> <li> <p>Add more RAM if possible</p> </li> <li> <p>Data Management:</p> </li> <li>Process smaller datasets</li> <li>Use pagination for large results</li> <li>Export data for offline analysis</li> </ol>"},{"location":"user-guide/troubleshooting/#authentication-problems","title":"Authentication Problems","text":""},{"location":"user-guide/troubleshooting/#login-issues","title":"Login Issues","text":"<p>Problem: Can't log in or access restricted features</p> <p>Solutions: 1. Check Credentials:    - Verify username/email and password    - Check for caps lock or typing errors    - Try password reset if needed</p> <ol> <li>Browser Issues:</li> <li>Enable cookies and JavaScript</li> <li>Clear browser cache</li> <li> <p>Try different browser</p> </li> <li> <p>Account Status:</p> </li> <li>Check email for account verification</li> <li>Ensure account hasn't been suspended</li> <li>Contact support for account issues</li> </ol>"},{"location":"user-guide/troubleshooting/#session-timeouts","title":"Session Timeouts","text":"<p>Problem: Frequently logged out or session expires</p> <p>Solutions: 1. Browser Settings:    - Enable cookies for the platform    - Don't use private/incognito mode for long sessions    - Keep browser tab active</p> <ol> <li>Security Settings:</li> <li>Check if security software is blocking cookies</li> <li>Whitelist the platform domain</li> <li>Disable overly aggressive privacy settings</li> </ol>"},{"location":"user-guide/troubleshooting/#data-import-problems","title":"Data Import Problems","text":""},{"location":"user-guide/troubleshooting/#file-format-issues","title":"File Format Issues","text":"<p>Problem: Import file rejected or fails validation</p> <p>Solutions: 1. Check File Format:    - Use CSV format for best compatibility    - Ensure proper encoding (UTF-8 recommended)    - Verify column headers match expected format</p> <ol> <li>Data Validation:</li> <li>Check for required fields (species, coordinates, date)</li> <li>Validate coordinate formats (decimal degrees)</li> <li> <p>Ensure date formats are consistent</p> </li> <li> <p>File Structure:</p> </li> <li>Remove empty rows and columns</li> <li>Check for special characters in data</li> <li>Ensure consistent delimiter usage</li> </ol>"},{"location":"user-guide/troubleshooting/#data-quality-errors","title":"Data Quality Errors","text":"<p>Common Validation Errors: - Invalid coordinates (outside valid ranges) - Unrecognized species names - Invalid date formats - Missing required fields</p> <p>Solutions: 1. Coordinate Issues:    - Use decimal degrees format (e.g., 25.7617, -80.1918)    - Check latitude/longitude aren't swapped    - Ensure coordinates are within valid ranges</p> <ol> <li>Species Names:</li> <li>Use full scientific names</li> <li>Check spelling against taxonomic databases</li> <li> <p>Include authority information if available</p> </li> <li> <p>Date Formats:</p> </li> <li>Use ISO format (YYYY-MM-DD)</li> <li>Ensure dates are reasonable (not future dates)</li> <li>Check for typos in date fields</li> </ol>"},{"location":"user-guide/troubleshooting/#species-prediction-issues","title":"Species Prediction Issues","text":""},{"location":"user-guide/troubleshooting/#low-confidence-predictions","title":"Low Confidence Predictions","text":"<p>Problem: All predictions show low confidence scores</p> <p>Solutions: 1. Improve Image Quality:    - Use better lighting (natural light preferred)    - Ensure sharp focus on specimen    - Remove background clutter    - Try different angles (dorsal view recommended)</p> <ol> <li>Specimen Preparation:</li> <li>Clean specimen if possible</li> <li>Position for clear view of diagnostic features</li> <li> <p>Ensure specimen is complete (not damaged)</p> </li> <li> <p>Technical Factors:</p> </li> <li>Use higher resolution images</li> <li>Ensure proper file format</li> <li>Check internet connection for upload</li> </ol>"},{"location":"user-guide/troubleshooting/#unexpected-predictions","title":"Unexpected Predictions","text":"<p>Problem: Prediction doesn't match expected species</p> <p>Troubleshooting: 1. Verify Image Quality: Ensure specimen is clearly visible 2. Check Geographic Range: Is predicted species found in your area? 3. Review Alternatives: Look at other high-confidence predictions 4. Consider Variation: Some species show significant morphological variation</p>"},{"location":"user-guide/troubleshooting/#processing-errors","title":"Processing Errors","text":"<p>Problem: Image uploads but prediction fails</p> <p>Solutions: 1. Image Content: Ensure image contains visible mosquito 2. File Integrity: Try re-saving and uploading image 3. Browser Issues: Clear cache and try again 4. Server Load: Try again during off-peak hours</p>"},{"location":"user-guide/troubleshooting/#mobile-device-issues","title":"Mobile Device Issues","text":""},{"location":"user-guide/troubleshooting/#touch-interface-problems","title":"Touch Interface Problems","text":"<p>Common Issues: - Difficulty with map navigation - Upload buttons not responding - Text input problems</p> <p>Solutions: 1. Browser Choice: Use Chrome or Safari on mobile 2. Screen Orientation: Try both portrait and landscape modes 3. Touch Sensitivity: Ensure screen is clean and responsive 4. Zoom Level: Adjust browser zoom for better touch targets</p>"},{"location":"user-guide/troubleshooting/#camera-integration","title":"Camera Integration","text":"<p>Problem: Can't access device camera for image capture</p> <p>Solutions: 1. Permissions: Allow camera access when prompted 2. Browser Settings: Check camera permissions in browser settings 3. App Conflicts: Close other camera apps 4. Hardware Issues: Test camera in other apps</p>"},{"location":"user-guide/troubleshooting/#performance-on-mobile","title":"Performance on Mobile","text":"<p>Optimization Tips: - Close other apps to free memory - Use WiFi instead of cellular data when possible - Reduce image sizes before upload - Use simplified map views for better performance</p>"},{"location":"user-guide/troubleshooting/#network-and-connectivity-issues","title":"Network and Connectivity Issues","text":""},{"location":"user-guide/troubleshooting/#slow-internet-connection","title":"Slow Internet Connection","text":"<p>Symptoms: - Long loading times - Upload timeouts - Incomplete data loading</p> <p>Solutions: 1. Connection Optimization:    - Use wired connection when possible    - Move closer to WiFi router    - Avoid peak usage times</p> <ol> <li>Data Management:</li> <li>Upload smaller files</li> <li>Use lower resolution images</li> <li>Process data in smaller batches</li> </ol>"},{"location":"user-guide/troubleshooting/#firewall-and-security-software","title":"Firewall and Security Software","text":"<p>Problem: Platform blocked by security software</p> <p>Solutions: 1. Whitelist Domain: Add platform URL to allowed sites 2. Disable Temporarily: Turn off security software for testing 3. Check Corporate Firewall: Contact IT department for access 4. VPN Issues: Try disabling VPN temporarily</p>"},{"location":"user-guide/troubleshooting/#error-messages-and-codes","title":"Error Messages and Codes","text":""},{"location":"user-guide/troubleshooting/#common-error-messages","title":"Common Error Messages","text":"<p>\"Network Error\" or \"Connection Failed\" - Check internet connection - Try refreshing the page - Disable VPN or proxy</p> <p>\"File Too Large\" - Reduce image file size - Use image compression tools - Try uploading smaller batches</p> <p>\"Invalid File Format\" - Convert to supported format (JPEG, PNG) - Check file isn't corrupted - Ensure proper file extension</p> <p>\"Processing Failed\" - Try uploading different image - Check image contains visible specimen - Wait and try again (may be temporary server issue)</p>"},{"location":"user-guide/troubleshooting/#http-error-codes","title":"HTTP Error Codes","text":"<p>404 - Not Found - Check URL spelling - Clear browser cache - Try accessing from main page</p> <p>500 - Internal Server Error - Temporary server issue - Try again in a few minutes - Contact support if persistent</p> <p>503 - Service Unavailable - Server maintenance in progress - Check status page for updates - Try again later</p>"},{"location":"user-guide/troubleshooting/#getting-additional-help","title":"Getting Additional Help","text":""},{"location":"user-guide/troubleshooting/#self-help-resources","title":"Self-Help Resources","text":"<p>Documentation: - User guides and tutorials - FAQ database - Video tutorials - Community forum</p> <p>Diagnostic Tools: - Browser compatibility checker - Network speed test - File format validator - System requirements checker</p>"},{"location":"user-guide/troubleshooting/#contact-support","title":"Contact Support","text":"<p>Before Contacting Support: 1. Try the solutions in this guide 2. Note exact error messages 3. Record steps to reproduce the problem 4. Check browser and system information</p> <p>Support Channels: - Email Support: Include detailed problem description - GitHub Issues: For bug reports and feature requests - Community Forum: For general questions and discussions - Live Chat: Available during business hours</p> <p>Information to Include: - Operating system and version - Browser type and version - Exact error messages - Steps to reproduce the problem - Screenshots if helpful</p>"},{"location":"user-guide/troubleshooting/#community-resources","title":"Community Resources","text":"<p>User Forum: - Search existing discussions - Ask questions and share solutions - Connect with other users - Share tips and best practices</p> <p>Documentation Feedback: - Report errors or unclear instructions - Suggest improvements - Contribute examples and tutorials - Help maintain accuracy</p>"},{"location":"user-guide/troubleshooting/#prevention-and-best-practices","title":"Prevention and Best Practices","text":""},{"location":"user-guide/troubleshooting/#regular-maintenance","title":"Regular Maintenance","text":"<p>Browser Maintenance: - Clear cache and cookies weekly - Keep browser updated - Manage extensions and add-ons - Regular restart of browser</p> <p>System Maintenance: - Keep operating system updated - Maintain adequate free disk space - Regular antivirus scans - Monitor system performance</p>"},{"location":"user-guide/troubleshooting/#data-backup","title":"Data Backup","text":"<p>Important Data: - Export important datasets regularly - Save prediction results locally - Backup custom configurations - Document important workflows</p>"},{"location":"user-guide/troubleshooting/#optimal-usage-patterns","title":"Optimal Usage Patterns","text":"<p>Performance Tips: - Use platform during off-peak hours - Process data in reasonable batch sizes - Close unnecessary applications - Use recommended browsers and settings</p> <p>Quality Practices: - Prepare data before import - Validate results regularly - Follow naming conventions - Document procedures and settings</p>"},{"location":"user-guide/troubleshooting/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"user-guide/troubleshooting/#general-troubleshooting","title":"General Troubleshooting","text":"<p>Q: Why is the platform running slowly? A: Performance can be affected by internet speed, browser performance, dataset size, and server load. Try the optimization steps in the Performance Issues section.</p> <p>Q: My browser says the site is not secure. Is it safe? A: Ensure you're accessing the correct URL with HTTPS. If you see security warnings, don't enter sensitive information and contact support.</p> <p>Q: Can I use the platform on my tablet or phone? A: Yes, the platform is mobile-responsive, but some features work better on desktop computers. Use the latest version of Chrome or Safari on mobile devices.</p>"},{"location":"user-guide/troubleshooting/#technical-issues","title":"Technical Issues","text":"<p>Q: What should I do if I get a \"JavaScript error\"? A: Enable JavaScript in your browser, clear the cache, and try again. If the problem persists, try a different browser.</p> <p>Q: Why can't I see the map? A: This usually indicates a WebGL or graphics issue. Update your graphics drivers, try a different browser, or check if WebGL is supported at webglreport.com.</p> <p>Q: My uploads keep failing. What's wrong? A: Check file size (under 10MB), format (JPEG/PNG), and internet connection. Try uploading one file at a time and ensure the image contains a clear mosquito specimen.</p>"},{"location":"user-guide/troubleshooting/#data-and-results","title":"Data and Results","text":"<p>Q: Why are my prediction results inconsistent? A: Prediction accuracy depends on image quality, specimen condition, and species complexity. Use high-quality images and consider confidence scores when interpreting results.</p> <p>Q: Can I recover deleted data? A: Deleted data cannot be recovered unless you have local backups. Always export important data before making changes.</p> <p>Q: Why don't I see any data on the map for my region? A: Data availability varies by region based on research and surveillance activities. You can contribute observations to help fill gaps in coverage.</p> <p>This troubleshooting guide covers the most common issues users encounter. If you can't find a solution here, don't hesitate to contact our support team or check the community forum for additional help.</p>"}]}